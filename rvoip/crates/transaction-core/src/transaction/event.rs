/// # Transaction Events
///
/// This module defines the events that flow from the transaction layer to the Transaction User (TU)
/// as defined in RFC 3261. These events represent the key communication mechanism between
/// the transaction layer and higher layers of a SIP stack.
///
/// ## RFC 3261 Context
///
/// RFC 3261 Section 17 defines the transaction layer as an intermediary between the transport
/// layer and the Transaction User (TU). The transaction layer is responsible for:
///
/// 1. Matching responses to client transactions
/// 2. Matching requests to server transactions
/// 3. Absorbing retransmissions at the transaction level
/// 4. Implementing transaction state machines and timers
///
/// When significant events occur within a transaction (receiving messages, state changes,
/// timeouts, etc.), the transaction layer must inform the TU through a well-defined set
/// of events, which this module implements.
///
/// ## Event Flow in the SIP Stack
///
/// ```text
///                  +----------------+
///                  | Transaction    |
///                  | User (TU)      |
///                  +----------------+
///                          ^
///                          | TransactionEvents
///                          |
///                  +----------------+
///                  | Transaction    |
///                  | Layer          |
///                  +----------------+
///                          ^
///                          | SIP Messages
///                          |
///                  +----------------+
///                  | Transport      |
///                  | Layer          |
///                  +----------------+
/// ```
///
/// ## Event Categories
///
/// The events in this module fall into several categories:
///
/// 1. **Request Events**: Notify the TU about incoming requests (NewRequest, AckReceived, etc.)
/// 2. **Response Events**: Notify the TU about responses to its requests (ProvisionalResponse, SuccessResponse, etc.)
/// 3. **State Events**: Inform the TU about transaction state changes (StateChanged, TransactionTerminated)
/// 4. **Error Events**: Report transport or processing errors (TransportError, Error)
/// 5. **Timeout Events**: Indicate when transaction timers expire (TransactionTimeout)
///
/// These events provide the TU with all the information it needs to implement proper SIP
/// dialog and session behavior without having to understand the complexities of the
/// transaction state machines.

use std::net::SocketAddr;
use std::fmt;
use rvoip_sip_core::prelude::{Request, Response, Message, Method, StatusCode, Uri, Version};

use crate::transaction::{TransactionKey, TransactionState};

/// Represents events generated by the transaction layer, intended for consumption by a
/// Transaction User (TU), such as a session layer or higher-level application logic.
///
/// These events inform the TU about incoming requests, responses, state changes,
/// errors, and timeouts related to SIP transactions.
#[derive(Debug, Clone)]
pub enum TransactionEvent {
    // --- Request Processing (Events primarily for Server Transactions) ---
    /// An ACK request was received, matching an Invite Server Transaction that had previously
    /// sent a non-2xx final response.
    ///
    /// This typically signals the completion of the INVITE transaction if it was in the
    /// `Completed` state (after sending a 2xx) or `Confirmed` state (after sending a non-2xx).
    /// The transaction might move to `Terminated`.
    AckReceived {
        /// The unique identifier for the server transaction that received the ACK.
        transaction_id: TransactionKey,
        /// The ACK request message.
        request: Request,
    },
    /// A CANCEL request was received for an existing Invite Server Transaction.
    ///
    /// The TU should attempt to stop processing the original INVITE if possible and
    /// respond to the INVITE with a 487 (Request Terminated) and to the CANCEL with a 200 OK.
    /// The transaction layer handles responding to the CANCEL if the TU doesn't.
    CancelReceived {
        /// The unique identifier for the server transaction for which the CANCEL was received.
        transaction_id: TransactionKey,
        /// The CANCEL request message.
        cancel_request: Request,
    },

    // --- Response Processing (Events primarily for Client Transactions) ---
    /// A provisional (1xx) response was received for an active client transaction.
    ///
    /// For example, a "100 Trying" or "180 Ringing" response to an INVITE.
    ProvisionalResponse {
        /// The unique identifier for the client transaction that received the response.
        transaction_id: TransactionKey,
        /// The provisional response message.
        response: Response,
    },
    /// A successful final (2xx) response was received for an active client transaction.
    ///
    /// If this response is for an INVITE transaction, the TU is responsible for generating
    /// and sending an ACK request. This can be done using `TransactionManager::send_ack_for_2xx()`.
    SuccessResponse {
        /// The unique identifier for the client transaction that received the response.
        transaction_id: TransactionKey,
        /// The successful final response message (e.g., "200 OK").
        response: Response,
        /// Flag indicating whether an ACK is needed for this response (true for 2xx to INVITE)
        need_ack: bool,
        /// The network address from which the response was received.
        source: SocketAddr,
    },
    /// A failure final (3xx, 4xx, 5xx, 6xx) response was received for an active client transaction.
    ///
    /// The transaction will typically move to a `Completed` or `Terminated` state.
    FailureResponse {
        /// The unique identifier for the client transaction that received the response.
        transaction_id: TransactionKey,
        /// The failure response message (e.g., "404 Not Found", "503 Service Unavailable").
        response: Response,
    },
    
    /// A generic response event, primarily for maintaining compatibility with older code or for
    /// scenarios where the distinction between provisional, success, or failure is handled
    /// uniformly by the TU. It's generally recommended to use the more specific response events.
    #[deprecated(note = "Prefer ProvisionalResponse, SuccessResponse, or FailureResponse")]
    Response {
        /// The unique identifier for the client transaction that received the response.
        transaction_id: TransactionKey,
        /// The SIP response message.
        response: Response,
        /// The network address from which the response was received.
        source: SocketAddr,
    },

    // --- Response Sending (Informational events, primarily for Server Transactions) ---
    /// Informs the TU that a provisional response was successfully sent by a server transaction.
    /// This is an informational event; the transaction layer handles the actual sending.
    ProvisionalResponseSent {
        /// The unique identifier for the server transaction that sent the response.
        transaction_id: TransactionKey,
        /// The provisional response that was sent.
        response: Response,
    },
    /// Informs the TU that a final response was successfully sent by a server transaction.
    /// This is an informational event; the transaction layer handles the actual sending.
    FinalResponseSent {
        /// The unique identifier for the server transaction that sent the response.
        transaction_id: TransactionKey,
        /// The final response that was sent.
        response: Response,
    },

    // --- State, Error, and Timeout Events ---
    /// A transaction-specific timer has expired, leading to a timeout condition.
    ///
    /// For example:
    /// * INVITE Client: Timer B (timeout awaiting final response).
    /// * Non-INVITE Client: Timer F (timeout awaiting final response).
    /// * INVITE Server: Timer G (timeout for retransmitting 2xx if ACK not received).
    /// * Non-INVITE Server: Timer J (timeout for retransmitting non-2xx if no further request).
    /// The transaction typically moves to a `Terminated` state.
    TransactionTimeout {
        /// The unique identifier for the transaction that timed out.
        transaction_id: TransactionKey,
    },
    /// A generic timeout event, primarily for maintaining compatibility.
    /// Prefer `TransactionTimeout` or `AckTimeout` for more specific timeout information.
    #[deprecated(note = "Prefer TransactionTimeout or AckTimeout")]
    Timeout {
        /// The unique identifier for the transaction that timed out.
        transaction_id: TransactionKey,
    },
    /// An ACK was not received in time for a 2xx final response sent by an Invite Server Transaction.
    /// This is specifically related to Timer G expiring. The server might stop retransmitting the 2xx.
    /// The RFC indicates the server should behave as if an ACK *was* received for state machine purposes.
    AckTimeout {
        /// The unique identifier for the Invite Server Transaction that did not receive an ACK.
        transaction_id: TransactionKey,
    },
    /// A transport layer error occurred that is associated with this transaction.
    ///
    /// This usually means the message could not be sent or a critical network error occurred.
    /// The transaction is typically terminated.
    TransportError {
        /// The unique identifier for the transaction affected by the transport error.
        transaction_id: TransactionKey,
        // TODO: Consider adding a `source_error: Arc<rvoip_transport::Error>` field here.
    },
    /// An internal error occurred within the transaction state machine or processing logic.
    /// This may indicate a bug or unexpected condition.
    Error {
        /// The unique identifier for the transaction, if the error is associated with one.
        transaction_id: Option<TransactionKey>,
        /// A description of the error.
        error: String, // Consider using a dedicated, clonable error type from `crate::Error`.
    },
    /// A SIP request was received that did not match any existing server transaction
    /// and could not be processed to create a new one (e.g., invalid format, method not supported for new transactions).
    /// It might also be a request that matches a transaction in a state that cannot handle it (e.g. Terminated).
    StrayRequest {
        /// The received SIP request.
        request: Request,
        /// The network address from which the request was received.
        source: SocketAddr,
    },
    /// A SIP response was received that did not match any existing client transaction.
    /// This could be due to a late-arriving response for an already terminated transaction
    /// or a response to a request never sent.
    StrayResponse {
        /// The received SIP response.
        response: Response,
        /// The network address from which the response was received.
        source: SocketAddr,
    },
    /// An ACK request was received that did not match any active Invite Server Transaction.
    /// This is usually ignored by the transaction layer, but the TU might want to be informed for logging or diagnostics.
    StrayAck {
        /// The received ACK request.
         request: Request,
        /// The network address from which the ACK was received.
         source: SocketAddr,
    },
     /// A CANCEL request was received that did not match any active Invite Server Transaction.
     /// The transaction layer automatically responds with a "481 Call/Transaction Does Not Exist".
     /// This event informs the TU that such a CANCEL was received and handled.
    StrayCancel {
        /// The received CANCEL request.
         request: Request,
        /// The network address from which the CANCEL was received.
         source: SocketAddr,
    },

    // --- Transaction Lifecycle Events ---
    /// The transaction has concluded its operation and entered the `Terminated` state.
    ///
    /// The TU should consider this transaction complete and can perform any necessary cleanup.
    /// The `TransactionManager` will typically remove the transaction from its active list shortly after this event.
    TransactionTerminated {
        /// The unique identifier for the transaction that has terminated.
        transaction_id: TransactionKey,
    },
    
    /// A generic terminated event, primarily for maintaining compatibility.
    /// Prefer `TransactionTerminated`.
    #[deprecated(note = "Prefer TransactionTerminated")]
    Terminated {
        /// The unique identifier for the transaction that has terminated.
        transaction_id: TransactionKey,
    },
    
    /// Indicates that a transaction has changed its internal state.
    ///
    /// This event allows the TU to observe the progression of the transaction through its
    /// lifecycle states (e.g., `Trying` -> `Proceeding` -> `Completed` -> `Terminated`).
    /// Useful for detailed logging, monitoring, or advanced state-dependent logic in the TU.
    StateChanged {
        /// The unique identifier for the transaction whose state changed.
        transaction_id: TransactionKey,
        /// The state of the transaction before the change.
        previous_state: TransactionState,
        /// The new current state of the transaction.
        new_state: TransactionState,
    },

    // --- Timer Events (Primarily for internal use by the Transaction Layer) ---
    /// An internal event used by the transaction layer to trigger its timer-based logic.
    ///
    /// This event is typically not directly consumed by the TU but is part of the
    /// `TransactionEvent` enum as it can be observed if the TU is subscribing to all
    /// events from the transaction manager.
    #[doc(hidden)] // Indicates this is not typically for direct TU consumption.
    TimerTriggered {
        /// The unique identifier for the transaction associated with the timer.
        transaction_id: TransactionKey,
        /// A string identifying the specific timer that fired (e.g., "A", "B", "Timer_F", "Timer_G").
        timer: String, 
    },

    /// A CANCEL request has been received that matches an active INVITE transaction.
    /// The TU should attempt to cancel the INVITE request's processing.
    CancelRequest {
        /// The unique identifier for the CANCEL server transaction.
        transaction_id: TransactionKey,
        /// The transaction ID of the INVITE transaction being canceled.
        target_transaction_id: TransactionKey,
        /// The CANCEL request
        request: Request,
        /// The network address from which the request was received.
        source: SocketAddr,
    },
    
    /// An ACK request for a 2xx response has been received.
    /// Since these ACKs are end-to-end, they don't belong to the transaction,
    /// but the TU needs to know about them.
    AckRequest {
        /// The transaction ID of the original INVITE transaction.
        transaction_id: TransactionKey,
        /// The ACK request.
        request: Request,
        /// The network address from which the request was received.
        source: SocketAddr,
    },
    
    /// An INVITE request has been received and a new server transaction has been created.
    InviteRequest {
        /// The unique identifier for the newly created INVITE server transaction.
        transaction_id: TransactionKey,
        /// The INVITE request.
        request: Request,
        /// The network address from which the request was received.
        source: SocketAddr,
    },
    
    /// A non-INVITE request has been received and a new server transaction has been created.
    NonInviteRequest {
        /// The unique identifier for the newly created non-INVITE server transaction.
        transaction_id: TransactionKey,
        /// The non-INVITE request.
        request: Request,
        /// The network address from which the request was received.
        source: SocketAddr,
    },
    
    /// An ACK request was received that did not match any active INVITE server transaction.
    /// This is usually sent directly to the TU since ACKs for 2xx don't have transactions.
    StrayAckRequest {
        /// The received ACK request.
        request: Request,
        /// The network address from which the ACK was received.
        source: SocketAddr,
    },
}

#[cfg(test)]
mod tests {
    use super::*;
    use rvoip_sip_core::types::uri::Uri;
    use rvoip_sip_core::types::method::Method;

    #[test]
    fn it_builds_provisional_response_event() {
        let response = Response::new(StatusCode::Trying);
        let event = TransactionEvent::ProvisionalResponse {
            transaction_id: TransactionKey::new("branch123".to_string(), Method::Invite, false),
            response,
        };
        assert!(matches!(event, TransactionEvent::ProvisionalResponse { .. }));
    }

    #[test]
    fn it_builds_success_response_event() {
        let response = Response::new(StatusCode::Ok);
        let event = TransactionEvent::SuccessResponse {
            transaction_id: TransactionKey::new("branch456".to_string(), Method::Invite, false),
            response,
            need_ack: true,
            source: "127.0.0.1:5060".parse().unwrap(),
        };
        assert!(matches!(event, TransactionEvent::SuccessResponse { .. }));
    }

    #[test]
    fn it_builds_failure_response_event() {
        let response = Response::new(StatusCode::NotFound);
        let event = TransactionEvent::FailureResponse {
            transaction_id: TransactionKey::new("branch789".to_string(), Method::Invite, false),
            response,
        };
        assert!(matches!(event, TransactionEvent::FailureResponse { .. }));
    }

    #[test]
    fn it_builds_ack_received_event() {
        let request = Request::new(Method::Ack, Uri::sip("test.com"));
        let event = TransactionEvent::AckReceived {
            transaction_id: TransactionKey::new("branch112".to_string(), Method::Invite, true),
            request,
        };
        assert!(matches!(event, TransactionEvent::AckReceived { .. }));
    }

    #[test]
    fn it_builds_cancel_received_event() {
        let request = Request::new(Method::Cancel, Uri::sip("test.com"));
        let event = TransactionEvent::CancelReceived {
            transaction_id: TransactionKey::new("branch113".to_string(), Method::Invite, true),
            cancel_request: request,
        };
        assert!(matches!(event, TransactionEvent::CancelReceived { .. }));
    }

    #[test]
    fn it_builds_state_changed_event() {
        let event = TransactionEvent::StateChanged {
            transaction_id: TransactionKey::new("branch223".to_string(), Method::Invite, false),
            previous_state: TransactionState::Calling,
            new_state: TransactionState::Proceeding,
        };
        assert!(matches!(event, TransactionEvent::StateChanged { .. }));
    }

    #[test]
    fn it_builds_timer_triggered_event() {
        let event = TransactionEvent::TimerTriggered {
            transaction_id: TransactionKey::new("branch334".to_string(), Method::Invite, false),
            timer: "TimerA".to_string(),
        };
        assert!(matches!(event, TransactionEvent::TimerTriggered { .. }));
    }

    #[test]
    fn it_builds_transport_error_event() {
        let event = TransactionEvent::TransportError {
            transaction_id: TransactionKey::new("branch445".to_string(), Method::Invite, false),
        };
        assert!(matches!(event, TransactionEvent::TransportError { .. }));
    }

    #[test]
    fn it_builds_transaction_timeout_event() {
        let event = TransactionEvent::TransactionTimeout {
            transaction_id: TransactionKey::new("branch556".to_string(), Method::Invite, false),
        };
        assert!(matches!(event, TransactionEvent::TransactionTimeout { .. }));
    }

    #[test]
    fn it_builds_transaction_terminated_event() {
        let event = TransactionEvent::TransactionTerminated {
            transaction_id: TransactionKey::new("branch667".to_string(), Method::Invite, false),
        };
        assert!(matches!(event, TransactionEvent::TransactionTerminated { .. }));
    }

    #[test]
    fn it_builds_error_event() {
        let event = TransactionEvent::Error {
            transaction_id: Some(TransactionKey::new("branch778".to_string(), Method::Invite, false)),
            error: "Something went wrong".to_string(),
        };
        assert!(matches!(event, TransactionEvent::Error { .. }));
    }
} 