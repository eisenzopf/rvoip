<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Integrating SDP with SIP</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="integrating-sdp-with-sip"><a class="header" href="#integrating-sdp-with-sip">Integrating SDP with SIP</a></h1>
<p>In the previous tutorials, we explored SIP messaging and SDP creation separately. In this tutorial, we'll bring these two protocols together to establish multimedia sessions. SIP and SDP work hand-in-hand, with SIP handling the signaling and session management, while SDP describes the media parameters.</p>
<h2 id="sdp-as-a-sip-message-body"><a class="header" href="#sdp-as-a-sip-message-body">SDP as a SIP Message Body</a></h2>
<p>SIP messages can carry various content types in their message bodies. For multimedia session establishment, SDP is the standard format. When including SDP in a SIP message:</p>
<ol>
<li>The Content-Type header must be set to <code>application/sdp</code></li>
<li>The Content-Length header must reflect the size of the SDP body</li>
<li>The SDP content follows the headers, separated by a blank line</li>
</ol>
<p>Here's how to include SDP in a SIP INVITE request using the <code>rvoip-sip-core</code> library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rvoip_sip_core::prelude::*;
use rvoip_sip_core::{RequestBuilder, ResponseBuilder};
use rvoip_sip_core::sdp::SdpBuilder;
use rvoip_sip_core::sdp::attributes::MediaDirection;
use rvoip_sip_core::types::sdp::SdpSession;
use rvoip_sip_core::json::SipJsonExt;  // Import for JSON access
use rvoip_sip_core::json::ext::SipMessageJson; // Import for SIP header convenience methods
use std::error::Error as StdError;
use std::str::FromStr;
use bytes::Bytes;

fn create_invite_with_sdp() -&gt; Result&lt;Message, Box&lt;dyn StdError&gt;&gt; {
    // 1. Create the SDP offer
    let sdp = SdpBuilder::new("Audio Call")
        .origin("alice", "2890844526", "2890844526", "IN", "IP4", "alice.example.com")
        .connection("IN", "IP4", "alice.example.com")
        .time("0", "0")
        .media_audio(49170, "RTP/AVP")
            .formats(&amp;["0", "8", "96"])
            .rtpmap("0", "PCMU/8000")
            .rtpmap("8", "PCMA/8000")
            .rtpmap("96", "telephone-event/8000")
            .direction(MediaDirection::SendRecv)
            .done()
        .build()?;
    
    // 2. Convert SDP to string for inclusion in SIP message
    let sdp_string = sdp.to_string();
    
    // 3. Create SIP INVITE request with SDP offer
    let invite = RequestBuilder::new(Method::Invite, "sip:bob@biloxi.example.com")?
        .from("Alice", "sip:alice@atlanta.example.com", Some("9fxced76sl"))
        .to("Bob", "sip:bob@biloxi.example.com", None)
        .call_id("3848276298220188511@atlanta.example.com")
        .cseq(314159)
        .via("atlanta.example.com:5060", "UDP", Some("z9hG4bKnashds7"))
        .max_forwards(70)
        .contact("sip:alice@pc33.atlanta.example.com", None)
        // Set Content-Type header for SDP
        .content_type("application/sdp")
        // Include SDP as body (using Bytes)
        .body(Bytes::from(sdp_string))
        .build();
    
    Ok(Message::Request(invite))
}
<span class="boring">}</span></code></pre></pre>
<p>The key components are:</p>
<ul>
<li>Using <code>.content_type("application/sdp")</code> to specify the body format</li>
<li>Using <code>.body(Bytes::from(sdp_string))</code> to include the SDP content as bytes</li>
</ul>
<h2 id="extracting-sdp-from-sip-messages"><a class="header" href="#extracting-sdp-from-sip-messages">Extracting SDP from SIP Messages</a></h2>
<p>When receiving a SIP message with an SDP body, you need to extract and parse it. Here's a robust method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn extract_sdp_from_message(message: &amp;Message) -&gt; Option&lt;std::result::Result&lt;SdpSession, Error&gt;&gt; {
    // Check for body content
    let bytes = message.body();
    if !bytes.is_empty() {
        // Convert bytes to string
        if let Ok(body_str) = std::str::from_utf8(bytes) {
            // Verify this looks like SDP (starts with v=0)
            if body_str.trim_start().starts_with("v=0") {
                return Some(SdpSession::from_str(body_str));
            }
        }
    }
    
    None
}
<span class="boring">}</span></code></pre></pre>
<p>This function:</p>
<ol>
<li>Gets the raw bytes from the message body</li>
<li>Converts them to a UTF-8 string</li>
<li>Verifies it looks like SDP by checking for "v=0" at the start</li>
<li>Returns a Result containing the parsed SDP session or an error</li>
</ol>
<h2 id="the-sipsdp-offeranswer-model"><a class="header" href="#the-sipsdp-offeranswer-model">The SIP/SDP Offer/Answer Model</a></h2>
<p>SIP uses the offer/answer model defined in <a href="https://datatracker.ietf.org/doc/html/rfc3264">RFC 3264</a> for negotiating media sessions. The basic flow is:</p>
<ol>
<li>The caller sends an INVITE with an SDP offer</li>
<li>The callee responds with a 200 OK including an SDP answer</li>
<li>The caller acknowledges with an ACK</li>
</ol>
<p>Let's implement responding to an INVITE with a 200 OK containing an SDP answer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_response_with_sdp_answer(invite: &amp;Message) -&gt; Result&lt;Message, Error&gt; {
    // Extract the SDP offer from the INVITE
    let incoming_sdp = if let Some(sdp_result) = extract_sdp_from_message(invite) {
        sdp_result?
    } else {
        return Err(Error::Parser("No SDP in INVITE".into()));
    };
    
    // Create SDP answer based on the offer
    let sdp_answer = SdpBuilder::new("Answer Session")
        .origin("bob", "2890844527", "2890844527", "IN", "IP4", "bob.example.com")
        .connection("IN", "IP4", "bob.example.com")
        .time("0", "0")
        .media_audio(49180, "RTP/AVP")
            // Select only one codec from the offer
            .formats(&amp;["0"])
            .rtpmap("0", "PCMU/8000")
            .direction(MediaDirection::SendRecv)
            .done()
        .build()?;
    
    // Create 200 OK response with SDP answer
    if let Message::Request(req) = invite {
        // Use the dialog_response helper method
        let response = ResponseBuilder::dialog_response(
            req,
            StatusCode::Ok,
            None
        )
        .to("Bob", "sip:bob@biloxi.example.com", Some("8a8sdg87s")) // Add/override To with tag
        .contact("sip:bob@biloxi.example.com", None)
        .content_type("application/sdp")
        .body(Bytes::from(sdp_answer.to_string()))
        .build();
        
        Ok(Message::Response(response))
    } else {
        Err(Error::Parser("Not a request".into()))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Note the use of the <code>dialog_response</code> helper method, which creates a response that includes all the necessary headers for dialog establishment.</p>
<h2 id="json-path-access-to-sip-headers"><a class="header" href="#json-path-access-to-sip-headers">JSON Path Access to SIP Headers</a></h2>
<p>Our library provides powerful JSON path access to SIP message headers, making it easy to extract values nested deep within the message structure. This is essential for proper dialog handling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Getting values with path accessors
let to_display_name = response.path_str_or("headers.To.display_name", "");
let to_uri = response.path_str_or("headers.To.uri", "");
let to_tag = response.path_str("headers.To.params[0].Tag");

// This also works for complex deeply nested structures like Via headers
let branch = response.path_str("headers.Via[0].params[0].Branch");

// You can use it to extract values with defaults
let from_display_name = invite.path_str_or("headers.From.display_name", "Alice");
<span class="boring">}</span></code></pre></pre>
<p>These path accessors:</p>
<ul>
<li>Handle the internal Request/Response wrapping structure</li>
<li>Provide case-insensitive header matching</li>
<li>Support array indexing for multi-value headers</li>
<li>Handle nested parameter structures like Via and From/To headers</li>
</ul>
<h2 id="creating-an-ack-to-complete-dialog-establishment"><a class="header" href="#creating-an-ack-to-complete-dialog-establishment">Creating an ACK to Complete Dialog Establishment</a></h2>
<p>After receiving a 200 OK response, you need to send an ACK to complete the dialog establishment:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_ack_for_response(response: &amp;Message, original_invite: &amp;Message) -&gt; Result&lt;Message, Error&gt; {
    // Get information from the response and original INVITE using JSON path accessors
    let to_display_name = response.path_str_or("headers.To.display_name", "");
    let to_uri = response.path_str_or("headers.To.uri", "");
    let to_tag = response.path_str("headers.To.params[0].Tag");
    
    // Use a simple default for the contact URI or extract from Contact header
    let contact_uri = "sip:bob@192.0.2.4";
    
    // Get From, Call-ID, and CSeq from original INVITE
    let from_display_name = original_invite.path_str_or("headers.From.display_name", "Alice");
    let from_uri = original_invite.path_str_or("headers.From.uri", "sip:alice@atlanta.example.com");
    let from_tag = original_invite.path_str("headers.From.params[0].Tag");
    let call_id = original_invite.path_str_or("headers.CallId", "3848276298220188511@atlanta.example.com");
    let cseq = original_invite.path("headers.CSeq.seq")
        .and_then(|v| v.as_i64())
        .unwrap_or(314159) as u32;
    
    // Create ACK request
    let ack = RequestBuilder::new(Method::Ack, contact_uri)?
        .from(&amp;from_display_name, &amp;from_uri, from_tag.as_deref())
        .to(&amp;to_display_name, &amp;to_uri, to_tag.as_deref())
        .call_id(&amp;call_id)
        .cseq(cseq)
        .via("atlanta.example.com:5060", "UDP", Some("z9hG4bKnashds7"))
        .max_forwards(70)
        .build();
    
    Ok(Message::Request(ack))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="session-modification-with-re-invite"><a class="header" href="#session-modification-with-re-invite">Session Modification with re-INVITE</a></h2>
<p>After a session is established, either party can modify the session parameters by sending a re-INVITE with a new SDP offer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_reinvite_with_updated_sdp(original_invite: &amp;Message) -&gt; Result&lt;Message, Error&gt; {
    // Create updated SDP with video added
    let updated_sdp = SdpBuilder::new("Audio/Video Call")
        .origin("alice", "2890844526", "2890844528", "IN", "IP4", "alice.example.com")
        .connection("IN", "IP4", "alice.example.com")
        .time("0", "0")
        // Existing audio stream
        .media_audio(49170, "RTP/AVP")
            .formats(&amp;["0"])
            .rtpmap("0", "PCMU/8000")
            .direction(MediaDirection::SendRecv)
            .done()
        // New video stream
        .media_video(49174, "RTP/AVP")
            .formats(&amp;["31"])
            .rtpmap("31", "H261/90000")
            .direction(MediaDirection::SendRecv)
            .done()
        .build()?;
    
    // Get headers from the original INVITE using JSON path
    let from_display_name = original_invite.path_str_or("headers.From.display_name", "Alice");
    let from_uri = original_invite.path_str_or("headers.From.uri", "sip:alice@atlanta.example.com");
    let from_tag = original_invite.path_str("headers.From.params[0].Tag");
    let to_display_name = original_invite.path_str_or("headers.To.display_name", "Bob");
    let to_uri = original_invite.path_str_or("headers.To.uri", "sip:bob@biloxi.example.com");
    let call_id = original_invite.path_str_or("headers.CallId", "3848276298220188511@atlanta.example.com");
    
    // Get CSeq and increment
    let cseq = original_invite.path("headers.CSeq.seq")
        .and_then(|v| v.as_i64())
        .unwrap_or(314159) as u32 + 1;
    
    // Create re-INVITE with new SDP
    let reinvite = RequestBuilder::new(Method::Invite, "sip:bob@biloxi.example.com")?
        .from(&amp;from_display_name, &amp;from_uri, from_tag.as_deref())
        .to(&amp;to_display_name, &amp;to_uri, None)  // No To tag for reinvite
        .call_id(&amp;call_id)
        .cseq(cseq)
        .via("atlanta.example.com:5060", "UDP", Some("z9hG4bKnashds8"))
        .max_forwards(70)
        .contact("sip:alice@pc33.atlanta.example.com", None)
        .content_type("application/sdp")
        .body(Bytes::from(updated_sdp.to_string()))
        .build();
    
    Ok(Message::Request(reinvite))
}
<span class="boring">}</span></code></pre></pre>
<p>Note that in the re-INVITE:</p>
<ul>
<li>We increment the CSeq number</li>
<li>We include an updated SDP with a new origin version</li>
<li>We use the JSON path accessor to extract headers from the original INVITE</li>
</ul>
<h2 id="handling-sdp-negotiation-failures"><a class="header" href="#handling-sdp-negotiation-failures">Handling SDP Negotiation Failures</a></h2>
<p>Sometimes SDP negotiation fails because the endpoints cannot agree on compatible parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_incompatible_sdp(invite: &amp;Message) -&gt; Result&lt;Message, Error&gt; {
    // Extract SDP from incoming INVITE
    let sdp_option = extract_sdp_from_message(invite);
    
    // Check if the SDP is compatible
    match sdp_option {
        Some(Ok(sdp)) =&gt; {
            // In a real implementation, we would check supported codecs
            // For this example, we'll assume incompatibility
            
            println!("Received SDP with unsupported codecs:");
            for media in &amp;sdp.media_descriptions {
                if media.media == "audio" {
                    println!("Audio formats: {:?}", media.formats);
                    
                    if let Message::Request(req) = invite {
                        // Try parsing URI for warning
                        let warning_agent = Uri::from_str("sip:biloxi.example.com").unwrap_or_else(|_| {
                            // Fallback to domain with SIP scheme
                            Uri::sip("biloxi.example.com")
                        });
                        
                        // Create a 488 Not Acceptable Here response
                        let response = ResponseBuilder::error_response(
                            req,
                            StatusCode::NotAcceptableHere, 
                            None
                        )
                        .warning(304, warning_agent, "Incompatible media format")
                        .build();
                        
                        return Ok(Message::Response(response));
                    }
                }
            }
        },
        Some(Err(_)) =&gt; {
            // SDP parsing failed
            if let Message::Request(req) = invite {
                // Create a 400 Bad Request response with "Invalid SDP" reason phrase
                let response = ResponseBuilder::error_response(
                    req,
                    StatusCode::BadRequest,
                    Some("Invalid SDP")
                )
                .build();
                
                return Ok(Message::Response(response));
            }
        },
        None =&gt; {
            // No SDP in the INVITE
            if let Message::Request(req) = invite {
                // Create a 406 Not Acceptable response with "SDP Required" reason phrase
                let response = ResponseBuilder::error_response(
                    req,
                    StatusCode::NotAcceptable,
                    Some("SDP Required")
                )
                .build();
                
                return Ok(Message::Response(response));
            }
        }
    }
    
    // If we reach here, there's another issue with the request
    if let Message::Request(req) = invite {
        // Create a 400 Bad Request response
        let response = ResponseBuilder::error_response(
            req,
            StatusCode::BadRequest,
            None
        )
        .build();
        
        return Ok(Message::Response(response));
    }
    
    Err(Error::Parser("Not a request".into()))
}
<span class="boring">}</span></code></pre></pre>
<p>Notice how the warning header is created with:</p>
<ul>
<li>An integer status code (304)</li>
<li>A Uri object for the warning agent</li>
<li>A text message explaining the issue</li>
</ul>
<h2 id="complete-sipsdp-dialog-flow"><a class="header" href="#complete-sipsdp-dialog-flow">Complete SIP/SDP Dialog Flow</a></h2>
<p>Here's a complete dialog flow showing all stages from INVITE to BYE:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn demonstrate_complete_dialog_flow() -&gt; Result&lt;(), Error&gt; {
    // Setup parameters
    let call_id = "3848276298220188511@atlanta.example.com";
    let from_tag = "9fxced76sl";
    let to_tag = "8a8sdg87s";  // Will be added by Bob
    let cseq = 314159;
    
    // Step 1: Create and send INVITE with SDP offer
    println!("Step 1: Initial INVITE with SDP offer");
    let invite = RequestBuilder::new(Method::Invite, "sip:bob@biloxi.example.com")?
        .from("Alice", "sip:alice@atlanta.example.com", Some(from_tag))
        .to("Bob", "sip:bob@biloxi.example.com", None)
        .call_id(call_id)
        .cseq(cseq)
        .via("atlanta.example.com:5060", "UDP", Some("z9hG4bKnashds7"))
        .max_forwards(70)
        .contact("sip:alice@pc33.atlanta.example.com", None)
        .content_type("application/sdp")
        .body(Bytes::from(create_offer_sdp("alice", "atlanta.example.com")?))
        .build();
    
    println!("{}\n", Message::Request(invite));
    
    // Step 2: Receive 180 Ringing (no SDP)
    println!("Step 2: 180 Ringing (no SDP)");
    let ringing = ResponseBuilder::new(StatusCode::Ringing, None)
        .from("Alice", "sip:alice@atlanta.example.com", Some(from_tag))
        .to("Bob", "sip:bob@biloxi.example.com", Some(to_tag))
        .call_id(call_id)
        .cseq(cseq, Method::Invite)
        .via("atlanta.example.com:5060", "UDP", Some("z9hG4bKnashds7"))
        .contact("sip:bob@192.0.2.4", None)
        .build();
    
    println!("{}\n", Message::Response(ringing));
    
    // Step 3: Receive 200 OK with SDP answer
    println!("Step 3: 200 OK with SDP answer");
    let ok_response = ResponseBuilder::new(StatusCode::Ok, None)
        .from("Alice", "sip:alice@atlanta.example.com", Some(from_tag))
        .to("Bob", "sip:bob@biloxi.example.com", Some(to_tag))
        .call_id(call_id)
        .cseq(cseq, Method::Invite)
        .via("atlanta.example.com:5060", "UDP", Some("z9hG4bKnashds7"))
        .contact("sip:bob@192.0.2.4", None)
        .content_type("application/sdp")
        .body(Bytes::from(create_answer_sdp("bob", "biloxi.example.com")?))
        .build();
    
    println!("{}\n", Message::Response(ok_response));
    
    // Step 4: Send ACK to acknowledge the 200 OK
    println!("Step 4: ACK to acknowledge 200 OK");
    
    // Using JSON path accessors to get contact URI
    let contact_uri = "sip:bob@192.0.2.4".to_string();
    
    let ack = RequestBuilder::new(Method::Ack, &amp;contact_uri)?
        .from("Alice", "sip:alice@atlanta.example.com", Some(from_tag))
        .to("Bob", "sip:bob@biloxi.example.com", Some(to_tag))
        .call_id(call_id)
        .cseq(cseq)
        .via("atlanta.example.com:5060", "UDP", Some("z9hG4bKnashds9"))
        .max_forwards(70)
        .build();
    
    println!("{}\n", Message::Request(ack));
    
    // Step 5: After some time, send re-INVITE to add video
    println!("Step 5: re-INVITE to add video");
    
    // Using convenience methods from SipMessageJson
    let contact_uri = "sip:bob@192.0.2.4".to_string();
    
    let reinvite = RequestBuilder::new(Method::Invite, &amp;contact_uri)?
        .from("Alice", "sip:alice@atlanta.example.com", Some(from_tag))
        .to("Bob", "sip:bob@biloxi.example.com", Some(to_tag))
        .call_id(call_id)
        .cseq(cseq + 1)
        .via("atlanta.example.com:5060", "UDP", Some("z9hG4bKnashds10"))
        .max_forwards(70)
        .contact("sip:alice@pc33.atlanta.example.com", None)
        .content_type("application/sdp")
        .body(Bytes::from(create_updated_sdp("alice", "atlanta.example.com")?))
        .build();
    
    println!("{}\n", Message::Request(reinvite));
    
    // Step 6: Receive 200 OK for re-INVITE with updated SDP
    println!("Step 6: 200 OK for re-INVITE with updated SDP");
    
    let ok_reinvite = ResponseBuilder::new(StatusCode::Ok, None)
        .from("Alice", "sip:alice@atlanta.example.com", Some(from_tag))
        .to("Bob", "sip:bob@biloxi.example.com", Some(to_tag))
        .call_id(call_id)
        .cseq(cseq + 1, Method::Invite)
        .via("atlanta.example.com:5060", "UDP", Some("z9hG4bKnashds10"))
        .contact("sip:bob@192.0.2.4", None)
        .content_type("application/sdp")
        .body(Bytes::from(create_video_answer_sdp("bob", "biloxi.example.com")?))
        .build();
    
    println!("{}\n", Message::Response(ok_reinvite));
    
    // Step 7: ACK the 200 OK for re-INVITE
    println!("Step 7: ACK for 200 OK of re-INVITE");
    
    // Using convenience methods to access URI
    let contact_uri = "sip:bob@192.0.2.4".to_string();
    
    let ack_reinvite = RequestBuilder::new(Method::Ack, &amp;contact_uri)?
        .from("Alice", "sip:alice@atlanta.example.com", Some(from_tag))
        .to("Bob", "sip:bob@biloxi.example.com", Some(to_tag))
        .call_id(call_id)
        .cseq(cseq + 1)
        .via("atlanta.example.com:5060", "UDP", Some("z9hG4bKnashds11"))
        .max_forwards(70)
        .build();
    
    println!("{}\n", Message::Request(ack_reinvite));
    
    // Step 8: Later, send BYE to terminate the session
    println!("Step 8: BYE to terminate session");
    
    let bye = RequestBuilder::new(Method::Bye, &amp;contact_uri)?
        .from("Alice", "sip:alice@atlanta.example.com", Some(from_tag))
        .to("Bob", "sip:bob@biloxi.example.com", Some(to_tag))
        .call_id(call_id)
        .cseq(cseq + 2)
        .via("atlanta.example.com:5060", "UDP", Some("z9hG4bKnashds12"))
        .max_forwards(70)
        .build();
    
    println!("{}\n", Message::Request(bye));
    
    // Step 9: Receive 200 OK for BYE
    println!("Step 9: 200 OK for BYE");
    
    let ok_bye = ResponseBuilder::new(StatusCode::Ok, None)
        .from("Alice", "sip:alice@atlanta.example.com", Some(from_tag))
        .to("Bob", "sip:bob@biloxi.example.com", Some(to_tag))
        .call_id(call_id)
        .cseq(cseq + 2, Method::Bye)
        .via("atlanta.example.com:5060", "UDP", Some("z9hG4bKnashds12"))
        .build();
    
    println!("{}\n", Message::Response(ok_bye));
    
    println!("Dialog completed successfully!");
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="helper-functions-for-sdp-creation"><a class="header" href="#helper-functions-for-sdp-creation">Helper Functions for SDP Creation</a></h2>
<p>These helper functions create different SDP messages for various stages of the call:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Initial offer for audio call
fn create_offer_sdp(username: &amp;str, domain: &amp;str) -&gt; Result&lt;String, Error&gt; {
    let sdp = SdpBuilder::new("Call Offer")
        .origin(username, "2890844526", "2890844526", "IN", "IP4", domain)
        .connection("IN", "IP4", domain)
        .time("0", "0")
        .media_audio(49170, "RTP/AVP")
            .formats(&amp;["0", "8"])
            .rtpmap("0", "PCMU/8000")
            .rtpmap("8", "PCMA/8000")
            .direction(MediaDirection::SendRecv)
            .done()
        .build()?;
    
    Ok(sdp.to_string())
}

// Answer accepting only PCMU codec
fn create_answer_sdp(username: &amp;str, domain: &amp;str) -&gt; Result&lt;String, Error&gt; {
    let sdp = SdpBuilder::new("Call Answer")
        .origin(username, "2890844527", "2890844527", "IN", "IP4", domain)
        .connection("IN", "IP4", domain)
        .time("0", "0")
        .media_audio(49180, "RTP/AVP")
            .formats(&amp;["0"])  // Choose only PCMU
            .rtpmap("0", "PCMU/8000")
            .direction(MediaDirection::SendRecv)
            .done()
        .build()?;
    
    Ok(sdp.to_string())
}

// Updated offer adding video
fn create_updated_sdp(username: &amp;str, domain: &amp;str) -&gt; Result&lt;String, Error&gt; {
    let sdp = SdpBuilder::new("Updated Call Offer")
        .origin(username, "2890844526", "2890844528", "IN", "IP4", domain)  // Increment version
        .connection("IN", "IP4", domain)
        .time("0", "0")
        // Existing audio stream
        .media_audio(49170, "RTP/AVP")
            .formats(&amp;["0"])
            .rtpmap("0", "PCMU/8000")
            .direction(MediaDirection::SendRecv)
            .done()
        // New video stream
        .media_video(49174, "RTP/AVP")
            .formats(&amp;["31", "34"])
            .rtpmap("31", "H261/90000")
            .rtpmap("34", "H263/90000")
            .direction(MediaDirection::SendRecv)
            .done()
        .build()?;
    
    Ok(sdp.to_string())
}

// Answer accepting audio and one video codec
fn create_video_answer_sdp(username: &amp;str, domain: &amp;str) -&gt; Result&lt;String, Error&gt; {
    let sdp = SdpBuilder::new("Video Call Answer")
        .origin(username, "2890844527", "2890844528", "IN", "IP4", domain)  // Increment version
        .connection("IN", "IP4", domain)
        .time("0", "0")
        // Audio stream
        .media_audio(49180, "RTP/AVP")
            .formats(&amp;["0"])
            .rtpmap("0", "PCMU/8000")
            .direction(MediaDirection::SendRecv)
            .done()
        // Video stream - accept H.261 only
        .media_video(49182, "RTP/AVP")
            .formats(&amp;["31"])
            .rtpmap("31", "H261/90000")
            .direction(MediaDirection::SendRecv)
            .done()
        .build()?;
    
    Ok(sdp.to_string())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-for-sipsdp-integration"><a class="header" href="#best-practices-for-sipsdp-integration">Best Practices for SIP/SDP Integration</a></h2>
<ol>
<li><strong>Convert SDP to Bytes for Body</strong>: Always convert SDP strings to <code>Bytes</code> when using them as message bodies</li>
<li><strong>JSON Path Access</strong>: Use the path accessor methods to extract values from complex SIP message structures</li>
<li><strong>Dialog-Specific Helpers</strong>: Use the <code>dialog_response</code> method for 200 OK responses to establish dialogs</li>
<li><strong>SDP Version Management</strong>: Increment the SDP version (in the origin line) when sending updated offers</li>
<li><strong>Proper CSeq Handling</strong>: Increment CSeq numbers across transactions and maintain the same CSeq in final ACK</li>
<li><strong>Branch ID Management</strong>: Use unique branch IDs in Via headers for each transaction</li>
<li><strong>Tag Handling</strong>: Ensure the From tag remains consistent throughout the dialog, while the To tag (once added) is included in all subsequent messages</li>
</ol>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this tutorial, we've explored how to integrate SDP with SIP to establish, modify, and terminate multimedia sessions. We've covered:</p>
<ul>
<li>Including SDP bodies in SIP messages using the <code>Bytes</code> type</li>
<li>Using JSON path accessors to extract headers and parameters from SIP messages</li>
<li>Implementing the complete SDP offer/answer model with SIP signaling</li>
<li>Creating and responding to re-INVITEs to modify a session</li>
<li>Handling SDP negotiation failures</li>
<li>Implementing a complete dialog flow from INVITE through BYE</li>
</ul>
<p>The rvoip-sip-core library provides powerful tools for working with SIP/SDP integration, making it easy to implement compliant and robust VoIP applications.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part2/tutorial_07.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../part2/tutorial_09.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part2/tutorial_07.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../part2/tutorial_09.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
