<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Media Negotiation with SDP</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="media-negotiation-with-sdp"><a class="header" href="#media-negotiation-with-sdp">Media Negotiation with SDP</a></h1>
<p>In the previous tutorial, we explored the basics of integrating SDP with SIP for establishing multimedia sessions. Now, we'll dive deeper into the complexities of media negotiation using SDP, covering advanced scenarios like multiple media streams, codec preferences, and handling special media operations.</p>
<h2 id="advanced-media-stream-negotiation"><a class="header" href="#advanced-media-stream-negotiation">Advanced Media Stream Negotiation</a></h2>
<p>Real-world VoIP and multimedia applications often involve multiple types of media streams and complex negotiation scenarios. Let's explore these in detail.</p>
<h3 id="multiple-media-types-audio-video-application"><a class="header" href="#multiple-media-types-audio-video-application">Multiple Media Types (Audio, Video, Application)</a></h3>
<p>SDP allows for the negotiation of multiple media streams of different types in a single session:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rvoip_sip_core::sdp::SdpBuilder;
use rvoip_sip_core::sdp::attributes::MediaDirection;
use bytes::Bytes;

// Create SDP with audio, video, and application data streams
fn create_multi_stream_sdp(username: &amp;str, domain: &amp;str) -&gt; Result&lt;String, Error&gt; {
    let sdp = SdpBuilder::new("Multi-Stream Session")
        .origin(username, "2890844526", "2890844526", "IN", "IP4", domain)
        .connection("IN", "IP4", domain)
        .time("0", "0")
        
        // Audio stream
        .media_audio(49170, "RTP/AVP")
            .formats(&amp;["0", "8", "96"])  // PCMU, PCMA, telephone-event
            .rtpmap("0", "PCMU/8000")
            .rtpmap("8", "PCMA/8000")
            .rtpmap("96", "telephone-event/8000")
            .fmtp("96", "0-15")  // DTMF events
            .direction(MediaDirection::SendRecv)
            .done()
            
        // Video stream
        .media_video(49174, "RTP/AVP")
            .formats(&amp;["97", "98"])
            .rtpmap("97", "H264/90000")
            .fmtp("97", "profile-level-id=42e01f;packetization-mode=1")
            .rtpmap("98", "VP8/90000")
            .direction(MediaDirection::SendRecv)
            .done()
            
        // Application data (for example, BFCP for floor control)
        .media("application", 50000, "TCP/BFCP")
            .formats(&amp;["*"])  // Add formats separately
            .connection("IN", "IP4", domain)  // Per-media connection info
            .attribute("setup", Some("actpass"))
            .attribute("connection", Some("new"))
            .attribute("floorctrl", Some("c-s"))
            .attribute("confid", Some("4321"))
            .attribute("userid", Some("1234"))
            .done()
            
        .build()?;
    
    Ok(sdp.to_string())
}
<span class="boring">}</span></code></pre></pre>
<p>When handling multiple media streams, it's important to:</p>
<ol>
<li>Maintain the same media streams in the same order in the answer</li>
<li>Process each media stream independently in terms of codec selection</li>
<li>Include connection information (c=) for each media when they differ</li>
</ol>
<h3 id="codec-preferences-and-ordering"><a class="header" href="#codec-preferences-and-ordering">Codec Preferences and Ordering</a></h3>
<p>In SDP, the order of codecs in the format list indicates preference. The first codec is the most preferred:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Creating SDP with ordered codec preferences
fn create_sdp_with_codec_preferences() -&gt; Result&lt;String, Error&gt; {
    let sdp = SdpBuilder::new("Audio with Codec Preferences")
        .origin("alice", "2890844526", "2890844526", "IN", "IP4", "alice.example.com")
        .connection("IN", "IP4", "alice.example.com")
        .time("0", "0")
        
        // Audio stream with ordered codec preferences
        .media_audio(49170, "RTP/AVP")
            // Most preferred codec first
            .formats(&amp;["96", "97", "98", "99", "0", "8"])
            .rtpmap("96", "opus/48000/2")     // Wideband, high quality
            .rtpmap("97", "AMR-WB/16000/1")   // Wideband
            .rtpmap("98", "EVS/32000/1")      // Super-wideband
            .rtpmap("99", "telephone-event/8000")
            .rtpmap("0", "PCMU/8000")         // Fallback
            .rtpmap("8", "PCMA/8000")         // Last fallback
            .direction(MediaDirection::SendRecv)
            .done()
        .build()?;
    
    Ok(sdp.to_string())
}
<span class="boring">}</span></code></pre></pre>
<p>When responding to an offer, your answer should:</p>
<ol>
<li>Only include codecs that were in the original offer</li>
<li>Order them according to your preferences</li>
<li>You may use a subset of the offered codecs, but cannot add new ones</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Function to select codecs from an offer based on preferences
fn select_preferred_codecs(offer_sdp: &amp;SdpSession) -&gt; Vec&lt;String&gt; {
    let mut selected_codecs = Vec::new();
    
    // Our codec preferences in order
    let codec_preferences = ["opus", "AMR-WB", "EVS", "PCMU", "PCMA"];
    
    // Find the audio media description
    if let Some(audio_media) = offer_sdp.media_descriptions.iter().find(|m| m.media == "audio") {
        // Get all rtpmap attributes to map payload types to codec names
        let mut codec_map = std::collections::HashMap::new();
        
        // Access the rtpmap attributes directly 
        for rtpmap in audio_media.rtpmaps() {
            let pt = rtpmap.payload_type.to_string();
            let codec_name = rtpmap.encoding_name.to_lowercase();
            codec_map.insert(codec_name, pt);
        }
        
        // Add codecs in our preferred order if they're in the offer
        for preferred_codec in &amp;codec_preferences {
            if let Some(pt) = codec_map.get(*preferred_codec) {
                selected_codecs.push(pt.clone());
            }
        }
    }
    
    selected_codecs
}
<span class="boring">}</span></code></pre></pre>
<h3 id="bandwidth-and-quality-considerations"><a class="header" href="#bandwidth-and-quality-considerations">Bandwidth and Quality Considerations</a></h3>
<p>SDP allows for specifying bandwidth requirements for each media stream:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Adding bandwidth parameters to SDP
fn create_sdp_with_bandwidth() -&gt; Result&lt;String, Error&gt; {
    let sdp = SdpBuilder::new("High Quality Video")
        .origin("alice", "2890844526", "2890844526", "IN", "IP4", "alice.example.com")
        .connection("IN", "IP4", "alice.example.com")
        .time("0", "0")
        
        // High-def video with bandwidth limit
        .media_video(49174, "RTP/AVP")
            .formats(&amp;["97"])
            .rtpmap("97", "H264/90000")
            .fmtp("97", "profile-level-id=42e01f;packetization-mode=1")
            .attribute("bandwidth", Some("AS:2000"))  // Application Specific: 2 Mbps
            .attribute("bandwidth", Some("TIAS:2000000"))  // Transport Independent: 2 Mbps
            .direction(MediaDirection::SendRecv)
            .done()
        .build()?;
    
    Ok(sdp.to_string())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="handling-special-media-operations"><a class="header" href="#handling-special-media-operations">Handling Special Media Operations</a></h2>
<h3 id="media-hold-and-resume"><a class="header" href="#media-hold-and-resume">Media Hold and Resume</a></h3>
<p>Placing a call on hold is a common operation that's handled through SDP renegotiation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// SDP for placing a call on hold
fn create_hold_sdp(username: &amp;str, domain: &amp;str) -&gt; Result&lt;String, Error&gt; {
    // Note the "sendonly" direction - this indicates hold
    let sdp = SdpBuilder::new("Call On Hold")
        .origin(username, "2890844526", "2890844527", "IN", "IP4", domain)
        .connection("IN", "IP4", domain)
        .time("0", "0")
        .media_audio(49170, "RTP/AVP")
            .formats(&amp;["0", "8"])
            .rtpmap("0", "PCMU/8000")
            .rtpmap("8", "PCMA/8000")
            .direction(MediaDirection::SendOnly)  // SendOnly for hold
            .done()
        .build()?;
    
    Ok(sdp.to_string())
}

// SDP for resuming a call that was on hold
fn create_resume_sdp(username: &amp;str, domain: &amp;str) -&gt; Result&lt;String, Error&gt; {
    // Back to sendrecv for resuming the call
    let sdp = SdpBuilder::new("Call Resumed")
        .origin(username, "2890844526", "2890844528", "IN", "IP4", domain)
        .connection("IN", "IP4", domain)
        .time("0", "0")
        .media_audio(49170, "RTP/AVP")
            .formats(&amp;["0", "8"])
            .rtpmap("0", "PCMU/8000")
            .rtpmap("8", "PCMA/8000")
            .direction(MediaDirection::SendRecv)  // SendRecv for resuming
            .done()
        .build()?;
    
    Ok(sdp.to_string())
}
<span class="boring">}</span></code></pre></pre>
<p>Key points about hold/resume operations:</p>
<ul>
<li>For hold, change direction to <code>SendOnly</code> or <code>Inactive</code></li>
<li>For resume, change direction back to <code>SendRecv</code></li>
<li>Always increment the SDP version in the origin line</li>
<li>Send a re-INVITE with the updated SDP</li>
</ul>
<h3 id="codec-switching"><a class="header" href="#codec-switching">Codec Switching</a></h3>
<p>Sometimes you need to switch or update codecs mid-call:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// SDP for switching to a different codec
fn create_codec_switch_sdp(username: &amp;str, domain: &amp;str, use_high_quality: bool) -&gt; Result&lt;String, Error&gt; {
    let sdp_builder = SdpBuilder::new("Codec Update")
        .origin(username, "2890844526", "2890844529", "IN", "IP4", domain)
        .connection("IN", "IP4", domain)
        .time("0", "0");
    
    // Choose codecs based on quality preference
    let (formats, audio_builder) = if use_high_quality {
        // High quality: Opus wideband
        let formats = &amp;["96"];
        let audio_builder = sdp_builder.media_audio(49170, "RTP/AVP")
            .formats(formats)
            .rtpmap("96", "opus/48000/2")
            .fmtp("96", "stereo=1;sprop-stereo=1;maxplaybackrate=48000");
        (formats, audio_builder)
    } else {
        // Low quality: PCMU narrowband
        let formats = &amp;["0"];
        let audio_builder = sdp_builder.media_audio(49170, "RTP/AVP")
            .formats(formats)
            .rtpmap("0", "PCMU/8000");
        (formats, audio_builder)
    };
    
    // Complete and build the SDP
    let sdp = audio_builder
        .direction(MediaDirection::SendRecv)
        .done()
        .build()?;
    
    Ok(sdp.to_string())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="ice-and-nat-traversal"><a class="header" href="#ice-and-nat-traversal">ICE and NAT Traversal</a></h2>
<p>Interactive Connectivity Establishment (ICE) is a protocol for NAT traversal that's commonly used with SIP/SDP:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Adding ICE candidates to SDP
fn create_sdp_with_ice() -&gt; Result&lt;String, Error&gt; {
    let sdp = SdpBuilder::new("ICE Session")
        .origin("alice", "2890844526", "2890844526", "IN", "IP4", "alice.example.com")
        .connection("IN", "IP4", "0.0.0.0")  // IP is determined by ICE
        .time("0", "0")
        
        // Session level ICE attributes
        .attribute("ice-pwd", Some("asd88fgpdd777uzjYhagZg"))
        .attribute("ice-ufrag", Some("8hhY"))
        .attribute("ice-options", Some("trickle"))
        
        // Audio stream with ICE candidates
        .media_audio(9, "RTP/AVP")  // Port 9 is a placeholder
            .formats(&amp;["0", "8"])
            .rtpmap("0", "PCMU/8000")
            .rtpmap("8", "PCMA/8000")
            .direction(MediaDirection::SendRecv)
            
            // ICE candidates
            .attribute("candidate", Some("1 1 UDP 2130706431 10.0.1.1 8998 typ host"))
            .attribute("candidate", Some("1 2 UDP 2130706430 10.0.1.1 8999 typ host"))
            .attribute("candidate", Some("2 1 UDP 1694498815 192.0.2.3 45664 typ srflx raddr 10.0.1.1 rport 8998"))
            .attribute("candidate", Some("2 2 UDP 1694498814 192.0.2.3 45665 typ srflx raddr 10.0.1.1 rport 8999"))
            
            // RTCP multiplexing
            .attribute("rtcp-mux", Some(""))
            .done()
        .build()?;
    
    Ok(sdp.to_string())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implementing-trickle-ice"><a class="header" href="#implementing-trickle-ice">Implementing Trickle ICE</a></h2>
<p>Trickle ICE is an extension that allows candidates to be sent incrementally:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Initial SDP for Trickle ICE
fn create_initial_trickle_ice_sdp() -&gt; Result&lt;String, Error&gt; {
    let sdp = SdpBuilder::new("Trickle ICE Session")
        .origin("alice", "2890844526", "2890844526", "IN", "IP4", "alice.example.com")
        .connection("IN", "IP4", "0.0.0.0")
        .time("0", "0")
        
        // Session-level ICE attributes
        .attribute("ice-options", Some("trickle"))
        .attribute("ice-pwd", Some("asd88fgpdd777uzjYhagZg"))
        .attribute("ice-ufrag", Some("8hhY"))
        
        // Media section with minimal ICE
        .media_audio(9, "RTP/AVP")
            .formats(&amp;["0"])
            .rtpmap("0", "PCMU/8000")
            .direction(MediaDirection::SendRecv)
            
            // Just include host candidates initially
            .attribute("candidate", Some("1 1 UDP 2130706431 10.0.1.1 8998 typ host"))
            .attribute("candidate", Some("1 2 UDP 2130706430 10.0.1.1 8999 typ host"))
            
            // Mark that more candidates may come
            .attribute("end-of-candidates", Some(""))  // Not yet the end
            .done()
        .build()?;
    
    Ok(sdp.to_string())
}

// Additional ICE candidates sent via INFO messages or other means
fn send_additional_ice_candidate(sdp_mid: &amp;str, m_line_index: u32, candidate: &amp;str) {
    // In a real application, this would be sent as an INFO message
    // with application/trickle-ice+sdpfrag content type
    println!("Send Trickle ICE candidate:");
    println!("a=mid:{}", sdp_mid);
    println!("a=ice-ufrag:8hhY");
    println!("a=ice-pwd:asd88fgpdd777uzjYhagZg");
    println!("a=candidate:{}", candidate);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-media-negotiation-example"><a class="header" href="#complete-media-negotiation-example">Complete Media Negotiation Example</a></h2>
<p>Here's a complete example that handles a more complex SDP negotiation scenario:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rvoip_sip_core::prelude::*;
use rvoip_sip_core::{RequestBuilder, ResponseBuilder};
use rvoip_sip_core::sdp::SdpBuilder;
use rvoip_sip_core::sdp::attributes::MediaDirection;
use rvoip_sip_core::types::sdp::SdpSession;
use rvoip_sip_core::json::SipJsonExt;
use bytes::Bytes;
use std::str::FromStr;

fn advanced_media_negotiation_example() -&gt; Result&lt;(), Error&gt; {
    // Initial parameters
    let call_id = "adv-media-call-1@example.com";
    let from_tag = "alice-tag-1";
    let cseq = 100;
    
    // Step 1: Alice sends INVITE with complex SDP offer
    println!("Step 1: Starting the VoIP call with advanced media");
    
    let alice_sdp = SdpBuilder::new("Advanced Media Call")
        .origin("alice", "2890844526", "2890844526", "IN", "IP4", "alice.example.com")
        .connection("IN", "IP4", "alice.example.com")
        .time("0", "0")
        
        // Session-level attributes
        .attribute("ice-options", Some("trickle"))
        .attribute("ice-pwd", Some("alice-ice-password-1"))
        .attribute("ice-ufrag", Some("alice-ice-1"))
        
        // High-quality audio
        .media_audio(49170, "RTP/AVP")
            .formats(&amp;["96", "0", "8"])
            .rtpmap("96", "opus/48000/2")  // Preferred: Opus
            .rtpmap("0", "PCMU/8000")      // Fallback: PCMU
            .rtpmap("8", "PCMA/8000")      // Last fallback: PCMA
            .direction(MediaDirection::SendRecv)
            .attribute("rtcp-mux", Some(""))
            .attribute("candidate", Some("1 1 UDP 2130706431 192.168.1.1 49170 typ host"))
            .done()
            
        // Video
        .media_video(49174, "RTP/AVP")
            .formats(&amp;["97", "98"])
            .rtpmap("97", "H264/90000")
            .fmtp("97", "profile-level-id=42e01f;packetization-mode=1")
            .rtpmap("98", "VP8/90000")
            .direction(MediaDirection::SendRecv)
            .attribute("rtcp-mux", Some(""))
            .attribute("candidate", Some("1 1 UDP 2130706431 192.168.1.1 49174 typ host"))
            .done()
        
        .build()?;
    
    let alice_sdp_str = alice_sdp.to_string();
    
    let invite = RequestBuilder::new(Method::Invite, "sip:bob@example.com")?
        .from("Alice", "sip:alice@example.com", Some(from_tag))
        .to("Bob", "sip:bob@example.com", None)
        .call_id(call_id)
        .cseq(cseq)
        .via("example.com", "UDP", Some("z9hG4bKabc123"))
        .max_forwards(70)
        .contact("sip:alice@192.168.1.1", None)
        .content_type("application/sdp")
        .body(Bytes::from(alice_sdp_str))
        .build();
    
    println!("INVITE with advanced media offer:\n{}\n", Message::Request(invite.clone()));
    
    // Step 2: Bob processes the offer and creates an answer
    println!("Step 2: Bob answers the call with codec selection");
    
    // Parse the SDP offer
    let alice_sdp_text = std::str::from_utf8(&amp;invite.body()[..]).unwrap();
    let alice_sdp_parsed = SdpSession::from_str(alice_sdp_text)?;
    
    // Bob's preferences and capabilities:
    // - Supports Opus for audio, prefers it
    // - Only supports VP8 for video (not H.264)
    // - Has own ICE credentials
    
    let bob_sdp = SdpBuilder::new("Advanced Media Response")
        .origin("bob", "3890844527", "3890844527", "IN", "IP4", "bob.example.com")
        .connection("IN", "IP4", "bob.example.com")
        .time("0", "0")
        
        // Session-level attributes
        .attribute("ice-options", Some("trickle"))
        .attribute("ice-pwd", Some("bob-ice-password-1"))
        .attribute("ice-ufrag", Some("bob-ice-1"))
        
        // Audio - select Opus as preferred
        .media_audio(59170, "RTP/AVP")
            .formats(&amp;["96"])  // Just Opus, which we prefer
            .rtpmap("96", "opus/48000/2")
            .direction(MediaDirection::SendRecv)
            .attribute("rtcp-mux", Some(""))
            .attribute("candidate", Some("1 1 UDP 2130706431 192.168.1.2 59170 typ host"))
            .done()
            
        // Video - select VP8 only (no H.264 support)
        .media_video(59174, "RTP/AVP")
            .formats(&amp;["98"])  // Just VP8
            .rtpmap("98", "VP8/90000")
            .direction(MediaDirection::SendRecv)
            .attribute("rtcp-mux", Some(""))
            .attribute("candidate", Some("1 1 UDP 2130706431 192.168.1.2 59174 typ host"))
            .done()
        
        .build()?;
    
    let bob_sdp_str = bob_sdp.to_string();
    
    let to_tag = "bob-tag-1";
    let ok_response = ResponseBuilder::dialog_response(
        &amp;invite,
        StatusCode::Ok,
        None
    )
    .to("Bob", "sip:bob@example.com", Some(to_tag))
    .contact("sip:bob@192.168.1.2", None)
    .content_type("application/sdp")
    .body(Bytes::from(bob_sdp_str))
    .build();
    
    println!("200 OK with advanced media answer:\n{}\n", Message::Response(ok_response.clone()));
    
    // Step 3: Alice sends ACK to establish the session
    println!("Step 3: Alice acknowledges the call");
    
    let ack = RequestBuilder::new(Method::Ack, "sip:bob@192.168.1.2")?
        .from("Alice", "sip:alice@example.com", Some(from_tag))
        .to("Bob", "sip:bob@example.com", Some(to_tag))
        .call_id(call_id)
        .cseq(cseq)
        .via("example.com", "UDP", Some("z9hG4bKdef456"))
        .max_forwards(70)
        .build();
    
    println!("ACK to establish session:\n{}\n", Message::Request(ack));
    
    // Step 4: Alice sends additional ICE candidates via INFO (Trickle ICE)
    println!("Step 4: Alice sends additional ICE candidates");
    
    let info = RequestBuilder::new(Method::Info, "sip:bob@192.168.1.2")?
        .from("Alice", "sip:alice@example.com", Some(from_tag))
        .to("Bob", "sip:bob@example.com", Some(to_tag))
        .call_id(call_id)
        .cseq(cseq + 1)
        .via("example.com", "UDP", Some("z9hG4bKghi789"))
        .max_forwards(70)
        .content_type("application/trickle-ice-sdpfrag")
        .body(Bytes::from(
            "a=ice-pwd:alice-ice-password-1\r\n\
             a=ice-ufrag:alice-ice-1\r\n\
             a=candidate:2 1 UDP 1694498815 203.0.113.3 56789 typ srflx raddr 192.168.1.1 rport 49170\r\n"
        ))
        .build();
    
    println!("INFO with additional ICE candidates:\n{}\n", Message::Request(info));
    
    // Step 5: Later, Alice sends re-INVITE to change to hold
    println!("Step 5: Alice puts the call on hold");
    
    let alice_hold_sdp = SdpBuilder::new("Call On Hold")
        .origin("alice", "2890844526", "2890844527", "IN", "IP4", "alice.example.com")
        .connection("IN", "IP4", "alice.example.com")
        .time("0", "0")
        
        // Audio on hold (sendonly)
        .media_audio(49170, "RTP/AVP")
            .formats(&amp;["96"])
            .rtpmap("96", "opus/48000/2")
            .direction(MediaDirection::SendOnly)  // Hold
            .attribute("rtcp-mux", Some(""))
            .done()
            
        // Video on hold too
        .media_video(49174, "RTP/AVP")
            .formats(&amp;["98"])
            .rtpmap("98", "VP8/90000")
            .direction(MediaDirection::SendOnly)  // Hold
            .attribute("rtcp-mux", Some(""))
            .done()
        
        .build()?;
    
    let alice_hold_sdp_str = alice_hold_sdp.to_string();
    
    let reinvite = RequestBuilder::new(Method::Invite, "sip:bob@192.168.1.2")?
        .from("Alice", "sip:alice@example.com", Some(from_tag))
        .to("Bob", "sip:bob@example.com", Some(to_tag))
        .call_id(call_id)
        .cseq(cseq + 2)
        .via("example.com", "UDP", Some("z9hG4bKjkl012"))
        .max_forwards(70)
        .contact("sip:alice@192.168.1.1", None)
        .content_type("application/sdp")
        .body(Bytes::from(alice_hold_sdp_str))
        .build();
    
    println!("re-INVITE to put call on hold:\n{}\n", Message::Request(reinvite));
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-for-sdp-media-negotiation"><a class="header" href="#best-practices-for-sdp-media-negotiation">Best Practices for SDP Media Negotiation</a></h2>
<ol>
<li><strong>Codec Compatibility</strong>: Ensure any codecs included in your answer were in the original offer</li>
<li><strong>Media Stream Preservation</strong>: Maintain the same number and type of media streams in the answer as in the offer</li>
<li><strong>Direction Management</strong>: Choose appropriate directions (sendrecv, sendonly, recvonly, inactive) for each media stream</li>
<li><strong>Bandwidth Control</strong>: Use bandwidth attributes to manage quality and network usage</li>
<li><strong>ICE Integration</strong>: Support ICE for NAT traversal; consider Trickle ICE for faster connection establishment</li>
<li><strong>Version Management</strong>: Increment the SDP version in the o= line for each new SDP in the same session</li>
<li><strong>Quality Fallback</strong>: Order codecs to gracefully handle varying bandwidth conditions</li>
</ol>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Advanced media negotiation with SDP is critical for creating robust real-time communication applications. With the <code>rvoip-sip-core</code> library, you can:</p>
<ul>
<li>Negotiate complex media scenarios with multiple streams</li>
<li>Implement codec priorities and preferences</li>
<li>Handle special operations like hold/resume and codec switching</li>
<li>Integrate ICE for NAT traversal</li>
</ul>
<p>In the next tutorial, we'll move into Part 3 of our series, exploring SIP Transactions and the state machines that govern SIP message exchanges.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part2/tutorial_08.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../part3/tutorial_10.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part2/tutorial_08.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../part3/tutorial_10.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
