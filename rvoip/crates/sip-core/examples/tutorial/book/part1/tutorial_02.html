<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Parsing Your First SIP Message</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="parsing-your-first-sip-message"><a class="header" href="#parsing-your-first-sip-message">Parsing Your First SIP Message</a></h1>
<p>In this tutorial, we'll explore how to parse SIP messages using the <code>rvoip-sip-core</code> library. We'll focus on different approaches to accessing message components, with special emphasis on the JSON path accessor approach.</p>
<h2 id="sip-message-structure-recap"><a class="header" href="#sip-message-structure-recap">SIP Message Structure Recap</a></h2>
<p>Before diving into parsing, let's recall the basic structure of a SIP message:</p>
<ol>
<li>
<p><strong>Start Line</strong>:</p>
<ul>
<li>For requests: <code>METHOD URI SIP/VERSION</code></li>
<li>For responses: <code>SIP/VERSION STATUS_CODE REASON_PHRASE</code></li>
</ul>
</li>
<li>
<p><strong>Headers</strong>: Multiple <code>Name: Value</code> pairs</p>
</li>
<li>
<p><strong>Empty Line</strong>: Separates headers from body</p>
</li>
<li>
<p><strong>Body</strong> (optional): Message content (e.g., SDP for media negotiation)</p>
</li>
</ol>
<h2 id="parsing-approaches"><a class="header" href="#parsing-approaches">Parsing Approaches</a></h2>
<p>The <code>rvoip-sip-core</code> library provides several ways to parse and access SIP message components:</p>
<ol>
<li><strong>JSON Path Accessors</strong>: Flexible string-based access to any part of the message</li>
<li><strong>Native Methods</strong>: Type-safe, direct access to common fields</li>
<li><strong>Header Access Traits</strong>: For working with multiple headers of the same type</li>
</ol>
<p>Let's explore each approach with examples.</p>
<h2 id="parsing-a-sip-message"><a class="header" href="#parsing-a-sip-message">Parsing a SIP Message</a></h2>
<p>To parse a SIP message, we use the <code>parse_message</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rvoip_sip_core::prelude::*;
use bytes::Bytes;

// Raw SIP message as bytes
let data = Bytes::from(message_string);

// Parse the message
match parse_message(&amp;data) {
    Ok(message) =&gt; {
        // Work with the parsed message
    },
    Err(e) =&gt; {
        println!("Failed to parse message: {:?}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>parse_message</code> function returns a <code>Result&lt;Message&gt;</code>, where <code>Message</code> is an enum with variants for <code>Request</code> and <code>Response</code>.</p>
<h2 id="json-path-accessors"><a class="header" href="#json-path-accessors">JSON Path Accessors</a></h2>
<p>The JSON path accessor approach provides a flexible way to access any part of a SIP message using dot notation paths. This is especially useful for quick prototyping or when you need to access deeply nested fields.</p>
<p>To use JSON path accessors, import the <code>SipJsonExt</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rvoip_sip_core::json::SipJsonExt;
<span class="boring">}</span></code></pre></pre>
<h3 id="path-accessor-methods"><a class="header" href="#path-accessor-methods">Path Accessor Methods</a></h3>
<p>There are two main path accessor methods:</p>
<ol>
<li><strong>path()</strong>: Returns <code>Option&lt;SipValue&gt;</code>, preserving the original type</li>
<li><strong>path_str_or()</strong>: Returns <code>String</code>, with a default value if the path is not found</li>
</ol>
<h3 id="example-accessing-request-fields"><a class="header" href="#example-accessing-request-fields">Example: Accessing Request Fields</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Message::Request(request) = message {
    // Basic request information
    println!("Method: {}", request.path_str_or("method", "(unknown)"));
    println!("URI: {}", request.path_str_or("uri", "(unknown)"));
    println!("Version: {}", request.path_str_or("version", "(unknown)"));
    
    // Headers
    println!("From: {}", 
        request.path_str_or("headers.From.display_name", "(unknown)"));
    println!("To: {}", 
        request.path_str_or("headers.To.display_name", "(unknown)"));
    println!("Call-ID: {}", 
        request.path_str_or("headers.CallId", "(none)"));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-accessing-response-fields"><a class="header" href="#example-accessing-response-fields">Example: Accessing Response Fields</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Message::Response(response) = message {
    // Basic response information
    println!("Status Code: {}", response.path_str_or("status_code", "(unknown)"));
    println!("Reason: {}", response.path_str_or("reason", "(unknown)"));
    
    // Headers (same as for requests)
    println!("From: {}", 
        response.path_str_or("headers.From.display_name", "(unknown)"));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="working-with-numeric-values"><a class="header" href="#working-with-numeric-values">Working with Numeric Values</a></h3>
<p>For numeric values, you might want to preserve the type. Here's how to do it with <code>path()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match request.path("headers.CSeq.seq") {
    Some(val) =&gt; {
        if let Some(num) = val.as_i64() {
            println!("CSeq number: {} (numeric value)", num);
            // Now you can use num in arithmetic operations
        }
    },
    None =&gt; println!("CSeq number not found"),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="native-methods"><a class="header" href="#native-methods">Native Methods</a></h2>
<p>The library also provides native methods for accessing common fields in a type-safe way:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Basic request information
println!("Method: {}", request.method());
println!("URI: {}", request.uri());
println!("Version: {}", request.version());

// Common headers
if let Some(from) = request.from() {
    println!("From: {}", from);
}

if let Some(to) = request.to() {
    println!("To: {}", to);
}

if let Some(via) = request.first_via() {
    println!("Via: {}", via);
}

if let Some(call_id) = request.call_id() {
    println!("Call-ID: {}", call_id);
}

if let Some(cseq) = request.cseq() {
    println!("CSeq: {} {}", cseq.seq, cseq.method);
}
<span class="boring">}</span></code></pre></pre>
<p>For responses, similar methods are available:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Basic response information
println!("Status Code: {}", response.status_code());
println!("Reason: {}", response.reason_phrase());
println!("Version: {}", response.version());

// Headers (same as for requests)
<span class="boring">}</span></code></pre></pre>
<h2 id="working-with-multiple-headers"><a class="header" href="#working-with-multiple-headers">Working with Multiple Headers</a></h2>
<p>SIP messages can contain multiple headers of the same type (e.g., multiple Via headers). To access them:</p>
<h3 id="using-path-accessors"><a class="header" href="#using-path-accessors">Using Path Accessors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Access first Via header
println!("First Via: {}", 
    request.path_str_or("headers.Via[0].sent_protocol.transport", "(unknown)"));

// Access second Via header
println!("Second Via: {}", 
    request.path_str_or("headers.Via[1].sent_protocol.transport", "(unknown)"));
<span class="boring">}</span></code></pre></pre>
<h3 id="using-native-methods"><a class="header" href="#using-native-methods">Using Native Methods</a></h3>
<p>To work with multiple headers, use the <code>HeaderAccess</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rvoip_sip_core::types::headers::HeaderAccess;

// Get all Via headers
let via_headers = request.via_headers();
for (i, via) in via_headers.iter().enumerate() {
    println!("Via #{}: {}", i+1, via);
}

// Get all headers of a specific name
let record_route_headers = request.headers_by_name("Record-Route");
for (i, rr) in record_route_headers.iter().enumerate() {
    println!("Record-Route #{}: {}", i+1, rr);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="working-with-sip-uris"><a class="header" href="#working-with-sip-uris">Working with SIP URIs</a></h2>
<p>SIP URIs are a fundamental part of SIP messages. Here's how to parse and work with them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::str::FromStr;

let uri_str = "sip:user:password@example.com:5060;transport=tcp?subject=Meeting";
match Uri::from_str(uri_str) {
    Ok(uri) =&gt; {
        println!("Scheme: {}", uri.scheme);
        println!("User: {}", uri.user.unwrap_or_default());
        
        if let Some(password) = uri.password {
            println!("Password: {}", password);
        }
        
        println!("Host: {}", uri.host);
        
        if let Some(port) = uri.port {
            println!("Port: {}", port);
        }
        
        // URI parameters
        for param in &amp;uri.parameters {
            match param {
                Param::Transport(transport) =&gt; println!("Transport: {}", transport),
                Param::Ttl(ttl) =&gt; println!("TTL: {}", ttl),
                Param::Other(name, Some(value)) =&gt; println!("{}: {}", name, value),
                Param::Other(name, None) =&gt; println!("{}", name),
                _ =&gt; println!("{:?}", param),
            }
        }
        
        // URI headers
        for (name, value) in &amp;uri.headers {
            println!("{}: {}", name, value);
        }
    },
    Err(e) =&gt; {
        println!("Failed to parse URI: {}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="working-with-message-bodies"><a class="header" href="#working-with-message-bodies">Working with Message Bodies</a></h2>
<p>SIP messages can contain bodies, such as SDP for media negotiation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Access Content-Type and Content-Length headers
if let Some(header) = request.header(&amp;HeaderName::ContentType) {
    println!("Content-Type: {}", header);
}

if let Some(header) = request.header(&amp;HeaderName::ContentLength) {
    println!("Content-Length: {}", header);
}

// Access the body
let body = request.body();
println!("Body: {} bytes", body.len());

// Convert body to string (if it's text-based)
if let Ok(body_str) = std::str::from_utf8(body) {
    println!("Body (as string):\n{}", body_str);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-each-approach"><a class="header" href="#when-to-use-each-approach">When to Use Each Approach</a></h2>
<ul>
<li>
<p><strong>JSON Path Accessors</strong>:</p>
<ul>
<li>For quick prototyping</li>
<li>When accessing deeply nested fields</li>
<li>When working with custom or non-standard headers</li>
<li>When you need string representations</li>
</ul>
</li>
<li>
<p><strong>Native Methods</strong>:</p>
<ul>
<li>For type safety</li>
<li>For common headers and fields</li>
<li>When you need the full power of the typed objects</li>
</ul>
</li>
<li>
<p><strong>Header Access Traits</strong>:</p>
<ul>
<li>When working with multiple headers of the same type</li>
<li>For advanced header manipulation</li>
</ul>
</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this tutorial, we've explored different ways to parse and access SIP message components using the <code>rvoip-sip-core</code> library. The JSON path accessor approach provides flexibility, while native methods offer type safety. Choose the approach that best suits your needs.</p>
<p>In the next tutorial, we'll learn how to create SIP messages using the builder pattern.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<ol>
<li>Parse a SIP INVITE request and extract all Via headers.</li>
<li>Parse a SIP 200 OK response and extract the To header with tag parameter.</li>
<li>Parse a SIP URI with multiple parameters and headers.</li>
</ol>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc3261">RFC 3261: SIP: Session Initiation Protocol</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3986: URI Generic Syntax</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../part1/tutorial_01.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../part1/tutorial_03.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../part1/tutorial_01.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../part1/tutorial_03.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
