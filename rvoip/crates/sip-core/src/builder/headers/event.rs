use crate::types::{
    event::{Event, EventType, Params, ParamValue},
    headers::TypedHeader,
};
use crate::builder::headers::HeaderSetter;
use std::collections::BTreeMap;
use crate::builder::headers::expires::ExpiresExt;

/// # SIP Event Header Builder
///
/// This module provides builder methods for constructing the SIP Event header,
/// as defined in [RFC 6665](https://datatracker.ietf.org/doc/html/rfc6665),
/// which obsoletes RFC 3265.
///
/// ## SIP Event Header Overview
///
/// The Event header field is a crucial component of the SIP event notification framework.
/// It is used by User Agents (UAs) to subscribe to specific event packages occurring
/// on a resource and by notification servers to inform subscribed UAs about those events.
///
/// ### Purpose
///
/// - **Subscriptions**: A UA sends a SUBSCRIBE request with an Event header indicating the
///   desired event package (e.g., `presence`, `conference`, `message-summary`).
/// - **Notifications**: A notifier sends NOTIFY requests to subscribed UAs. These NOTIFY
///   requests also contain an Event header, echoing the event package and often including
///   an `id` parameter to match the specific subscription.
/// - **State Management**: The framework allows UAs to learn about changes in state of
///   remote resources, such as user presence, conference state, or message waiting status.
///
/// ### Structure
///
/// The Event header typically includes:
///
/// - **Event Type**: This can be an *event package name* (e.g., `presence`) or a simple
///   *event template token*. Package names are often standardized (e.g., by IANA),
///   while tokens can be more specific.
///   - Format: `event-package` (e.g., `presence`) or `<event-package>` (e.g., `<conference>`).
///     The angle brackets were more common in older RFCs but RFC 6665 simplifies this.
///     Our parser and type handle both `EventType::Token(String)` and `EventType::Package(String)`.
/// - **`id` Parameter**: An optional parameter used to correlate subscriptions with
///   notifications, especially when multiple subscriptions to the same event package exist.
///   The `id` parameter is generated by the subscriber in the SUBSCRIBE request and echoed
///   by the notifier in subsequent NOTIFY requests for that subscription.
/// - **Other Generic Parameters**: The Event header can also include other parameters
///   as defined by specific event packages or for extension purposes.
///
/// ### Common Event Packages
///
/// - **`presence`**: (RFC 3856) Used for subscribing to and receiving updates about the
///   presence status of a user (e.g., online, offline, busy).
/// - **`conference`**: (RFC 4575) Used for subscribing to information about a conference
///   call, such as participant lists, media types, and conference state.
/// - **`dialog`**: (RFC 4235) Allows subscription to the state of a specific SIP dialog.
///   This can be used for features like call pickup or monitoring.
///   Event types within this package include `dialog` (generic), `call-completion`, etc.
/// - **`message-summary`**: (RFC 3842) Indicates a subscription to message waiting
///   indicators (MWI).
/// - **`refer`**: (RFC 3515, specifically `eventlist` for `REFER` implications) Though not
///   directly an event package for SUBSCRIBE, `REFER` requests can imply a subscription
///   to the outcome of the referral, and NOTIFY requests use the Event header
///   (e.g., `Event: refer`) to report status.
///
/// ## Examples
///
/// ### Subscribing to Presence
///
/// ```rust
/// use rvoip_sip_core::prelude::*;
/// use rvoip_sip_core::builder::{SimpleRequestBuilder, headers::EventBuilderExt};
/// use rvoip_sip_core::builder::headers::expires::ExpiresExt;
/// use rvoip_sip_core::types::event::EventType;
///
/// let subscribe_request = SimpleRequestBuilder::new(Method::Subscribe, "sip:bob@example.com").unwrap()
///     .from("Alice", "sip:alice@example.com", Some("sub1"))
///     .to("Bob", "sip:bob@example.com", None)
///     .contact("<sip:alice@192.0.2.101>", None)
///     // Specify the 'presence' event package with a unique ID for this subscription
///     .event_id(EventType::Token("presence".to_string()), "unique-presence-id-123")
///     .accept("application/pidf+xml", None) // Expected content type for presence notifications
///     .expires(3600) // Subscription duration
///     .build();
///
/// // The server will now attempt to establish a presence subscription for Alice to Bob.
/// // Subsequent NOTIFY requests from the server for this subscription will include:
/// // Event: presence;id=unique-presence-id-123
/// ```
///
/// ### Sending a Conference State Notification
///
/// ```rust
/// use rvoip_sip_core::prelude::*;
/// use rvoip_sip_core::builder::{SimpleRequestBuilder, headers::EventBuilderExt}; // Assuming ResponseBuilder for NOTIFY
/// use rvoip_sip_core::types::event::EventType;
/// use std::collections::BTreeMap;
///
/// // Scenario: A conference server sends an update about a conference.
/// // This would typically be a NOTIFY request.
///
/// let conference_params = vec![
///     ("version".to_string(), Some("42".to_string())),
///     ("state".to_string(), Some("full".to_string()))
/// ];
///
/// let notify_request = SimpleRequestBuilder::new(Method::Notify, "sip:subscriber@example.net").unwrap()
///     // Usually From/To would be related to the conference server and subscriber
///     .from("Conference Server", "sip:conf-server@example.com", Some("notify1"))
///     .to("Subscriber", "sip:subscriber@example.net", Some("sub-token"))
///     .contact("<sip:conf-server@example.com>", None)
///     // Event header indicating conference event, matching a subscription's ID
///     .event_full(
///         EventType::Package("conference".to_string()),
///         Some("conf-sub-789"),
///         conference_params
///     )
///     .content_type("application/conference-info+xml")
///     // .body(...) // XML body describing conference state
///     .build();
///
/// // This NOTIFY informs the subscriber about the current state of the conference
/// // identified by 'conf-sub-789'.
/// ```
///
/// ### Dialog Event Package (e.g., for Blind Transfer Monitoring)
///
/// A SUBSCRIBE request with the dialog event package is often used to monitor
/// call state within a SIP dialog.
///
/// # Examples
///
/// ```rust
/// use rvoip_sip_core::prelude::*;
/// use rvoip_sip_core::builder::{SimpleRequestBuilder, headers::EventBuilderExt};
/// use rvoip_sip_core::builder::headers::expires::ExpiresExt;
/// use rvoip_sip_core::types::event::EventType;
///
/// let subscribe_to_dialog = SimpleRequestBuilder::new(Method::Invite, "sip:transferor@example.com")
///     .unwrap()
///     .from("Transfer Target", "sip:target@example.com", Some("diag-sub"))
///     .to("Transferor", "sip:transferor@example.com", None)
///     // Contact where notifications should be sent
///     .contact("<sip:target@192.0.2.5>", None)
///     // Make this a dialog event subscription with an identifier
///     .event_id(EventType::Token("dialog".to_string()), "transfer-monitor-456")
///     .expires(600)
///     .build();
/// // Results in a SUBSCRIBE request with "Event: dialog;id=transfer-monitor-456"
/// // and "Expires: 600" headers
/// ```
///
/// ```rust
/// use rvoip_sip_core::prelude::*;
/// use rvoip_sip_core::builder::{SimpleRequestBuilder, headers::EventBuilderExt};
/// use rvoip_sip_core::types::event::EventType;
/// use rvoip_sip_core::types::headers::TypedHeader;
///
/// // Create a NOTIFY request with custom Event package
/// let notification = SimpleRequestBuilder::new(Method::Notify, "sip:alice@atlanta.example.com")
///     .unwrap()
///     .from("Bob", "sip:bob@biloxi.example.com", Some("a73kszlfl"))
///     .to("Alice", "sip:alice@atlanta.example.com", Some("1j9FpLxk3"))
///     .event_id(EventType::Token("presence".to_string()), "pres-qw452")
///     // Add a Content-Type header
///     .content_type("application/pidf+xml")
///     .build();
/// // Results in a NOTIFY with "Event: presence;id=pres-qw452" header
/// ```
pub trait EventBuilderExt {
    /// Sets the Event header using a pre-constructed `Event` object.
    ///
    /// This is useful if the `Event` data (type, id, parameters) has been
    /// assembled elsewhere.
    ///
    /// # Parameters
    /// - `event_data`: The fully populated `crate::types::event::Event` struct.
    ///
    /// # Returns
    /// `Self` - The builder with the Event header set.
    fn event(self, event_data: Event) -> Self;

    /// Sets the Event header with a specific event type and no `id` or other parameters.
    ///
    /// # Parameters
    /// - `event_type`: The `EventType` (e.g., `EventType::Token("presence".to_string())`).
    ///
    /// # Returns
    /// `Self` - The builder with the Event header set.
    ///
    /// # Examples
    /// ```rust
    /// use rvoip_sip_core::prelude::*;
    /// use rvoip_sip_core::builder::{SimpleRequestBuilder, headers::EventBuilderExt};
    /// use rvoip_sip_core::types::event::EventType;
    ///
    /// let req = SimpleRequestBuilder::new(Method::Subscribe, "sip:bob@example.com").unwrap()
    ///     .event_type(EventType::Token("message-summary".to_string()))
    ///     .build();
    /// // Results in "Event: message-summary"
    /// ```
    fn event_type(self, event_type: EventType) -> Self;

    /// Sets the Event header with an event type and an `id` parameter.
    ///
    /// The `id` parameter is crucial for matching subscriptions with notifications.
    ///
    /// # Parameters
    /// - `event_type`: The `EventType`.
    /// - `id`: The value for the `id` parameter.
    ///
    /// # Returns
    /// `Self` - The builder with the Event header set.
    ///
    /// # Examples
    /// ```rust
    /// use rvoip_sip_core::prelude::*;
    /// use rvoip_sip_core::builder::{SimpleRequestBuilder, headers::EventBuilderExt};
    /// use rvoip_sip_core::types::event::EventType;
    ///
    /// let req = SimpleRequestBuilder::new(Method::Subscribe, "sip:bob@example.com").unwrap()
    ///     .event_id(EventType::Package("conference".to_string()), "conf-subscription-1")
    ///     .build();
    /// // Results in "Event: <conference>;id=conf-subscription-1"
    /// ```
    fn event_id(self, event_type: EventType, id: impl Into<String>) -> Self;

    /// Sets the Event header with an event type, an optional `id`, and generic parameters.
    ///
    /// # Parameters
    /// - `event_type`: The `EventType`.
    /// - `id`: An optional value for the `id` parameter.
    /// - `params`: A vector of key-value pairs for generic parameters.
    ///   The value in the tuple is an `Option<impl Into<String>>`; if `None`, it's a flag parameter.
    ///
    /// # Returns
    /// `Self` - The builder with the Event header set.
    ///
    /// # Examples
    /// ```rust
    /// use rvoip_sip_core::prelude::*;
    /// use rvoip_sip_core::builder::{SimpleRequestBuilder, headers::EventBuilderExt};
    /// use rvoip_sip_core::types::event::EventType;
    ///
    /// let event_params = vec![
    ///     ("extra".to_string(), Some("data".to_string())),
    ///     ("flagparam".to_string(), None)
    /// ];
    /// let req = SimpleRequestBuilder::new(Method::Notify, "sip:alice@example.com").unwrap()
    ///     .event_full(
    ///         EventType::Token("presence".to_string()),
    ///         Some("presence-sub-xyz"),
    ///         event_params
    ///     )
    ///     .build();
    /// // Results in "Event: presence;id=presence-sub-xyz;extra=data;flagparam" (params may be sorted)
    /// ```
    fn event_full(
        self,
        event_type: EventType,
        id: Option<impl Into<String>>,
        params: Vec<(impl Into<String>, Option<impl Into<String>>)>,
    ) -> Self;

    /// Convenience method to set a "presence" event.
    ///
    /// # Parameters
    /// - `id`: An optional `id` for the presence subscription/notification.
    fn event_presence(self, id: Option<impl Into<String>>) -> Self;

    /// Convenience method to set a "conference" event (as a package).
    ///
    /// # Parameters
    /// - `id`: An optional `id` for the conference subscription/notification.
    fn event_conference(self, id: Option<impl Into<String>>) -> Self;
    
    /// Convenience method to set a "dialog" event.
    ///
    /// # Parameters
    /// - `id`: An optional `id` for the dialog event subscription/notification.
    fn event_dialog(self, id: Option<impl Into<String>>) -> Self;

    /// Convenience method to set a "message-summary" event.
    ///
    /// # Parameters
    /// - `id`: An optional `id` for the message-summary subscription/notification.
    fn event_message_summary(self, id: Option<impl Into<String>>) -> Self;
}

impl<T> EventBuilderExt for T
where
    T: HeaderSetter,
{
    fn event(self, event_data: Event) -> Self {
        self.set_header(event_data)
    }

    fn event_type(self, event_type: EventType) -> Self {
        self.set_header(Event::new(event_type))
    }

    fn event_id(self, event_type: EventType, id: impl Into<String>) -> Self {
        self.set_header(Event::new(event_type).with_id(id))
    }

    fn event_full(
        self,
        event_type: EventType,
        id: Option<impl Into<String>>,
        params_vec: Vec<(impl Into<String>, Option<impl Into<String>>)>,
    ) -> Self {
        let mut event = Event::new(event_type);
        if let Some(id_val) = id {
            event = event.with_id(id_val);
        }
        let mut btree_params = Params::new();
        for (key, value_opt) in params_vec {
            let param_value = match value_opt.map(Into::into) {
                Some(v_str) => ParamValue::Value(v_str),
                None => ParamValue::None,
            };
            btree_params.insert(key.into(), param_value);
        }
        event.params = btree_params;
        self.set_header(event)
    }

    fn event_presence(self, id: Option<impl Into<String>>) -> Self {
        let event = Event::new(EventType::Token("presence".to_string()));
        if let Some(id_val) = id {
            self.set_header(event.with_id(id_val))
        } else {
            self.set_header(event)
        }
    }

    fn event_conference(self, id: Option<impl Into<String>>) -> Self {
        let event = Event::new(EventType::Package("conference".to_string()));
         if let Some(id_val) = id {
            self.set_header(event.with_id(id_val))
        } else {
            self.set_header(event)
        }
    }
    
    fn event_dialog(self, id: Option<impl Into<String>>) -> Self {
        let event = Event::new(EventType::Token("dialog".to_string()));
        if let Some(id_val) = id {
            self.set_header(event.with_id(id_val))
        } else {
            self.set_header(event)
        }
    }

    fn event_message_summary(self, id: Option<impl Into<String>>) -> Self {
        let event = Event::new(EventType::Token("message-summary".to_string()));
        if let Some(id_val) = id {
            self.set_header(event.with_id(id_val))
        } else {
            self.set_header(event)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::headers::{HeaderName, header_access::HeaderAccess};
    use crate::types::method::Method;
    use crate::types::uri::Uri;
    use crate::types::StatusCode;
    use crate::{RequestBuilder, ResponseBuilder}; // Assuming these are your primary builders
    use std::str::FromStr;

    #[test]
    fn test_set_full_event_object() {
        let mut custom_event = Event::new(EventType::Token("custom-event".to_string()))
            .with_id("custom-id-001");
        custom_event.params.insert("p1".to_string(), ParamValue::Value("v1".to_string()));

        let request = RequestBuilder::new(Method::Subscribe, "sip:test@example.com").unwrap()
            .event(custom_event.clone()) // clone because we assert against it later
            .build();

        if let Some(TypedHeader::Event(h)) = request.header(&HeaderName::Event) {
            assert_eq!(*h, custom_event);
        } else {
            panic!("Event header not found or of wrong type");
        }
    }

    #[test]
    fn test_event_type_only() {
        let request = RequestBuilder::new(Method::Subscribe, "sip:test@example.com").unwrap()
            .event_type(EventType::Token("keep-alive".to_string()))
            .build();

        if let Some(TypedHeader::Event(h)) = request.header(&HeaderName::Event) {
            assert_eq!(h.event_type, EventType::Token("keep-alive".to_string()));
            assert!(h.id.is_none());
            assert!(h.params.is_empty());
        } else {
            panic!("Event header not found or of wrong type");
        }
    }

    #[test]
    fn test_event_type_as_package() {
        let request = RequestBuilder::new(Method::Subscribe, "sip:test@example.com").unwrap()
            .event_type(EventType::Package("conference-info".to_string()))
            .build();

        if let Some(TypedHeader::Event(h)) = request.header(&HeaderName::Event) {
            assert_eq!(h.event_type, EventType::Package("conference-info".to_string()));
            assert!(h.id.is_none());
            assert!(h.params.is_empty());
        } else {
            panic!("Event header not found or of wrong type");
        }
    }
    
    #[test]
    fn test_event_id_token_type() {
        let response = ResponseBuilder::new(StatusCode::Ok, None)
            .event_id(EventType::Token("presence".to_string()), "pres-sub-123")
            .build();

        if let Some(TypedHeader::Event(h)) = response.header(&HeaderName::Event) {
            assert_eq!(h.event_type, EventType::Token("presence".to_string()));
            assert_eq!(h.id, Some("pres-sub-123".to_string()));
            assert!(h.params.is_empty());
        } else {
            panic!("Event header not found or of wrong type");
        }
    }

    #[test]
    fn test_event_id_package_type() {
        let response = ResponseBuilder::new(StatusCode::Ok, None)
            .event_id(EventType::Package("reg".to_string()), "reg-event-001")
            .build();

        if let Some(TypedHeader::Event(h)) = response.header(&HeaderName::Event) {
            assert_eq!(h.event_type, EventType::Package("reg".to_string()));
            assert_eq!(h.id, Some("reg-event-001".to_string()));
            assert!(h.params.is_empty());
        } else {
            panic!("Event header not found or of wrong type");
        }
    }

    #[test]
    fn test_event_full_with_id_and_params() {
        let params_to_add = vec![
            ("p1".to_string(), Some("v1".to_string())),
            ("flag".to_string(), None),
            ("p2".to_string(), Some("v2".to_string())),
        ];
        let request = RequestBuilder::new(Method::Notify, "sip:user@example.com").unwrap()
            .event_full(
                EventType::Token("custom".to_string()),
                Some("id-789"),
                params_to_add,
            )
            .build();

        if let Some(TypedHeader::Event(h)) = request.header(&HeaderName::Event) {
            assert_eq!(h.event_type, EventType::Token("custom".to_string()));
            assert_eq!(h.id, Some("id-789".to_string()));
            assert_eq!(h.params.len(), 3);
            assert_eq!(h.params.get("p1"), Some(&ParamValue::Value("v1".to_string())));
            assert_eq!(h.params.get("flag"), Some(&ParamValue::None));
            assert_eq!(h.params.get("p2"), Some(&ParamValue::Value("v2".to_string())));
        } else {
            panic!("Event header not found or of wrong type");
        }
    }

    #[test]
    fn test_event_full_no_id_with_params() {
         let params_to_add = vec![
            ("app-data".to_string(), Some("payload".to_string())),
        ];
        let request = RequestBuilder::new(Method::Notify, "sip:user@example.com").unwrap()
            .event_full(
                EventType::Token("generic-event".to_string()),
                None::<String>, // No ID - Explicitly typed
                params_to_add,
            )
            .build();

        if let Some(TypedHeader::Event(h)) = request.header(&HeaderName::Event) {
            assert_eq!(h.event_type, EventType::Token("generic-event".to_string()));
            assert!(h.id.is_none());
            assert_eq!(h.params.len(), 1);
            assert_eq!(h.params.get("app-data"), Some(&ParamValue::Value("payload".to_string())));
        } else {
            panic!("Event header not found or of wrong type");
        }
    }
    
    #[test]
    fn test_event_full_no_params() {
        let request = RequestBuilder::new(Method::Notify, "sip:user@example.com").unwrap()
            .event_full(
                EventType::Token("another-event".to_string()),
                Some("id-abc"),
                Vec::<(String, Option<String>)>::new(), // No params - Explicitly typed empty Vec
            )
            .build();

        if let Some(TypedHeader::Event(h)) = request.header(&HeaderName::Event) {
            assert_eq!(h.event_type, EventType::Token("another-event".to_string()));
            assert_eq!(h.id, Some("id-abc".to_string()));
            assert!(h.params.is_empty());
        } else {
            panic!("Event header not found or of wrong type");
        }
    }

    #[test]
    fn test_convenience_presence() {
        let request = RequestBuilder::new(Method::Subscribe, "sip:test@example.com").unwrap()
            .event_presence(Some("pres-001"))
            .build();
        if let Some(TypedHeader::Event(h)) = request.header(&HeaderName::Event) {
            assert_eq!(h.event_type, EventType::Token("presence".to_string()));
            assert_eq!(h.id, Some("pres-001".to_string()));
        } else { panic!("Event header not found"); }

        let request_no_id = RequestBuilder::new(Method::Subscribe, "sip:test@example.com").unwrap()
            .event_presence(None::<String>) // Explicitly typed None
            .build();
        if let Some(TypedHeader::Event(h)) = request_no_id.header(&HeaderName::Event) {
            assert_eq!(h.event_type, EventType::Token("presence".to_string()));
            assert!(h.id.is_none());
        } else { panic!("Event header not found"); }
    }

    #[test]
    fn test_convenience_conference() {
        let request = RequestBuilder::new(Method::Subscribe, "sip:test@example.com").unwrap()
            .event_conference(Some("conf-xyz"))
            .build();
        if let Some(TypedHeader::Event(h)) = request.header(&HeaderName::Event) {
            assert_eq!(h.event_type, EventType::Package("conference".to_string()));
            assert_eq!(h.id, Some("conf-xyz".to_string()));
        } else { panic!("Event header not found"); }
    }

    #[test]
    fn test_convenience_dialog() {
        let request = RequestBuilder::new(Method::Subscribe, "sip:test@example.com").unwrap()
            .event_dialog(Some("dlg-777"))
            .build();
        if let Some(TypedHeader::Event(h)) = request.header(&HeaderName::Event) {
            assert_eq!(h.event_type, EventType::Token("dialog".to_string()));
            assert_eq!(h.id, Some("dlg-777".to_string()));
        } else { panic!("Event header not found"); }
    }

    #[test]
    fn test_convenience_message_summary() {
        let request = RequestBuilder::new(Method::Subscribe, "sip:test@example.com").unwrap()
            .event_message_summary(None::<String>) // Explicitly typed None
            .build();
        if let Some(TypedHeader::Event(h)) = request.header(&HeaderName::Event) {
            assert_eq!(h.event_type, EventType::Token("message-summary".to_string()));
            assert!(h.id.is_none());
        } else { panic!("Event header not found"); }
    }
} 