//! # ACK Method Utilities for SIP Transactions
//!
//! This module implements special handling for ACK requests according to RFC 3261 Section 17.1.1.3.
//! In SIP, the ACK method has a unique dual nature that requires special handling at the transaction layer.
//!
//! ## ACK's Dual Nature in the Transaction Layer
//!
//! ACK behaves differently depending on the type of response it acknowledges:
//!
//! 1. **ACK for 2xx responses**:
//!    - Creates a new transaction separate from the INVITE
//!    - Uses a new branch parameter (new transaction ID)
//!    - Sent directly from the Transaction User (TU), not by the transaction layer
//!    - May follow a different route than the original INVITE
//!    - See RFC 3261 Section 13.2.2.4
//!
//! 2. **ACK for non-2xx responses**:
//!    - Part of the same transaction as the INVITE
//!    - Uses the same branch parameter as the INVITE
//!    - Automatically generated by the transaction layer
//!    - Follows the same route as the INVITE
//!    - See RFC 3261 Section 17.1.1.3
//!
//! ## Transaction Layer Responsibilities
//!
//! Per RFC 3261, the transaction layer is responsible for:
//! - Automatically generating ACKs for non-2xx responses
//! - NOT automatically generating ACKs for 2xx responses (this is the TU's job)
//! - Correctly matching incoming ACKs to the right transaction
//! - Handling the different timer behaviors for ACKed transactions
//!
//! ## Diagram: ACK Processing in Transaction Layer
//!
//! ```text
//! INVITE Client Transaction                          Server
//!    |                                                |
//!    |------------------INVITE-------------------->  |
//!    |                                                |
//!    |                                                |
//!    |  For non-2xx (e.g., 4xx):                     |
//!    |<-----------------4xx Error--------------------|
//!    |                                                |
//!    |------------------ACK----------------------->  | ← Same transaction
//!    |  (Auto-generated by transaction layer)         |
//!    |                                                |
//!    |  For 2xx:                                      |
//!    |<-------------------200 OK--------------------|
//!    |                                                |
//!    |------------------ACK----------------------->  | ← New transaction
//!    |  (Generated by Transaction User)               |
//!    |                                                |
//! ```
//!
//! This module provides utility functions to create both types of ACK requests
//! according to the rules defined in RFC 3261.

use std::net::SocketAddr;

use rvoip_sip_core::prelude::*;
use rvoip_sip_core::types::CSeq;
use rvoip_sip_core::types::MaxForwards;
use rvoip_sip_core::builder::SimpleRequestBuilder;
use uuid::Uuid;

use crate::error::{Error, Result};

/// Creates an ACK request for a 2xx response to an INVITE.
///
/// According to RFC 3261 Sections 13.2.2.4 and 17.1.1.3, ACK for 2xx responses:
/// - Is a separate transaction from the INVITE
/// - Uses the contact address from the 2xx response as the Request-URI
/// - Must have a new branch parameter (new transaction ID)
/// - Contains the same Call-ID, From, and CSeq number as the INVITE
/// - Contains the To tag from the 2xx response
///
/// The Transaction User (TU) is responsible for generating and sending this ACK,
/// not the transaction layer. This function helps the TU create a properly
/// formatted ACK for 2xx responses.
///
/// # RFC References
/// - RFC 3261 Section 13.2.2.4: Generation of the ACK Request
/// - RFC 3261 Section 17.1.1.3: Construction of the ACK Request
///
/// # Arguments
/// * `invite_request` - The original INVITE request
/// * `ok_response` - The 2xx response to acknowledge
/// * `local_addr` - The local address to use in the Via header
///
/// # Returns
/// * `Result<Request>` - The ACK request or an error
///
/// # Example
/// ```
/// # use std::net::SocketAddr;
/// # use std::str::FromStr;
/// # use rvoip_sip_core::builder::{SimpleRequestBuilder, SimpleResponseBuilder};
/// # use rvoip_sip_core::prelude::*;
/// # use rvoip_sip_core::types::status::StatusCode;
/// # use rvoip_transaction_core::method::ack::create_ack_for_2xx;
/// # use rvoip_transaction_core::error::Result;
/// #
/// # // Create a simple INVITE request
/// # let invite = SimpleRequestBuilder::new(Method::Invite, "sip:bob@example.com").unwrap()
/// #     .from("Alice", "sip:alice@example.com", Some("alice-tag"))
/// #     .to("Bob", "sip:bob@example.com", None)
/// #     .call_id("test-call-id-1234")
/// #     .cseq(101)
/// #     .via("127.0.0.1:5060", "UDP", Some("z9hG4bK.originalbranchvalue"))
/// #     .build();
/// #
/// # // Create a 200 OK response
/// # let ok_response = SimpleResponseBuilder::response_from_request(&invite, StatusCode::Ok, Some("OK"))
/// #     .to("Bob", "sip:bob@example.com", Some("bob-tag-resp"))
/// #     .contact("sip:bob@192.168.1.2:5060", Some("Bob"))
/// #     .build();
/// #
/// # let local_addr = SocketAddr::from_str("127.0.0.1:5060").unwrap();
/// #
/// // Create an ACK for the 200 OK response
/// let ack = create_ack_for_2xx(&invite, &ok_response, &local_addr).unwrap();
///
/// // The ACK should have a new branch parameter
/// let invite_via = invite.first_via().unwrap();
/// let ack_via = ack.first_via().unwrap();
/// assert_ne!(invite_via.branch().unwrap(), ack_via.branch().unwrap());
///
/// // But should have the same Call-ID
/// assert_eq!(invite.call_id().unwrap(), ack.call_id().unwrap());
/// ```
pub fn create_ack_for_2xx(
    invite_request: &Request,
    ok_response: &Response,
    local_addr: &SocketAddr
) -> Result<Request> {
    // Validate that this is an INVITE request
    if invite_request.method() != Method::Invite {
        return Err(Error::Other("Cannot create ACK for non-INVITE request".to_string()));
    }
    
    // Validate that this is a 2xx response
    let status_code = ok_response.status_code();
    if status_code < 200 || status_code >= 300 {
        return Err(Error::Other(format!("Cannot create ACK for non-2xx response: {}", status_code)));
    }
    
    // Get Request-URI from Contact header in the response if available
    let request_uri = if let Some(TypedHeader::Contact(contact)) = ok_response.header(&HeaderName::Contact) {
        if let Some(contact_addr) = contact.addresses().next() {
            contact_addr.uri.clone()
        } else {
            invite_request.uri().clone()
        }
    } else {
        invite_request.uri().clone()
    };
    
    // Extract required headers
    let from = invite_request.from()
        .ok_or_else(|| Error::Other("INVITE request missing From header".to_string()))?
        .clone();
    
    // Use To from the response (will have a tag)
    let to = ok_response.to()
        .ok_or_else(|| Error::Other("Response missing To header".to_string()))?
        .clone();
    
    let call_id = invite_request.call_id()
        .ok_or_else(|| Error::Other("INVITE request missing Call-ID header".to_string()))?
        .clone();
    
    let cseq_num = invite_request.cseq()
        .ok_or_else(|| Error::Other("INVITE request missing CSeq header".to_string()))?
        .seq;
    
    // Create a new branch ID
    let branch = format!("z9hG4bK{}", Uuid::new_v4().to_string().replace("-", ""));
    
    // Build the ACK request
    let mut builder = SimpleRequestBuilder::new(Method::Ack, &request_uri.to_string())
        .map_err(|e| Error::Other(format!("Failed to create ACK builder: {}", e)))?;
    
    builder = builder
        .header(TypedHeader::From(from))
        .header(TypedHeader::To(to))
        .header(TypedHeader::CallId(call_id))
        .header(TypedHeader::CSeq(CSeq::new(cseq_num, Method::Ack)))
        .via(&local_addr.to_string(), "UDP", Some(&branch))
        .header(TypedHeader::MaxForwards(MaxForwards::new(70)))
        .header(TypedHeader::ContentLength(ContentLength::new(0)));
    
    // Copy Route headers from the response if any
    if let Some(route_header) = ok_response.header(&HeaderName::RecordRoute) {
        builder = builder.header(route_header.clone());
    }
    
    Ok(builder.build())
}

/// Creates an ACK request for a non-2xx final response to an INVITE.
///
/// According to RFC 3261 Section 17.1.1.3, ACK for non-2xx final responses:
/// - Is part of the same transaction as the INVITE
/// - Has the same Request-URI, Call-ID, From, CSeq number as the INVITE
/// - Uses the same branch parameter as the INVITE (same transaction ID)
/// - Contains the To tag from the error response
/// - Is automatically generated by the transaction layer, not the TU
///
/// This type of ACK is used to acknowledge receipt of the error response, but
/// does not indicate acceptance of the response by the TU. The transaction layer
/// is responsible for generating and sending this ACK automatically.
///
/// # RFC References
/// - RFC 3261 Section 17.1.1.3: Construction of the ACK Request
///
/// # Arguments
/// * `invite_request` - The original INVITE request
/// * `error_response` - The non-2xx final response to acknowledge
///
/// # Returns
/// * `Result<Request>` - The ACK request or an error
///
/// # Example
/// ```
/// # use std::net::SocketAddr;
/// # use std::str::FromStr;
/// # use rvoip_sip_core::builder::{SimpleRequestBuilder, SimpleResponseBuilder};
/// # use rvoip_sip_core::prelude::*;
/// # use rvoip_sip_core::types::status::StatusCode;
/// # use rvoip_transaction_core::method::ack::create_ack_for_error_response;
/// # use rvoip_transaction_core::error::Result;
/// #
/// # // Create a simple INVITE request
/// # let invite = SimpleRequestBuilder::new(Method::Invite, "sip:bob@example.com").unwrap()
/// #     .from("Alice", "sip:alice@example.com", Some("alice-tag"))
/// #     .to("Bob", "sip:bob@example.com", None)
/// #     .call_id("test-call-id-1234")
/// #     .cseq(101)
/// #     .via("127.0.0.1:5060", "UDP", Some("z9hG4bK.originalbranchvalue"))
/// #     .build();
/// #
/// # // Create a 404 Not Found response
/// # let error_response = SimpleResponseBuilder::response_from_request(&invite, StatusCode::NotFound, Some("Not Found"))
/// #     .to("Bob", "sip:bob@example.com", Some("bob-tag-error"))
/// #     .build();
/// #
/// // Create an ACK for the error response
/// let ack = create_ack_for_error_response(&invite, &error_response).unwrap();
///
/// // The ACK should have the same branch parameter as the INVITE
/// let invite_via = invite.first_via().unwrap();
/// let ack_via = ack.first_via().unwrap();
/// assert_eq!(invite_via.branch().unwrap(), ack_via.branch().unwrap());
///
/// // And the same Call-ID
/// assert_eq!(invite.call_id().unwrap(), ack.call_id().unwrap());
/// ```
pub fn create_ack_for_error_response(
    invite_request: &Request,
    error_response: &Response
) -> Result<Request> {
    // Validate that this is an INVITE request
    if invite_request.method() != Method::Invite {
        return Err(Error::Other("Cannot create ACK for non-INVITE request".to_string()));
    }
    
    // Validate that this is a non-2xx final response
    let status_code = error_response.status_code();
    if status_code < 300 {
        return Err(Error::Other(format!("Cannot create error ACK for 1xx or 2xx response: {}", status_code)));
    }
    
    // For an error ACK, we use the same Request-URI as the INVITE
    let request_uri = invite_request.uri().clone();
    
    // Extract required headers
    let from = invite_request.from()
        .ok_or_else(|| Error::Other("INVITE request missing From header".to_string()))?
        .clone();
    
    // Use To from the response (will have a tag)
    let to = error_response.to()
        .ok_or_else(|| Error::Other("Response missing To header".to_string()))?
        .clone();
    
    let call_id = invite_request.call_id()
        .ok_or_else(|| Error::Other("INVITE request missing Call-ID header".to_string()))?
        .clone();
    
    let cseq_num = invite_request.cseq()
        .ok_or_else(|| Error::Other("INVITE request missing CSeq header".to_string()))?
        .seq;
    
    // For non-2xx responses, we use the same branch ID as the INVITE
    let via_header = invite_request.header(&HeaderName::Via)
        .ok_or_else(|| Error::Other("INVITE request missing Via header".to_string()))?
        .clone();
    
    // Build the ACK request
    let mut builder = SimpleRequestBuilder::new(Method::Ack, &request_uri.to_string())
        .map_err(|e| Error::Other(format!("Failed to create ACK builder: {}", e)))?;
    
    builder = builder
        .header(TypedHeader::From(from))
        .header(TypedHeader::To(to))
        .header(TypedHeader::CallId(call_id))
        .header(TypedHeader::CSeq(CSeq::new(cseq_num, Method::Ack)))
        .header(via_header)
        .header(TypedHeader::MaxForwards(MaxForwards::new(70)))
        .header(TypedHeader::ContentLength(ContentLength::new(0)));
    
    // Copy Route headers from the INVITE
    if let Some(route_header) = invite_request.header(&HeaderName::Route) {
        builder = builder.header(route_header.clone());
    }
    
    Ok(builder.build())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::net::SocketAddr;
    use std::str::FromStr;
    use rvoip_sip_core::builder::{SimpleRequestBuilder, SimpleResponseBuilder};
    use rvoip_sip_core::types::status::StatusCode;
    
    fn create_test_invite() -> Request {
        let builder = SimpleRequestBuilder::new(Method::Invite, "sip:bob@example.com")
            .expect("Failed to create request builder");
            
        builder
            .from("Alice", "sip:alice@example.com", Some("alice-tag"))
            .to("Bob", "sip:bob@example.com", None)
            .call_id("test-call-id-1234")
            .cseq(101)
            .via("127.0.0.1:5060", "UDP", Some("z9hG4bK.originalbranchvalue"))
            .max_forwards(70)
            .build()
    }
    
    fn create_2xx_response(invite: &Request) -> Response {
        SimpleResponseBuilder::response_from_request(invite, StatusCode::Ok, Some("OK"))
            .to("Bob", "sip:bob@example.com", Some("bob-tag-resp"))
            .contact("sip:bob@192.168.1.2:5060", Some("Bob"))
            .build()
    }
    
    fn create_4xx_response(invite: &Request) -> Response {
        SimpleResponseBuilder::response_from_request(invite, StatusCode::BadRequest, Some("Bad Request"))
            .to("Bob", "sip:bob@example.com", Some("bob-tag-error"))
            .build()
    }
    
    #[test]
    fn test_create_ack_for_2xx() {
        let invite = create_test_invite();
        let ok_response = create_2xx_response(&invite);
        let local_addr = SocketAddr::from_str("127.0.0.1:5060").unwrap();
        
        let ack = create_ack_for_2xx(&invite, &ok_response, &local_addr).expect("Failed to create ACK");
        
        // Verify the ACK has the right method
        assert_eq!(ack.method(), Method::Ack);
        
        // Verify Request-URI comes from contact
        assert!(ack.uri().to_string().contains("192.168.1.2:5060"));
        
        // Verify From header copied from INVITE
        assert_eq!(ack.from().unwrap().tag(), invite.from().unwrap().tag());
        
        // Verify To header comes from response (with tag)
        assert_eq!(ack.to().unwrap().tag().unwrap(), "bob-tag-resp");
        
        // Verify CSeq has same number but ACK method
        let ack_cseq = ack.cseq().unwrap();
        let invite_cseq = invite.cseq().unwrap();
        assert_eq!(ack_cseq.seq, invite_cseq.seq);
        assert_eq!(ack_cseq.method, Method::Ack);
        
        // Verify branch parameter is different
        let ack_via = ack.header(&HeaderName::Via).unwrap();
        let invite_via = invite.header(&HeaderName::Via).unwrap();
        assert_ne!(ack_via, invite_via);
    }
    
    #[test]
    fn test_create_ack_for_error_response() {
        let invite = create_test_invite();
        let error_response = create_4xx_response(&invite);
        
        let ack = create_ack_for_error_response(&invite, &error_response).expect("Failed to create ACK");
        
        // Verify the ACK has the right method
        assert_eq!(ack.method(), Method::Ack);
        
        // Verify Request-URI same as INVITE
        assert_eq!(ack.uri(), invite.uri());
        
        // Verify From header copied from INVITE
        assert_eq!(ack.from().unwrap().tag(), invite.from().unwrap().tag());
        
        // Verify To header comes from response (with tag)
        assert_eq!(ack.to().unwrap().tag().unwrap(), "bob-tag-error");
        
        // Verify CSeq has same number but ACK method
        let ack_cseq = ack.cseq().unwrap();
        let invite_cseq = invite.cseq().unwrap();
        assert_eq!(ack_cseq.seq, invite_cseq.seq);
        assert_eq!(ack_cseq.method, Method::Ack);
        
        // Verify branch parameter is the same
        let ack_via = ack.header(&HeaderName::Via).unwrap();
        let invite_via = invite.header(&HeaderName::Via).unwrap();
        assert_eq!(ack_via, invite_via);
    }
    
    #[test]
    fn test_create_ack_for_2xx_invalid_input() {
        // Test with non-INVITE request
        let non_invite = SimpleRequestBuilder::new(Method::Register, "sip:registrar.example.com").unwrap()
            .from("Alice", "sip:alice@example.com", Some("alice-tag"))
            .to("Registrar", "sip:registrar.example.com", None)
            .call_id("test-call-id-1234")
            .cseq(101)
            .via("127.0.0.1:5060", "UDP", Some("z9hG4bK.branch"))
            .build();
            
        let ok_response = SimpleResponseBuilder::response_from_request(&non_invite, StatusCode::Ok, Some("OK"))
            .to("Registrar", "sip:registrar.example.com", Some("reg-tag"))
            .build();
            
        let local_addr = SocketAddr::from_str("127.0.0.1:5060").unwrap();
        
        let result = create_ack_for_2xx(&non_invite, &ok_response, &local_addr);
        assert!(result.is_err());
        
        // Test with non-2xx response
        let invite = create_test_invite();
        let error_response = create_4xx_response(&invite);
        
        let result = create_ack_for_2xx(&invite, &error_response, &local_addr);
        assert!(result.is_err());
    }
    
    #[test]
    fn test_create_ack_for_error_response_invalid_input() {
        // Test with non-INVITE request
        let non_invite = SimpleRequestBuilder::new(Method::Register, "sip:registrar.example.com").unwrap()
            .from("Alice", "sip:alice@example.com", Some("alice-tag"))
            .to("Registrar", "sip:registrar.example.com", None)
            .call_id("test-call-id-1234")
            .cseq(101)
            .via("127.0.0.1:5060", "UDP", Some("z9hG4bK.branch"))
            .build();
            
        let error_response = SimpleResponseBuilder::response_from_request(&non_invite, StatusCode::BadRequest, Some("Bad Request"))
            .to("Registrar", "sip:registrar.example.com", Some("reg-tag"))
            .build();
            
        let result = create_ack_for_error_response(&non_invite, &error_response);
        assert!(result.is_err());
        
        // Test with 2xx response
        let invite = create_test_invite();
        let ok_response = create_2xx_response(&invite);
        
        let result = create_ack_for_error_response(&invite, &ok_response);
        assert!(result.is_err());
    }
} 