├── .github
    └── workflows
    │   └── rust-ci.yml
├── .gitignore
├── Cargo.lock
├── Cargo.toml
├── LICENSE
├── README.md
├── examples
    └── unauthorized_register.rs
├── rsip-derives
    ├── Cargo.toml
    ├── LICENSE
    ├── README.md
    └── src
    │   ├── lib.rs
    │   ├── newtype.rs
    │   ├── to_typed_header.rs
    │   ├── typed_header.rs
    │   └── untyped_header.rs
├── src
    ├── common
    │   ├── language.rs
    │   ├── method.rs
    │   ├── mod.rs
    │   ├── status_code.rs
    │   ├── transport.rs
    │   ├── uri
    │   │   ├── auth.rs
    │   │   ├── host_with_port
    │   │   │   ├── host.rs
    │   │   │   ├── mod.rs
    │   │   │   └── port.rs
    │   │   ├── mod.rs
    │   │   ├── param
    │   │   │   ├── branch.rs
    │   │   │   ├── expires.rs
    │   │   │   ├── maddr.rs
    │   │   │   ├── mod.rs
    │   │   │   ├── q.rs
    │   │   │   ├── received.rs
    │   │   │   ├── tag.rs
    │   │   │   ├── ttl.rs
    │   │   │   └── user.rs
    │   │   ├── scheme.rs
    │   │   ├── uri_with_params.rs
    │   │   └── uri_with_params_list.rs
    │   └── version.rs
    ├── error
    │   ├── mod.rs
    │   └── tokenizer_error.rs
    ├── headers
    │   ├── auth
    │   │   ├── algorithm.rs
    │   │   ├── mod.rs
    │   │   ├── qop.rs
    │   │   └── scheme.rs
    │   ├── header.rs
    │   ├── mod.rs
    │   ├── typed
    │   │   ├── accept.rs
    │   │   ├── alert_info.rs
    │   │   ├── allow.rs
    │   │   ├── authentication_info.rs
    │   │   ├── authorization.rs
    │   │   ├── call_info.rs
    │   │   ├── contact.rs
    │   │   ├── content_disposition.rs
    │   │   ├── content_type.rs
    │   │   ├── cseq.rs
    │   │   ├── error_info.rs
    │   │   ├── from.rs
    │   │   ├── in_reply_to.rs
    │   │   ├── media_type.rs
    │   │   ├── mod.rs
    │   │   ├── priority.rs
    │   │   ├── proxy_authenticate.rs
    │   │   ├── proxy_authorization.rs
    │   │   ├── record_route.rs
    │   │   ├── reply_to.rs
    │   │   ├── route.rs
    │   │   ├── to.rs
    │   │   ├── tokenizers
    │   │   │   ├── auth.rs
    │   │   │   ├── cseq.rs
    │   │   │   ├── display_uri_params.rs
    │   │   │   ├── mod.rs
    │   │   │   ├── name_params.rs
    │   │   │   ├── name_params_list.rs
    │   │   │   ├── name_value.rs
    │   │   │   ├── token_list.rs
    │   │   │   ├── uri_with_params.rs
    │   │   │   ├── uri_with_params_list.rs
    │   │   │   ├── value.rs
    │   │   │   ├── via.rs
    │   │   │   └── warning.rs
    │   │   ├── via.rs
    │   │   ├── warning.rs
    │   │   └── www_authenticate.rs
    │   └── untyped
    │   │   ├── accept.rs
    │   │   ├── accept_encoding.rs
    │   │   ├── accept_language.rs
    │   │   ├── alert_info.rs
    │   │   ├── allow.rs
    │   │   ├── authentication_info.rs
    │   │   ├── authorization.rs
    │   │   ├── call_id.rs
    │   │   ├── call_info.rs
    │   │   ├── contact.rs
    │   │   ├── content_disposition.rs
    │   │   ├── content_encoding.rs
    │   │   ├── content_language.rs
    │   │   ├── content_length.rs
    │   │   ├── content_type.rs
    │   │   ├── cseq.rs
    │   │   ├── date.rs
    │   │   ├── error_info.rs
    │   │   ├── event.rs
    │   │   ├── expires.rs
    │   │   ├── from.rs
    │   │   ├── in_reply_to.rs
    │   │   ├── max_forwards.rs
    │   │   ├── mime_version.rs
    │   │   ├── min_expires.rs
    │   │   ├── mod.rs
    │   │   ├── organization.rs
    │   │   ├── priority.rs
    │   │   ├── proxy_authenticate.rs
    │   │   ├── proxy_authorization.rs
    │   │   ├── proxy_require.rs
    │   │   ├── record_route.rs
    │   │   ├── reply_to.rs
    │   │   ├── require.rs
    │   │   ├── retry_after.rs
    │   │   ├── route.rs
    │   │   ├── server.rs
    │   │   ├── subject.rs
    │   │   ├── subscription_state.rs
    │   │   ├── supported.rs
    │   │   ├── timestamp.rs
    │   │   ├── to.rs
    │   │   ├── unsupported.rs
    │   │   ├── user_agent.rs
    │   │   ├── via.rs
    │   │   ├── warning.rs
    │   │   └── www_authenticate.rs
    ├── lib.rs
    ├── message
    │   ├── header_macros.rs
    │   ├── headers_ext.rs
    │   ├── mod.rs
    │   ├── request.rs
    │   ├── response.rs
    │   └── sip_message.rs
    └── services
    │   ├── digest_generator.rs
    │   └── mod.rs
└── tests
    ├── common
        ├── method.rs
        ├── mod.rs
        ├── status_code.rs
        ├── transport.rs
        ├── uri
        │   ├── auth.rs
        │   ├── host_with_port.rs
        │   ├── mod.rs
        │   ├── params
        │   │   └── mod.rs
        │   ├── scheme.rs
        │   ├── uri_with_params.rs
        │   └── uri_with_params_list.rs
        └── version.rs
    ├── headers
        ├── accept
        │   ├── mod.rs
        │   └── typed.rs
        ├── alert_info
        │   ├── mod.rs
        │   └── typed.rs
        ├── allow
        │   ├── mod.rs
        │   └── typed.rs
        ├── auth
        │   ├── mod.rs
        │   └── scheme.rs
        ├── authentication_info
        │   ├── mod.rs
        │   └── typed.rs
        ├── authorization
        │   ├── mod.rs
        │   └── typed.rs
        ├── call_info
        │   ├── mod.rs
        │   └── typed.rs
        ├── contact
        │   ├── mod.rs
        │   └── typed.rs
        ├── content_disposition
        │   ├── mod.rs
        │   └── typed.rs
        ├── content_length
        │   └── mod.rs
        ├── content_type
        │   ├── mod.rs
        │   └── typed.rs
        ├── cseq
        │   ├── mod.rs
        │   ├── tokenizer.rs
        │   └── typed.rs
        ├── error_info
        │   ├── mod.rs
        │   └── typed.rs
        ├── from
        │   ├── mod.rs
        │   └── typed.rs
        ├── in_reply_to
        │   ├── mod.rs
        │   └── typed.rs
        ├── max_forwards
        │   └── mod.rs
        ├── media_type.rs
        ├── mod.rs
        ├── priority
        │   ├── mod.rs
        │   └── typed.rs
        ├── proxy_authenticate
        │   ├── mod.rs
        │   └── typed.rs
        ├── proxy_authorization
        │   ├── mod.rs
        │   └── typed.rs
        ├── record_route
        │   ├── mod.rs
        │   └── typed.rs
        ├── reply_to
        │   ├── mod.rs
        │   └── typed.rs
        ├── route
        │   ├── mod.rs
        │   └── typed.rs
        ├── to
        │   ├── mod.rs
        │   └── typed.rs
        ├── tokenizers
        │   ├── auth.rs
        │   ├── display_uri_params.rs
        │   ├── mod.rs
        │   ├── name_params.rs
        │   ├── name_params_list.rs
        │   ├── name_value.rs
        │   ├── token_list.rs
        │   ├── value.rs
        │   └── warning.rs
        ├── via
        │   ├── mod.rs
        │   ├── tokenizer.rs
        │   └── typed.rs
        ├── warning
        │   ├── mod.rs
        │   └── typed.rs
        └── www_authenticate
        │   ├── mod.rs
        │   └── typed.rs
    ├── lib.rs
    ├── message
        ├── has_headers.rs
        ├── message.rs
        ├── mod.rs
        ├── request.rs
        └── response.rs
    ├── services
        ├── auth.rs
        └── mod.rs
    └── support
        ├── has_headers_impl.rs
        └── mod.rs


/.github/workflows/rust-ci.yml:
--------------------------------------------------------------------------------
 1 | on:
 2 |   push:
 3 |     branches:
 4 |       - master
 5 |   pull_request:
 6 |     branches: ['*']
 7 | 
 8 | name: Continuous integration
 9 | 
10 | jobs:
11 |   check:
12 |     name: Check
13 |     runs-on: ubuntu-latest
14 |     steps:
15 |       - uses: actions/checkout@v2
16 |       - uses: actions-rs/toolchain@v1
17 |         with:
18 |           profile: minimal
19 |           toolchain: stable
20 |           override: true
21 |       - uses: actions-rs/cargo@v1
22 |         with:
23 |           command: check
24 | 
25 |   test:
26 |     name: Test Suite
27 |     runs-on: ubuntu-latest
28 |     steps:
29 |       - uses: actions/checkout@v2
30 |       - uses: actions-rs/toolchain@v1
31 |         with:
32 |           profile: minimal
33 |           toolchain: stable
34 |           override: true
35 |       - uses: actions-rs/cargo@v1
36 |         with:
37 |           command: test
38 | 
39 |   fmt:
40 |     name: Rustfmt
41 |     runs-on: ubuntu-latest
42 |     steps:
43 |       - uses: actions/checkout@v2
44 |       - uses: actions-rs/toolchain@v1
45 |         with:
46 |           profile: minimal
47 |           toolchain: stable
48 |           override: true
49 |       - run: rustup component add rustfmt
50 |       - uses: actions-rs/cargo@v1
51 |         with:
52 |           command: fmt
53 |           args: --all -- --check
54 | 
55 |   clippy:
56 |     name: Clippy
57 |     runs-on: ubuntu-latest
58 |     steps:
59 |       - uses: actions/checkout@v2
60 |       - uses: actions-rs/toolchain@v1
61 |         with:
62 |           profile: minimal
63 |           toolchain: 1.60.0
64 |           override: true
65 |       - run: rustup component add clippy
66 |       - uses: actions-rs/cargo@v1
67 |         with:
68 |           command: clippy
69 |           args: -- -D warnings
70 |   coverage:
71 |     name: Coverage
72 |     runs-on: ubuntu-latest
73 | 
74 |     steps:
75 |       - name: Checkout sources
76 |         uses: actions/checkout@v2
77 | 
78 |       - name: Install rust
79 |         uses: actions-rs/toolchain@v1
80 |         with:
81 |           toolchain: stable
82 |           profile: minimal
83 |           override: true
84 | 
85 |       - name: Install cargo-tarpaulin
86 |         uses: actions-rs/cargo@v1
87 |         with:
88 |           command: install
89 |           args: cargo-tarpaulin --version 0.18.0-alpha3 # @TODO restore to normal (https://github.com/xd009642/tarpaulin/issues/756#issuecomment-838769320)
90 | 
91 |       - name: Run cargo tarpaulin
92 |         uses: actions-rs/cargo@v1
93 |         env:
94 |           TOKEN: ${{ secrets.COVERALLS_TOKEN }}
95 |         with:
96 |           command: tarpaulin
97 |           args: --coveralls "$TOKEN" --avoid-cfg-tarpaulin # @TODO restore to normal (https://github.com/xd009642/tarpaulin/issues/756#issuecomment-838769320)
98 | 


--------------------------------------------------------------------------------
/.gitignore:
--------------------------------------------------------------------------------
1 | target


--------------------------------------------------------------------------------
/Cargo.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "rsip"
 3 | version = "0.4.0"
 4 | authors = ["Filippos Vasilakis <vasilakisfil@gmail.com>"]
 5 | edition = "2018"
 6 | description = "SIP Rust library, parser & generator of SIP"
 7 | repository = "https://github.com/vasilakisfil/rsip"
 8 | documentation = "https://docs.rs/rsip"
 9 | keywords = ["sip", "3261", "session", "voip", "webrtc"]
10 | categories = ["parser-implementations", "parsing", "network-programming"]
11 | license-file = "LICENSE"
12 | 
13 | 
14 | [workspace]
15 | members = [
16 |     "rsip-derives",
17 | ]
18 | 
19 | [dependencies]
20 | uuid = { version = "0.8.1", features = ["v4"] }
21 | bytes = "1.0.1"
22 | nom = { version = "7.1.0", features = ["alloc"] }
23 | rsip-derives = { version = "0.4.0", path = "./rsip-derives" }
24 | md-5 = "0.9.1"
25 | sha2 = "0.9.5"
26 | testing-utils = { version = "0.1.1", optional = true }
27 | bstr = "0.2.17"
28 | 
29 | [features]
30 | test-utils = ["testing-utils"]
31 | 
32 | [dev-dependencies]
33 | quote = "1.0.9"
34 | rand = { version = "0.8.4" }
35 | 


--------------------------------------------------------------------------------
/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2020-2021 Filippos Vasilakis vasilakisfil@gmail.com
 4 | Copyright (c) 2019 Patrick Greene pmg41494@protonmail.com
 5 | 
 6 | Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 7 | 
 8 | The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 9 | 
10 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
11 | 
12 | Except as contained in this notice, the name of a copyright holder shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization of the copyright holder.
13 | 


--------------------------------------------------------------------------------
/rsip-derives/Cargo.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "rsip-derives"
 3 | version = "0.4.0"
 4 | authors = ["Filippos Vasilakis <vasilakisfil@gmail.com>"]
 5 | edition = "2018"
 6 | description = "rsip helpful macros, for internal use mostly"
 7 | repository = "https://github.com/vasilakisfil/rsip/tree/master/rsip-derives"
 8 | keywords = ["sip", "rsip", "macros", "derive", "derives"]
 9 | license-file = "LICENSE"
10 | 
11 | [lib]
12 | proc-macro = true
13 | 
14 | [dependencies]
15 | quote = "1.0.9"
16 | syn = { version = "1.0.65", features = ["extra-traits"] }
17 | proc-macro2 = "1.0.27"
18 | darling = "0.13.0"
19 | 


--------------------------------------------------------------------------------
/rsip-derives/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2020-2021 Filippos Vasilakis vasilakisfil@gmail.com
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 6 | 
 7 | The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 8 | 
 9 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
10 | 
11 | Except as contained in this notice, the name of a copyright holder shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization of the copyright holder.
12 | 


--------------------------------------------------------------------------------
/rsip-derives/README.md:
--------------------------------------------------------------------------------
1 | # rsip-macros
2 | A collection of useful (derive) macros used internally in rsip.
3 | Could be used when defining rsip extensions or new headers but other than that
4 | they are not supposed to be used in the user code.
5 | 


--------------------------------------------------------------------------------
/rsip-derives/src/newtype.rs:
--------------------------------------------------------------------------------
 1 | use quote::quote;
 2 | 
 3 | pub fn new_signature(struct_name: &syn::Ident, field_type: &syn::Type) -> proc_macro2::TokenStream {
 4 |     quote! {
 5 |         impl #struct_name {
 6 |             pub fn new(value: impl Into<#field_type>) -> Self {
 7 |                 Self(value.into())
 8 |             }
 9 |         }
10 |     }
11 | }
12 | 
13 | pub fn value_signature(
14 |     struct_name: &syn::Ident,
15 |     field_type: &syn::Type,
16 | ) -> proc_macro2::TokenStream {
17 |     let value_type = match crate::is_string(field_type.clone()) {
18 |         true => quote! { &str },
19 |         false => quote! { &#field_type },
20 |     };
21 | 
22 |     quote! {
23 |         impl #struct_name {
24 |             pub fn value(&self) -> #value_type {
25 |                 &self.0
26 |             }
27 |         }
28 |     }
29 | }
30 | 
31 | pub fn display_signature(struct_name: &syn::Ident) -> proc_macro2::TokenStream {
32 |     quote! {
33 |         impl std::fmt::Display for #struct_name {
34 |             fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
35 |                 write!(f, "{}", self.value())
36 |             }
37 |         }
38 |     }
39 | }
40 | 
41 | pub fn from_inner_signature(
42 |     struct_name: &syn::Ident,
43 |     field_type: &syn::Type,
44 | ) -> proc_macro2::TokenStream {
45 |     quote! {
46 |         impl<'a> std::convert::From<#field_type> for #struct_name {
47 |             fn from(from: #field_type) -> Self {
48 |                 Self(from)
49 |             }
50 |         }
51 |     }
52 | }
53 | 
54 | //TODO: when the type is Copy, is it faster to do *from.value() ?
55 | pub fn into_inner_signature(
56 |     struct_name: &syn::Ident,
57 |     field_type: &syn::Type,
58 | ) -> proc_macro2::TokenStream {
59 |     quote! {
60 |         impl<'a> std::convert::From<#struct_name> for #field_type {
61 |             fn from(from: #struct_name) -> Self {
62 |                 from.value().clone().into()
63 |             }
64 |         }
65 |     }
66 | }
67 | 
68 | pub fn from_str_signature(struct_name: &syn::Ident) -> proc_macro2::TokenStream {
69 |     quote! {
70 |         impl<'a> std::convert::From<&str> for #struct_name {
71 |             fn from(from: &str) -> Self {
72 |                 Self(from.into())
73 |             }
74 |         }
75 |     }
76 | }
77 | 


--------------------------------------------------------------------------------
/rsip-derives/src/to_typed_header.rs:
--------------------------------------------------------------------------------
 1 | use quote::quote;
 2 | 
 3 | pub fn trait_methods(struct_name: &syn::Ident) -> proc_macro2::TokenStream {
 4 |     quote! {
 5 |         impl<'a> crate::headers::untyped::ToTypedHeader<'a> for #struct_name {
 6 |             type Typed = crate::headers::typed::#struct_name;
 7 | 
 8 |             fn typed(&self) -> Result<Self::Typed, crate::Error> {
 9 |                 std::convert::TryInto::try_into(self.clone())
10 |             }
11 | 
12 |             fn into_typed(self) -> Result<Self::Typed, crate::Error> {
13 |                 std::convert::TryInto::try_into(self)
14 |             }
15 |         }
16 |     }
17 | }
18 | 


--------------------------------------------------------------------------------
/rsip-derives/src/untyped_header.rs:
--------------------------------------------------------------------------------
 1 | use quote::quote;
 2 | 
 3 | pub fn trait_methods(struct_name: &syn::Ident) -> proc_macro2::TokenStream {
 4 |     quote! {
 5 |         impl<'a> crate::headers::untyped::UntypedHeader<'a> for #struct_name {
 6 |             fn new(value: impl std::convert::Into<String>) -> Self {
 7 |                 Self(value.into())
 8 |             }
 9 | 
10 |             fn value(&self) -> &str {
11 |                 &self.0
12 |             }
13 | 
14 |             fn replace(&mut self, new_value: impl Into<String>) {
15 |                 self.0 = new_value.into();
16 |             }
17 |         }
18 |     }
19 | }
20 | 
21 | //TODO: are we sure that we want here the {}: {} ? Maybe Header should do that
22 | pub fn display(struct_name: &syn::Ident, display_name: Option<String>) -> proc_macro2::TokenStream {
23 |     let name = match display_name {
24 |         Some(display_name) => display_name,
25 |         None => crate::kebab_case(struct_name.to_string()),
26 |     };
27 | 
28 |     quote! {
29 |         impl std::fmt::Display for #struct_name {
30 |             fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
31 |                 use crate::headers::untyped::UntypedHeader;
32 | 
33 |                 write!(f, "{}: {}", #name, self.value())
34 |             }
35 |         }
36 |     }
37 | }
38 | 
39 | pub fn into_header(struct_name: &syn::Ident) -> proc_macro2::TokenStream {
40 |     quote! {
41 |         impl std::convert::From<#struct_name> for crate::Header {
42 |             fn from(from: #struct_name) -> Self {
43 |                 crate::Header::#struct_name(from)
44 |             }
45 |         }
46 |     }
47 | }
48 | 
49 | //TODO: this shouldn't be needed once specialization lands
50 | pub fn from_into_string(struct_name: &syn::Ident) -> proc_macro2::TokenStream {
51 |     let from = quote! {
52 |         impl<'a> std::convert::From<String> for #struct_name {
53 |             fn from(from: String) -> Self {
54 |                 Self(from)
55 |             }
56 |         }
57 |     };
58 | 
59 |     let from_value = quote! {
60 |         impl<'a> std::convert::From<#struct_name> for String {
61 |             fn from(from: #struct_name) -> Self {
62 |                 use crate::headers::untyped::UntypedHeader;
63 | 
64 |                 from.value().clone().into()
65 |             }
66 |         }
67 |     };
68 | 
69 |     quote! {
70 |         #from
71 |         #from_value
72 |     }
73 | }
74 | 
75 | //TODO: this shouldn't be needed once specialization lands
76 | pub fn from_str(struct_name: &syn::Ident) -> proc_macro2::TokenStream {
77 |     quote! {
78 |         impl<'a> std::convert::From<&str> for #struct_name {
79 |             fn from(from: &str) -> Self {
80 |                 Self(from.into())
81 |             }
82 |         }
83 |     }
84 | }
85 | 


--------------------------------------------------------------------------------
/src/common/language.rs:
--------------------------------------------------------------------------------
 1 | use rsip_derives::NewType;
 2 | 
 3 | #[derive(Debug, PartialEq, Eq, Clone)]
 4 | pub enum Language {
 5 |     English,
 6 |     Other(OtherLanguage),
 7 | }
 8 | 
 9 | #[derive(NewType, Debug, PartialEq, Eq, Clone)]
10 | pub struct OtherLanguage(String);
11 | 


--------------------------------------------------------------------------------
/src/common/mod.rs:
--------------------------------------------------------------------------------
 1 | pub mod language;
 2 | pub mod method;
 3 | pub mod status_code;
 4 | pub mod transport;
 5 | pub mod uri;
 6 | pub mod version;
 7 | 
 8 | pub use language::Language;
 9 | pub use method::Method;
10 | pub use status_code::{StatusCode, StatusCodeKind};
11 | pub use transport::Transport;
12 | pub use uri::param;
13 | pub use uri::Uri;
14 | pub use version::Version;
15 | 


--------------------------------------------------------------------------------
/src/common/uri/host_with_port/host.rs:
--------------------------------------------------------------------------------
  1 | use crate::Error;
  2 | use rsip_derives::NewType;
  3 | use std::convert::TryInto;
  4 | use std::hash::{Hash, Hasher};
  5 | use std::net::{IpAddr, Ipv4Addr, SocketAddr};
  6 | 
  7 | /// The `Host` enum represents the host part of the [HostWithPort](super::HostWithPort) struct
  8 | ///
  9 | /// It has 2 variants:
 10 | ///
 11 | /// * `Domain` that holds a [Domain] that represents a DNS domain.
 12 | /// * `IpAddr` that holds an [IpAddr](std::net::IpAddr) and represents a raw IP address
 13 | #[derive(Debug, PartialEq, Eq, Clone)]
 14 | pub enum Host {
 15 |     Domain(Domain),
 16 |     IpAddr(IpAddr),
 17 | }
 18 | 
 19 | impl Default for Host {
 20 |     fn default() -> Self {
 21 |         Self::IpAddr(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)))
 22 |     }
 23 | }
 24 | 
 25 | impl std::str::FromStr for Host {
 26 |     type Err = crate::Error;
 27 |     fn from_str(s: &str) -> Result<Self, Self::Err> {
 28 |         match s.parse::<IpAddr>() {
 29 |             Ok(ip_addr) => Ok(Host::IpAddr(ip_addr)),
 30 |             Err(_) => Ok(Host::Domain(s.into())),
 31 |         }
 32 |     }
 33 | }
 34 | 
 35 | /// A NewType around `String` to hold DNS domains.
 36 | /// No check is done when you convert something into `Domain`.
 37 | #[derive(NewType, Debug, Eq, Clone)]
 38 | pub struct Domain(String);
 39 | 
 40 | impl Hash for Domain {
 41 |     fn hash<H: Hasher>(&self, state: &mut H) {
 42 |         self.0.hash(state);
 43 |     }
 44 | }
 45 | 
 46 | impl PartialEq for Domain {
 47 |     fn eq(&self, other: &Self) -> bool {
 48 |         self.0 == other.0
 49 |     }
 50 | }
 51 | 
 52 | impl std::fmt::Display for Host {
 53 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
 54 |         match &self {
 55 |             Host::Domain(domain) => write!(f, "{}", domain),
 56 |             Host::IpAddr(ip_addr) => write!(f, "{}", ip_addr),
 57 |         }
 58 |     }
 59 | }
 60 | 
 61 | impl From<String> for Host {
 62 |     fn from(from: String) -> Self {
 63 |         from.as_str().into()
 64 |     }
 65 | }
 66 | 
 67 | impl From<&str> for Host {
 68 |     fn from(from: &str) -> Self {
 69 |         match from.parse::<IpAddr>() {
 70 |             Ok(ip_addr) => Host::IpAddr(ip_addr),
 71 |             Err(_) => Host::Domain(from.into()),
 72 |         }
 73 |     }
 74 | }
 75 | 
 76 | impl From<IpAddr> for Host {
 77 |     fn from(from: IpAddr) -> Self {
 78 |         Host::IpAddr(from)
 79 |     }
 80 | }
 81 | 
 82 | impl From<Domain> for Host {
 83 |     fn from(from: Domain) -> Self {
 84 |         Host::Domain(from)
 85 |     }
 86 | }
 87 | 
 88 | impl TryInto<IpAddr> for Host {
 89 |     type Error = Error;
 90 | 
 91 |     fn try_into(self) -> Result<IpAddr, Error> {
 92 |         match self {
 93 |             Self::Domain(_) => Err(Error::Unexpected("cannot convert Host to IpAddr".into())),
 94 |             Self::IpAddr(ip_addr) => Ok(ip_addr),
 95 |         }
 96 |     }
 97 | }
 98 | 
 99 | impl TryInto<SocketAddr> for Host {
100 |     type Error = Error;
101 | 
102 |     fn try_into(self) -> Result<SocketAddr, Error> {
103 |         let ip_addr: IpAddr = self.try_into()?;
104 |         Ok(SocketAddr::new(ip_addr, 5060))
105 |     }
106 | }
107 | 
108 | #[cfg(feature = "test-utils")]
109 | impl testing_utils::Randomize for Domain {
110 |     fn random() -> Self {
111 |         Domain(format!(
112 |             "{}.{}",
113 |             String::random(),
114 |             testing_utils::rand_str_of(3)
115 |         ))
116 |     }
117 | }
118 | 
119 | #[cfg(feature = "test-utils")]
120 | impl testing_utils::Randomize for Host {
121 |     fn random() -> Self {
122 |         use testing_utils::sample;
123 | 
124 |         sample(&[
125 |             Host::Domain(Domain::random()),
126 |             Host::IpAddr(IpAddr::random()),
127 |         ])
128 |     }
129 | }
130 | 


--------------------------------------------------------------------------------
/src/common/uri/host_with_port/port.rs:
--------------------------------------------------------------------------------
 1 | use rsip_derives::NewType;
 2 | 
 3 | /// A simple NewType around u16, as part of the [HostWithPort](super::HostWithPort).
 4 | #[derive(NewType, Debug, PartialEq, Eq, Clone, Copy)]
 5 | pub struct Port(u16);
 6 | 
 7 | impl Default for Port {
 8 |     fn default() -> Self {
 9 |         Self(5060)
10 |     }
11 | }
12 | 
13 | impl std::convert::TryFrom<String> for Port {
14 |     type Error = crate::Error;
15 | 
16 |     fn try_from(from: String) -> Result<Self, Self::Error> {
17 |         use std::convert::TryInto;
18 | 
19 |         from.as_str().try_into()
20 |     }
21 | }
22 | 
23 | impl std::convert::TryFrom<&str> for Port {
24 |     type Error = crate::Error;
25 | 
26 |     fn try_from(from: &str) -> Result<Self, Self::Error> {
27 |         Ok(from.parse::<u16>()?.into())
28 |     }
29 | }
30 | 
31 | #[cfg(feature = "test-utils")]
32 | impl testing_utils::Randomize for Port {
33 |     fn random() -> Self {
34 |         Self(testing_utils::rand_num_from(1001..50000))
35 |     }
36 | }
37 | 


--------------------------------------------------------------------------------
/src/common/uri/param/branch.rs:
--------------------------------------------------------------------------------
 1 | use rsip_derives::{IntoParam, NewType};
 2 | 
 3 | /// Simple NewType around String. Intended to be used for the `branch` parameter found in the `Via`
 4 | /// header.
 5 | ///
 6 | /// Provides a simple default implementation that uses a `Uuid` for genearting a unique branch
 7 | /// across space & time.
 8 | #[derive(NewType, IntoParam, Debug, PartialEq, Eq, Clone, Ord, PartialOrd, Hash)]
 9 | pub struct Branch(String);
10 | 
11 | impl<'a> Default for Branch {
12 |     fn default() -> Self {
13 |         use uuid::Uuid;
14 |         Self::new(format!("z9hG4bK-rsip-{}", Uuid::new_v4()))
15 |     }
16 | }
17 | 
18 | #[cfg(feature = "test-utils")]
19 | impl testing_utils::Randomize for Branch {
20 |     fn random() -> Self {
21 |         Self::default()
22 |     }
23 | }
24 | 


--------------------------------------------------------------------------------
/src/common/uri/param/expires.rs:
--------------------------------------------------------------------------------
 1 | use rsip_derives::{IntoParam, NewType};
 2 | 
 3 | /// Simple NewType around String. Intended to be used for the `expires` parameter found in the
 4 | /// `Contact` header.
 5 | //TODO: add typed + default
 6 | #[derive(NewType, IntoParam, Debug, PartialEq, Eq, Clone)]
 7 | pub struct Expires(String);
 8 | 
 9 | impl Expires {
10 |     pub fn seconds(&self) -> Result<u32, crate::Error> {
11 |         Ok(self.value().parse::<u32>()?)
12 |     }
13 | }
14 | 
15 | #[cfg(feature = "test-utils")]
16 | impl testing_utils::Randomize for Expires {
17 |     fn random() -> Self {
18 |         Self(testing_utils::rand_num_from(0..10000).to_string())
19 |     }
20 | }
21 | 


--------------------------------------------------------------------------------
/src/common/uri/param/maddr.rs:
--------------------------------------------------------------------------------
 1 | use rsip_derives::{IntoParam, NewType};
 2 | 
 3 | /// Simple NewType around String. Intended to be used for the `maddr` parameter found in the
 4 | /// `Via` header.
 5 | #[derive(NewType, IntoParam, Debug, PartialEq, Eq, Clone)]
 6 | pub struct Maddr(String);
 7 | 
 8 | #[cfg(feature = "test-utils")]
 9 | impl testing_utils::Randomize for Maddr {
10 |     fn random() -> Self {
11 |         Self(std::net::IpAddr::random().to_string())
12 |     }
13 | }
14 | 


--------------------------------------------------------------------------------
/src/common/uri/param/q.rs:
--------------------------------------------------------------------------------
 1 | use rsip_derives::{IntoParam, NewType};
 2 | 
 3 | /// Simple NewType around String. Intended to be used for the `q` parameter found in the `Contact`
 4 | /// header.
 5 | //TODO: add typed + default
 6 | #[derive(NewType, IntoParam, Debug, PartialEq, Eq, Clone)]
 7 | pub struct Q(String);
 8 | 
 9 | #[cfg(feature = "test-utils")]
10 | impl testing_utils::Randomize for Q {
11 |     fn random() -> Self {
12 |         Self(format!("0.{}", testing_utils::rand_num_from(1..=9)))
13 |     }
14 | }
15 | 


--------------------------------------------------------------------------------
/src/common/uri/param/received.rs:
--------------------------------------------------------------------------------
 1 | use rsip_derives::{IntoParam, NewType};
 2 | use std::net::IpAddr;
 3 | 
 4 | /// Simple NewType around String. Intended to be used for the `received` parameter found in the `Via`
 5 | /// header.
 6 | #[derive(NewType, IntoParam, Debug, PartialEq, Eq, Clone)]
 7 | pub struct Received(String);
 8 | 
 9 | impl Received {
10 |     pub fn parse(&self) -> Result<IpAddr, std::net::AddrParseError> {
11 |         self.0.parse()
12 |     }
13 | }
14 | 
15 | #[cfg(feature = "test-utils")]
16 | impl testing_utils::Randomize for Received {
17 |     fn random() -> Self {
18 |         Self(std::net::IpAddr::random().to_string())
19 |     }
20 | }
21 | 


--------------------------------------------------------------------------------
/src/common/uri/param/tag.rs:
--------------------------------------------------------------------------------
 1 | use rsip_derives::{IntoParam, NewType};
 2 | 
 3 | /// Simple NewType around String. Intended to be used for the `tag` parameter found in the `From`
 4 | /// and `To` headers.
 5 | #[derive(NewType, IntoParam, Debug, PartialEq, Eq, Clone)]
 6 | pub struct Tag(String);
 7 | 
 8 | impl<'a> Default for Tag {
 9 |     fn default() -> Self {
10 |         use uuid::Uuid;
11 |         Self::new(format!("viska-{}", Uuid::new_v4()))
12 |     }
13 | }
14 | 
15 | #[cfg(feature = "test-utils")]
16 | impl testing_utils::Randomize for Tag {
17 |     fn random() -> Self {
18 |         Self::default()
19 |     }
20 | }
21 | 


--------------------------------------------------------------------------------
/src/common/uri/param/ttl.rs:
--------------------------------------------------------------------------------
 1 | use rsip_derives::{IntoParam, NewType};
 2 | 
 3 | /// Simple NewType around String. Intended to be used for the `ttl` parameter found in the
 4 | /// SIP(S) uris and in `Via` header.
 5 | #[derive(NewType, IntoParam, Debug, PartialEq, Eq, Clone)]
 6 | pub struct Ttl(String);
 7 | 
 8 | #[cfg(feature = "test-utils")]
 9 | impl testing_utils::Randomize for Ttl {
10 |     fn random() -> Self {
11 |         Self(testing_utils::rand_num_from(1..=100).to_string())
12 |     }
13 | }
14 | 


--------------------------------------------------------------------------------
/src/common/uri/param/user.rs:
--------------------------------------------------------------------------------
 1 | use rsip_derives::{IntoParam, NewType};
 2 | 
 3 | /// Simple NewType around String. Intended to be used for the `user` parameter found in SIP(S)
 4 | /// uris, rarely used nowardays.
 5 | #[derive(NewType, IntoParam, Debug, PartialEq, Eq, Clone)]
 6 | pub struct User(String);
 7 | 
 8 | #[cfg(feature = "test-utils")]
 9 | impl testing_utils::Randomize for User {
10 |     fn random() -> Self {
11 |         Self(testing_utils::sample(&["phone", "ip", &testing_utils::rand_str_of(5)]).to_string())
12 |     }
13 | }
14 | 


--------------------------------------------------------------------------------
/src/common/version.rs:
--------------------------------------------------------------------------------
  1 | use crate::Error;
  2 | #[doc(hidden)]
  3 | pub use tokenizer::Tokenizer;
  4 | 
  5 | use std::convert::{TryFrom, TryInto};
  6 | 
  7 | /// Simple enum that holds the SIP version. Defaults to `Version::V2`.
  8 | #[derive(Debug, PartialEq, Eq, Clone)]
  9 | pub enum Version {
 10 |     V1,
 11 |     V2,
 12 |     //Custom(String)
 13 | }
 14 | 
 15 | impl Default for Version {
 16 |     fn default() -> Self {
 17 |         Self::V2
 18 |     }
 19 | }
 20 | 
 21 | impl<'a> TryFrom<&'a [u8]> for Version {
 22 |     type Error = crate::Error;
 23 | 
 24 |     fn try_from(from: &'a [u8]) -> Result<Self, Self::Error> {
 25 |         Tokenizer::tokenize(from)?.1.try_into()
 26 |     }
 27 | }
 28 | 
 29 | impl std::fmt::Display for Version {
 30 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
 31 |         match self {
 32 |             Self::V1 => write!(f, "SIP/1.0"),
 33 |             Self::V2 => write!(f, "SIP/2.0"),
 34 |         }
 35 |     }
 36 | }
 37 | 
 38 | impl<'a> std::convert::TryFrom<tokenizer::Tokenizer<'a, &'a str, char>> for Version {
 39 |     type Error = Error;
 40 | 
 41 |     fn try_from(tokenizer: tokenizer::Tokenizer<'a, &'a str, char>) -> Result<Self, Self::Error> {
 42 |         match tokenizer.major {
 43 |             "1" => Ok(Version::V1),
 44 |             "2" => Ok(Version::V2),
 45 |             _ => Err(Self::Error::ParseError("Unrecognized SIP version".into())),
 46 |         }
 47 |     }
 48 | }
 49 | 
 50 | impl<'a> std::convert::TryFrom<tokenizer::Tokenizer<'a, &'a [u8], u8>> for Version {
 51 |     type Error = Error;
 52 | 
 53 |     fn try_from(tokenizer: tokenizer::Tokenizer<'a, &'a [u8], u8>) -> Result<Self, Self::Error> {
 54 |         match tokenizer.major {
 55 |             b"1" => Ok(Version::V1),
 56 |             b"2" => Ok(Version::V2),
 57 |             _ => Err(Self::Error::ParseError("Unrecognized SIP version".into())),
 58 |         }
 59 |     }
 60 | }
 61 | 
 62 | #[doc(hidden)]
 63 | mod tokenizer {
 64 |     use crate::{AbstractInput, AbstractInputItem, GResult, GenericNomError, TokenizerError};
 65 |     use std::marker::PhantomData;
 66 | 
 67 |     #[derive(Debug, PartialEq, Eq, Clone)]
 68 |     pub struct Tokenizer<'a, T, I>
 69 |     where
 70 |         T: AbstractInput<'a, I>,
 71 |         I: AbstractInputItem<I>,
 72 |     {
 73 |         pub major: T,
 74 |         pub minor: T,
 75 |         phantom1: PhantomData<&'a T>,
 76 |         phantom2: PhantomData<I>,
 77 |     }
 78 | 
 79 |     impl<'a, T, I> From<(T, T)> for Tokenizer<'a, T, I>
 80 |     where
 81 |         T: AbstractInput<'a, I>,
 82 |         I: AbstractInputItem<I>,
 83 |     {
 84 |         fn from(from: (T, T)) -> Self {
 85 |             Self {
 86 |                 major: from.0,
 87 |                 minor: from.1,
 88 |                 phantom1: PhantomData,
 89 |                 phantom2: PhantomData,
 90 |             }
 91 |         }
 92 |     }
 93 | 
 94 |     impl<'a, T, I> Tokenizer<'a, T, I>
 95 |     where
 96 |         T: AbstractInput<'a, I>,
 97 |         I: AbstractInputItem<I>,
 98 |     {
 99 |         pub fn tokenize(part: T) -> GResult<T, Self> {
100 |             use nom::{bytes::complete::tag, character::complete::digit1, sequence::tuple};
101 | 
102 |             let (rem, (_, major, _, minor)) = tuple((tag("SIP/"), digit1, tag("."), digit1))(part)
103 |                 .map_err(|_: GenericNomError<'a, T>| {
104 |                     TokenizerError::from(("version", part)).into()
105 |                 })?;
106 | 
107 |             Ok((rem, (major, minor).into()))
108 |         }
109 |     }
110 | }
111 | 
112 | #[cfg(feature = "test-utils")]
113 | impl testing_utils::Randomize for Version {
114 |     fn random() -> Self {
115 |         //is anyone using V1 ?!
116 |         Self::V2
117 |     }
118 | }
119 | 


--------------------------------------------------------------------------------
/src/error/tokenizer_error.rs:
--------------------------------------------------------------------------------
 1 | use std::{error::Error as StdError, fmt};
 2 | 
 3 | #[derive(Debug, Eq, PartialEq, Clone)]
 4 | pub struct TokenizerError {
 5 |     pub context: String,
 6 | }
 7 | 
 8 | impl<'a, S, T> From<(S, T)> for TokenizerError
 9 | where
10 |     S: Into<String>,
11 |     T: Into<&'a bstr::BStr>,
12 | {
13 |     fn from(from: (S, T)) -> Self {
14 |         Self {
15 |             context: format!("failed to tokenize {}: {}", from.0.into(), from.1.into()),
16 |         }
17 |     }
18 | }
19 | 
20 | impl From<&'static str> for TokenizerError {
21 |     fn from(from: &'static str) -> Self {
22 |         Self {
23 |             context: from.into(),
24 |         }
25 |     }
26 | }
27 | 
28 | #[allow(clippy::from_over_into)]
29 | impl Into<nom::Err<Self>> for TokenizerError {
30 |     fn into(self) -> nom::Err<Self> {
31 |         nom::Err::Error(self)
32 |     }
33 | }
34 | 
35 | #[allow(clippy::from_over_into)]
36 | impl<'a, T> Into<crate::IResult<'a, T>> for TokenizerError {
37 |     fn into(self) -> crate::IResult<'a, T> {
38 |         Err(nom::Err::Error(self))
39 |     }
40 | }
41 | 
42 | impl fmt::Display for TokenizerError {
43 |     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
44 |         write!(f, "Tokenizer error: {}", self.context)
45 |     }
46 | }
47 | 
48 | impl StdError for TokenizerError {}
49 | 
50 | impl<'a, T: Into<&'a bstr::BStr>> nom::error::ParseError<T> for TokenizerError {
51 |     fn from_error_kind(input: T, kind: nom::error::ErrorKind) -> Self {
52 |         Self {
53 |             context: format!("could not tokenize ({:?}): {}", kind, input.into()),
54 |         }
55 |     }
56 |     fn append(input: T, kind: nom::error::ErrorKind, other: Self) -> Self {
57 |         Self {
58 |             context: format!(
59 |                 "{}. Also, could not tokenize ({:?}): {}",
60 |                 other,
61 |                 kind,
62 |                 input.into(),
63 |             ),
64 |         }
65 |     }
66 | 
67 |     fn from_char(input: T, c: char) -> Self {
68 |         Self {
69 |             context: format!("was expecting char {} in: {}", c, input.into()),
70 |         }
71 |     }
72 | 
73 |     fn or(self, other: Self) -> Self {
74 |         Self {
75 |             context: format!("tokenizer error: {} or {}", self, other.context),
76 |         }
77 |     }
78 | }
79 | 


--------------------------------------------------------------------------------
/src/headers/auth/algorithm.rs:
--------------------------------------------------------------------------------
 1 | /// The `Algorithm`, as part of the SIP Authorization framework, found in headers like
 2 | /// [Authorization](super::super::typed::Authorization) and
 3 | /// [WwwAuthenticate](super::super::typed::WwwAuthenticate)
 4 | #[derive(Debug, PartialEq, Eq, Clone, Copy)]
 5 | pub enum Algorithm {
 6 |     Md5,
 7 |     Md5Sess,
 8 |     Sha256,
 9 |     Sha256Sess,
10 |     Sha512,
11 |     Sha512Sess,
12 | }
13 | 
14 | impl Default for Algorithm {
15 |     fn default() -> Self {
16 |         Self::Sha256
17 |     }
18 | }
19 | 
20 | impl std::fmt::Display for Algorithm {
21 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
22 |         match self {
23 |             Self::Md5 => write!(f, "MD5"),
24 |             Self::Md5Sess => write!(f, "MD5-sess"),
25 |             Self::Sha256 => write!(f, "SHA256"),
26 |             Self::Sha256Sess => write!(f, "SHA256-sess"),
27 |             Self::Sha512 => write!(f, "SHA512"),
28 |             Self::Sha512Sess => write!(f, "SHA512-sess"),
29 |         }
30 |     }
31 | }
32 | 
33 | impl std::str::FromStr for Algorithm {
34 |     type Err = crate::Error;
35 | 
36 |     fn from_str(s: &str) -> Result<Self, Self::Err> {
37 |         use std::convert::TryInto;
38 | 
39 |         s.try_into()
40 |     }
41 | }
42 | 
43 | impl std::convert::TryFrom<&str> for Algorithm {
44 |     type Error = crate::Error;
45 | 
46 |     fn try_from(s: &str) -> Result<Self, Self::Error> {
47 |         match s {
48 |             s if s.eq_ignore_ascii_case("md5") => Ok(Self::Md5),
49 |             s if s.eq_ignore_ascii_case("md5-sess") => Ok(Self::Md5Sess),
50 |             s if s.eq_ignore_ascii_case("sha256") => Ok(Self::Sha256),
51 |             s if s.eq_ignore_ascii_case("sha256-sess") => Ok(Self::Sha256Sess),
52 |             s if s.eq_ignore_ascii_case("sha512") => Ok(Self::Sha512),
53 |             s if s.eq_ignore_ascii_case("sha512-sess") => Ok(Self::Sha512Sess),
54 |             s => Err(crate::Error::ParseError(format!(
55 |                 "invalid Algorithm `{}`",
56 |                 s
57 |             ))),
58 |         }
59 |     }
60 | }
61 | 


--------------------------------------------------------------------------------
/src/headers/auth/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod algorithm;
2 | pub mod qop;
3 | pub mod scheme;
4 | 
5 | pub use algorithm::Algorithm;
6 | pub use qop::{AuthQop, Qop};
7 | pub use scheme::Scheme;
8 | 


--------------------------------------------------------------------------------
/src/headers/auth/qop.rs:
--------------------------------------------------------------------------------
 1 | /// The `Algorithm`, as part of the SIP Authorization framework, found in headers like
 2 | /// [Authorization](super::super::typed::Authorization) and
 3 | /// [WwwAuthenticate](super::super::typed::WwwAuthenticate)
 4 | #[derive(Debug, PartialEq, Eq, Clone)]
 5 | pub enum Qop {
 6 |     Auth,
 7 |     AuthInt,
 8 | }
 9 | 
10 | impl std::fmt::Display for Qop {
11 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
12 |         match self {
13 |             Self::Auth => write!(f, "auth"),
14 |             Self::AuthInt => write!(f, "auth-int"),
15 |         }
16 |     }
17 | }
18 | 
19 | impl std::str::FromStr for Qop {
20 |     type Err = crate::Error;
21 | 
22 |     fn from_str(s: &str) -> Result<Self, Self::Err> {
23 |         use std::convert::TryInto;
24 | 
25 |         s.try_into()
26 |     }
27 | }
28 | 
29 | impl std::convert::TryFrom<&str> for Qop {
30 |     type Error = crate::Error;
31 | 
32 |     fn try_from(s: &str) -> Result<Self, Self::Error> {
33 |         match s {
34 |             s if s.eq_ignore_ascii_case("auth") => Ok(Self::Auth),
35 |             s if s.eq_ignore_ascii_case("auth-int") => Ok(Self::AuthInt),
36 |             s => Err(crate::Error::ParseError(format!("invalid Qop `{}`", s))),
37 |         }
38 |     }
39 | }
40 | 
41 | #[derive(Debug, PartialEq, Eq, Clone)]
42 | pub enum AuthQop {
43 |     Auth { cnonce: String, nc: u8 },
44 |     AuthInt { cnonce: String, nc: u8 },
45 | }
46 | 
47 | impl std::fmt::Display for AuthQop {
48 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
49 |         match self {
50 |             Self::Auth { cnonce, nc } => {
51 |                 write!(f, "qop=\"auth\", nc={:08}, cnonce=\"{}\"", nc, cnonce)
52 |             }
53 |             Self::AuthInt { cnonce, nc } => {
54 |                 write!(f, "qop=\"auth-int\", nc={:08}, cnonce=\"{}\"", nc, cnonce)
55 |             }
56 |         }
57 |     }
58 | }
59 | 


--------------------------------------------------------------------------------
/src/headers/auth/scheme.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use tokenizer::Tokenizer;
 3 | 
 4 | /// The `Scheme`, as part of the SIP Authorization framework, found in headers like
 5 | /// [Authorization](super::super::typed::Authorization) and
 6 | /// [WwwAuthenticate](super::super::typed::WwwAuthenticate)
 7 | #[derive(Debug, PartialEq, Eq, Clone)]
 8 | pub enum Scheme {
 9 |     Digest,
10 |     Other(String),
11 | }
12 | 
13 | impl Default for Scheme {
14 |     fn default() -> Self {
15 |         Self::Digest
16 |     }
17 | }
18 | 
19 | impl std::fmt::Display for Scheme {
20 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
21 |         match self {
22 |             Self::Digest => write!(f, "Digest"),
23 |             Self::Other(inner) => write!(f, "{}", inner),
24 |         }
25 |     }
26 | }
27 | 
28 | impl<'a> std::convert::TryFrom<Tokenizer<'a, &'a [u8], u8>> for Scheme {
29 |     type Error = crate::Error;
30 | 
31 |     fn try_from(tokenizer: Tokenizer<'a, &'a [u8], u8>) -> Result<Self, Self::Error> {
32 |         use std::str::from_utf8;
33 | 
34 |         match from_utf8(tokenizer.value)? {
35 |             part if part.eq_ignore_ascii_case("digest") => Ok(Self::Digest),
36 |             part => Ok(Self::Other(part.into())),
37 |         }
38 |     }
39 | }
40 | 
41 | impl<'a> std::convert::TryFrom<Tokenizer<'a, &'a str, char>> for Scheme {
42 |     type Error = crate::Error;
43 | 
44 |     fn try_from(tokenizer: Tokenizer<'a, &'a str, char>) -> Result<Self, Self::Error> {
45 |         match tokenizer.value {
46 |             part if part.eq_ignore_ascii_case("digest") => Ok(Self::Digest),
47 |             part => Ok(Self::Other(part.into())),
48 |         }
49 |     }
50 | }
51 | 
52 | #[doc(hidden)]
53 | mod tokenizer {
54 |     use crate::{AbstractInput, GResult, GenericNomError, TokenizerError};
55 |     use std::marker::PhantomData;
56 | 
57 |     #[derive(Debug, PartialEq, Eq, Clone)]
58 |     pub struct Tokenizer<'a, T, I>
59 |     where
60 |         T: AbstractInput<'a, I>,
61 |         I: nom::AsChar,
62 |     {
63 |         pub value: T,
64 |         phantom1: PhantomData<&'a T>,
65 |         phantom2: PhantomData<I>,
66 |     }
67 | 
68 |     impl<'a, T, I> From<T> for Tokenizer<'a, T, I>
69 |     where
70 |         T: AbstractInput<'a, I>,
71 |         I: nom::AsChar,
72 |     {
73 |         fn from(value: T) -> Self {
74 |             Self {
75 |                 value,
76 |                 phantom1: PhantomData,
77 |                 phantom2: PhantomData,
78 |             }
79 |         }
80 |     }
81 | 
82 |     impl<'a, T, I> Tokenizer<'a, T, I>
83 |     where
84 |         T: AbstractInput<'a, I>,
85 |         I: nom::AsChar,
86 |     {
87 |         pub fn tokenize(part: T) -> GResult<T, Self> {
88 |             use nom::{branch::alt, bytes::complete::take_until, combinator::rest};
89 | 
90 |             let (rem, scheme) =
91 |                 alt((take_until(" "), rest))(part).map_err(|_: GenericNomError<'a, T>| {
92 |                     TokenizerError::from(("scheme (header)", part)).into()
93 |                 })?;
94 | 
95 |             Ok((rem, Self::from(scheme)))
96 |         }
97 |     }
98 | }
99 | 


--------------------------------------------------------------------------------
/src/headers/mod.rs:
--------------------------------------------------------------------------------
 1 | pub mod auth;
 2 | pub mod header;
 3 | pub mod typed;
 4 | pub mod untyped;
 5 | pub use header::Header;
 6 | pub use untyped::*;
 7 | 
 8 | /// Simple NewType around `Vec<Header>` that gives many helpful methods when dealing with headers
 9 | /// in [super::Request], [super::Response] and [super::SipMessage].
10 | #[derive(Debug, PartialEq, Eq, Clone, Default)]
11 | pub struct Headers(Vec<Header>);
12 | 
13 | impl Headers {
14 |     pub fn push(&mut self, h: Header) {
15 |         self.0.push(h)
16 |     }
17 | 
18 |     pub fn unique_push(&mut self, h: Header) {
19 |         self.0
20 |             .retain(|s| std::mem::discriminant(s) != std::mem::discriminant(&h));
21 |         self.push(h);
22 |     }
23 | 
24 |     pub fn iter(&self) -> impl Iterator<Item = &Header> {
25 |         self.0.iter()
26 |     }
27 | 
28 |     pub fn extend(&mut self, i: Vec<Header>) {
29 |         self.0.extend(i)
30 |     }
31 | 
32 |     pub fn iter_mut(&mut self) -> impl Iterator<Item = &mut Header> {
33 |         self.0.iter_mut()
34 |     }
35 | 
36 |     pub fn is_empty(&self) -> bool {
37 |         self.0.is_empty()
38 |     }
39 | 
40 |     pub fn retain<F>(&mut self, f: F)
41 |     where
42 |         F: FnMut(&Header) -> bool,
43 |     {
44 |         self.0.retain(f)
45 |     }
46 | }
47 | 
48 | impl IntoIterator for Headers {
49 |     type IntoIter = ::std::vec::IntoIter<Self::Item>;
50 |     type Item = Header;
51 | 
52 |     fn into_iter(self) -> Self::IntoIter {
53 |         self.0.into_iter()
54 |     }
55 | }
56 | 
57 | impl std::convert::From<Header> for Headers {
58 |     fn from(header: Header) -> Self {
59 |         Self(vec![header])
60 |     }
61 | }
62 | 
63 | impl std::convert::From<Vec<Header>> for Headers {
64 |     fn from(headers: Vec<Header>) -> Self {
65 |         Self(headers)
66 |     }
67 | }
68 | 
69 | impl std::convert::From<Headers> for Vec<Header> {
70 |     fn from(from: Headers) -> Self {
71 |         from.0
72 |     }
73 | }
74 | 
75 | impl std::fmt::Display for Headers {
76 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
77 |         if self.is_empty() {
78 |             write!(f, "")
79 |         } else {
80 |             write!(
81 |                 f,
82 |                 "{}\r\n",
83 |                 self.iter()
84 |                     .map(|s| s.to_string())
85 |                     .collect::<Vec<_>>()
86 |                     .join("\r\n")
87 |             )
88 |         }
89 |     }
90 | }
91 | 


--------------------------------------------------------------------------------
/src/headers/typed/accept.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::NameParamsListTokenizer as Tokenizer;
 3 | 
 4 | use super::MediaType;
 5 | use crate::Error;
 6 | use rsip_derives::TypedHeader;
 7 | use std::convert::TryFrom;
 8 | 
 9 | /// The `Accept` header in its [typed](super) form.
10 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug)]
11 | pub struct Accept(pub Vec<MediaType>);
12 | 
13 | impl From<Vec<MediaType>> for Accept {
14 |     fn from(media_types: Vec<MediaType>) -> Self {
15 |         Self(media_types)
16 |     }
17 | }
18 | 
19 | impl<'a> TryFrom<Tokenizer<'a>> for Accept {
20 |     type Error = crate::Error;
21 | 
22 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
23 |         let media_types = tokenizer
24 |             .0
25 |             .into_iter()
26 |             .map(MediaType::try_from)
27 |             .collect::<Result<Vec<MediaType>, Error>>()?;
28 |         Ok(Self(media_types))
29 |     }
30 | }
31 | 
32 | impl std::fmt::Display for Accept {
33 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
34 |         write!(
35 |             f,
36 |             "{}",
37 |             self.0
38 |                 .iter()
39 |                 .map(|m| m.to_string())
40 |                 .collect::<Vec<String>>()
41 |                 .join(", ")
42 |         )
43 |     }
44 | }
45 | 


--------------------------------------------------------------------------------
/src/headers/typed/alert_info.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::UriWithParamsListTokenizer as Tokenizer;
 3 | 
 4 | use crate::common::uri::{UriWithParams, UriWithParamsList};
 5 | use rsip_derives::TypedHeader;
 6 | use std::convert::TryFrom;
 7 | 
 8 | /// The `Alert-Info` header in its [typed](super) form.
 9 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug)]
10 | pub struct AlertInfo(pub UriWithParamsList);
11 | 
12 | impl AlertInfo {
13 |     pub fn uris(&self) -> &[UriWithParams] {
14 |         self.0.uris()
15 |     }
16 | }
17 | 
18 | impl From<UriWithParamsList> for AlertInfo {
19 |     fn from(uri_with_params_list: UriWithParamsList) -> Self {
20 |         Self(uri_with_params_list)
21 |     }
22 | }
23 | 
24 | impl<'a> TryFrom<Tokenizer<'a>> for AlertInfo {
25 |     type Error = crate::Error;
26 | 
27 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
28 |         Ok(Self(UriWithParamsList::try_from(tokenizer)?))
29 |     }
30 | }
31 | 
32 | impl std::fmt::Display for AlertInfo {
33 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
34 |         write!(f, "{}", self.0)
35 |     }
36 | }
37 | 


--------------------------------------------------------------------------------
/src/headers/typed/allow.rs:
--------------------------------------------------------------------------------
 1 | use crate::{common::Method, Error};
 2 | use rsip_derives::TypedHeader;
 3 | use std::convert::TryFrom;
 4 | 
 5 | #[doc(hidden)]
 6 | pub use super::tokenizers::TokenListTokenizer as Tokenizer;
 7 | 
 8 | /// The `Allow` header in its [typed](super) form.
 9 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug)]
10 | pub struct Allow(pub Vec<Method>);
11 | 
12 | impl From<Vec<Method>> for Allow {
13 |     fn from(methods: Vec<Method>) -> Self {
14 |         Self(methods)
15 |     }
16 | }
17 | 
18 | impl<'a> TryFrom<Tokenizer<'a>> for Allow {
19 |     type Error = Error;
20 | 
21 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
22 |         use std::str::FromStr;
23 | 
24 |         let methods = tokenizer
25 |             .tokens
26 |             .into_iter()
27 |             .map(Method::from_str)
28 |             .collect::<Result<Vec<Method>, Error>>()?;
29 |         Ok(Self(methods))
30 |     }
31 | }
32 | 
33 | impl std::fmt::Display for Allow {
34 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
35 |         write!(
36 |             f,
37 |             "{}",
38 |             self.0
39 |                 .iter()
40 |                 .map(|m| m.to_string())
41 |                 .collect::<Vec<String>>()
42 |                 .join(", ")
43 |         )
44 |     }
45 | }
46 | 


--------------------------------------------------------------------------------
/src/headers/typed/authentication_info.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::NameValueTokenizer as Tokenizer;
 3 | 
 4 | use crate::{headers::auth::AuthQop, Error};
 5 | use rsip_derives::TypedHeader;
 6 | use std::convert::TryFrom;
 7 | 
 8 | /// The `Authentication-Info` header in its [typed](super) form.
 9 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug)]
10 | pub struct AuthenticationInfo {
11 |     pub nextnonce: String,
12 |     pub qop: Option<AuthQop>,
13 |     pub rspauth: Option<String>,
14 | }
15 | 
16 | impl<'a> TryFrom<Tokenizer<'a>> for AuthenticationInfo {
17 |     type Error = crate::Error;
18 | 
19 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
20 |         Ok(AuthenticationInfo {
21 |             nextnonce: find_param(&tokenizer.params, "nextnonce")
22 |                 .ok_or_else(|| Error::InvalidParam("missing nextnonce".into()))?
23 |                 .into(),
24 |             qop: find_qop(&tokenizer.params)?,
25 |             rspauth: find_param(&tokenizer.params, "rspauth").map(Into::into),
26 |         })
27 |     }
28 | }
29 | 
30 | impl std::fmt::Display for AuthenticationInfo {
31 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
32 |         write!(f, "nextnonce=\"{}\"", self.nextnonce)?;
33 | 
34 |         if let Some(rspauth) = &self.rspauth {
35 |             write!(f, ", rspauth=\"{}\"", rspauth)?;
36 |         }
37 | 
38 |         if let Some(qop) = &self.qop {
39 |             write!(f, ", {}", qop)?;
40 |         }
41 | 
42 |         Ok(())
43 |     }
44 | }
45 | 
46 | //TODO: Move to common trait and impl on relevant tokenizers
47 | fn find_param<'a>(params: &[(&'a str, &'a str)], name: &str) -> Option<&'a str> {
48 |     params.iter().find_map(|(key, value)| {
49 |         if key.eq_ignore_ascii_case(name) {
50 |             Some(*value)
51 |         } else {
52 |             None
53 |         }
54 |     })
55 | }
56 | 
57 | fn find_qop<'a>(params: &[(&'a str, &'a str)]) -> Result<Option<AuthQop>, Error> {
58 |     Ok(match find_param(params, "qop") {
59 |         Some(qop) if qop.eq_ignore_ascii_case("auth") => Some(AuthQop::Auth {
60 |             cnonce: find_param(params, "cnonce")
61 |                 .ok_or_else(|| Error::InvalidParam("Found qop, but missing cnonce".into()))?
62 |                 .into(),
63 |             nc: find_param(params, "nc")
64 |                 .ok_or_else(|| Error::InvalidParam("Found qop, but missing nc".into()))?
65 |                 .parse::<u8>()?,
66 |         }),
67 |         Some(qop) if qop.eq_ignore_ascii_case("auth-int") => Some(AuthQop::AuthInt {
68 |             cnonce: find_param(params, "cnonce")
69 |                 .ok_or_else(|| Error::InvalidParam("Found qop, but missing cnonce".into()))?
70 |                 .into(),
71 |             nc: find_param(params, "nc")
72 |                 .ok_or_else(|| Error::InvalidParam("Found qop, but missing nc".into()))?
73 |                 .parse::<u8>()?,
74 |         }),
75 |         Some(qop) => return Err(Error::InvalidParam(format!("Found unknown qop: {}", qop))),
76 |         None => None,
77 |     })
78 | }
79 | 


--------------------------------------------------------------------------------
/src/headers/typed/call_info.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::UriWithParamsListTokenizer as Tokenizer;
 3 | 
 4 | use crate::common::uri::{UriWithParams, UriWithParamsList};
 5 | use rsip_derives::TypedHeader;
 6 | use std::convert::TryFrom;
 7 | 
 8 | /// The `Call-Info` header in its [typed](super) form.
 9 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug)]
10 | pub struct CallInfo(pub UriWithParamsList);
11 | 
12 | impl CallInfo {
13 |     pub fn uris(&self) -> &[UriWithParams] {
14 |         self.0.uris()
15 |     }
16 | }
17 | 
18 | impl From<UriWithParamsList> for CallInfo {
19 |     fn from(uri_with_params_list: UriWithParamsList) -> Self {
20 |         Self(uri_with_params_list)
21 |     }
22 | }
23 | 
24 | impl<'a> TryFrom<Tokenizer<'a>> for CallInfo {
25 |     type Error = crate::Error;
26 | 
27 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
28 |         Ok(Self(UriWithParamsList::try_from(tokenizer)?))
29 |     }
30 | }
31 | 
32 | impl std::fmt::Display for CallInfo {
33 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
34 |         write!(f, "{}", self.0)
35 |     }
36 | }
37 | 


--------------------------------------------------------------------------------
/src/headers/typed/contact.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::DisplayUriParamsTokenizer as Tokenizer;
 3 | 
 4 | use crate::common::{
 5 |     uri::{param, Param},
 6 |     Uri,
 7 | };
 8 | use rsip_derives::{TypedHeader, UriAndParamsHelpers};
 9 | use std::convert::{TryFrom, TryInto};
10 | 
11 | /// The `Contact` header in its [typed](super) form.
12 | #[derive(TypedHeader, UriAndParamsHelpers, Eq, PartialEq, Clone, Debug)]
13 | pub struct Contact {
14 |     pub display_name: Option<String>,
15 |     pub uri: Uri,
16 |     pub params: Vec<Param>,
17 | }
18 | 
19 | impl Contact {
20 |     pub fn expires(&self) -> Option<&param::Expires> {
21 |         self.params.iter().find_map(|param| match param {
22 |             Param::Expires(expires) => Some(expires),
23 |             _ => None,
24 |         })
25 |     }
26 | }
27 | 
28 | impl<'a> TryFrom<Tokenizer<'a>> for Contact {
29 |     type Error = crate::Error;
30 | 
31 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
32 |         Ok(Contact {
33 |             display_name: tokenizer.display_name.map(Into::into),
34 |             uri: tokenizer.uri.try_into()?,
35 |             params: tokenizer
36 |                 .params
37 |                 .into_iter()
38 |                 .map(TryInto::try_into)
39 |                 .collect::<Result<Vec<_>, _>>()?,
40 |         })
41 |     }
42 | }
43 | 
44 | impl std::fmt::Display for Contact {
45 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
46 |         match &self.display_name {
47 |             Some(display_name) => write!(
48 |                 f,
49 |                 "{} <{}>{}",
50 |                 display_name,
51 |                 self.uri,
52 |                 self.params
53 |                     .iter()
54 |                     .map(|s| s.to_string())
55 |                     .collect::<Vec<_>>()
56 |                     .join("")
57 |             ),
58 |             None => write!(
59 |                 f,
60 |                 "<{}>{}",
61 |                 self.uri,
62 |                 self.params
63 |                     .iter()
64 |                     .map(|s| s.to_string())
65 |                     .collect::<Vec<_>>()
66 |                     .join("")
67 |             ),
68 |         }
69 |     }
70 | }
71 | 
72 | impl std::convert::From<crate::common::Uri> for Contact {
73 |     fn from(uri: crate::common::Uri) -> Self {
74 |         Self {
75 |             display_name: None,
76 |             uri,
77 |             params: Default::default(),
78 |         }
79 |     }
80 | }
81 | 


--------------------------------------------------------------------------------
/src/headers/typed/content_disposition.rs:
--------------------------------------------------------------------------------
  1 | #[doc(hidden)]
  2 | pub use super::tokenizers::NameParamsTokenizer as Tokenizer;
  3 | 
  4 | use rsip_derives::TypedHeader;
  5 | use std::convert::TryFrom;
  6 | 
  7 | /// The `Content-Disposition` header in its [typed](super) form.
  8 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug)]
  9 | pub struct ContentDisposition {
 10 |     pub display_type: DisplayType,
 11 |     pub display_params: Vec<DisplayTypeParam>,
 12 | }
 13 | 
 14 | impl ContentDisposition {
 15 |     pub fn is_session(&self) -> bool {
 16 |         matches!(self.display_type, DisplayType::Session)
 17 |     }
 18 | }
 19 | 
 20 | #[derive(Eq, PartialEq, Clone, Debug)]
 21 | pub enum DisplayType {
 22 |     Render,
 23 |     Session,
 24 |     Icon,
 25 |     Alert,
 26 |     Other(String),
 27 | }
 28 | 
 29 | #[derive(Debug, PartialEq, Eq, Clone)]
 30 | pub struct DisplayTypeParam(pub String, pub String);
 31 | 
 32 | impl<S, T> From<(S, T)> for DisplayTypeParam
 33 | where
 34 |     S: std::fmt::Display,
 35 |     T: std::fmt::Display,
 36 | {
 37 |     fn from(tuple: (S, T)) -> Self {
 38 |         Self(tuple.0.to_string(), tuple.1.to_string())
 39 |     }
 40 | }
 41 | 
 42 | impl<'a> TryFrom<Tokenizer<'a>> for ContentDisposition {
 43 |     type Error = crate::Error;
 44 | 
 45 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
 46 |         let display_type = match tokenizer.name {
 47 |             s if s.eq_ignore_ascii_case("render") => DisplayType::Render,
 48 |             s if s.eq_ignore_ascii_case("session") => DisplayType::Session,
 49 |             s if s.eq_ignore_ascii_case("icon") => DisplayType::Icon,
 50 |             s if s.eq_ignore_ascii_case("alert") => DisplayType::Alert,
 51 |             s => DisplayType::Other(s.into()),
 52 |         };
 53 | 
 54 |         Ok(Self {
 55 |             display_type,
 56 |             display_params: tokenizer
 57 |                 .params
 58 |                 .into_iter()
 59 |                 .map(Into::into)
 60 |                 .collect::<Vec<_>>(),
 61 |         })
 62 |     }
 63 | }
 64 | 
 65 | impl std::fmt::Display for DisplayType {
 66 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
 67 |         match self {
 68 |             Self::Render => write!(f, "render"),
 69 |             Self::Session => write!(f, "session"),
 70 |             Self::Icon => write!(f, "icon"),
 71 |             Self::Alert => write!(f, "alert"),
 72 |             Self::Other(other) => write!(f, "{}", other),
 73 |         }
 74 |     }
 75 | }
 76 | 
 77 | impl std::fmt::Display for DisplayTypeParam {
 78 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
 79 |         write!(f, "{}={}", self.0, self.1)
 80 |     }
 81 | }
 82 | 
 83 | impl std::fmt::Display for ContentDisposition {
 84 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
 85 |         if self.display_params.is_empty() {
 86 |             write!(f, "{}", self.display_type)
 87 |         } else {
 88 |             write!(
 89 |                 f,
 90 |                 "{}; {}",
 91 |                 self.display_type,
 92 |                 self.display_params
 93 |                     .iter()
 94 |                     .map(|param| param.to_string())
 95 |                     .collect::<Vec<String>>()
 96 |                     .join("; ")
 97 |             )
 98 |         }
 99 |     }
100 | }
101 | 


--------------------------------------------------------------------------------
/src/headers/typed/content_type.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::NameParamsTokenizer as Tokenizer;
 3 | 
 4 | use super::MediaType;
 5 | use rsip_derives::TypedHeader;
 6 | use std::convert::TryFrom;
 7 | 
 8 | /// The `ContentType` header in its [typed](super) form.
 9 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug)]
10 | pub struct ContentType(pub MediaType);
11 | 
12 | impl<'a> TryFrom<Tokenizer<'a>> for ContentType {
13 |     type Error = crate::Error;
14 | 
15 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
16 |         MediaType::try_from(tokenizer).map(Self)
17 |     }
18 | }
19 | 
20 | impl std::fmt::Display for ContentType {
21 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
22 |         write!(f, "{}", self.0)
23 |     }
24 | }
25 | 


--------------------------------------------------------------------------------
/src/headers/typed/cseq.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::CseqTokenizer as Tokenizer;
 3 | 
 4 | use crate::common::Method;
 5 | use rsip_derives::TypedHeader;
 6 | use std::convert::TryFrom;
 7 | 
 8 | /// The `CSeq` header in its [typed](super) form.
 9 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug)]
10 | pub struct CSeq {
11 |     pub seq: u32,
12 |     pub method: Method,
13 | }
14 | 
15 | impl From<(u32, Method)> for CSeq {
16 |     fn from(tuple: (u32, Method)) -> Self {
17 |         Self {
18 |             seq: tuple.0,
19 |             method: tuple.1,
20 |         }
21 |     }
22 | }
23 | 
24 | impl<'a> TryFrom<Tokenizer<'a>> for CSeq {
25 |     type Error = crate::Error;
26 | 
27 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
28 |         Ok(CSeq {
29 |             seq: tokenizer.seq.parse::<u32>()?,
30 |             method: tokenizer.method.parse::<Method>()?,
31 |         })
32 |     }
33 | }
34 | 
35 | impl std::fmt::Display for CSeq {
36 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
37 |         write!(f, "{} {}", self.seq, self.method)
38 |     }
39 | }
40 | 


--------------------------------------------------------------------------------
/src/headers/typed/error_info.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::UriWithParamsListTokenizer as Tokenizer;
 3 | 
 4 | use crate::common::uri::{UriWithParams, UriWithParamsList};
 5 | use rsip_derives::TypedHeader;
 6 | use std::convert::TryFrom;
 7 | 
 8 | /// The `Error-Info` header in its [typed](super) form.
 9 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug)]
10 | pub struct ErrorInfo(pub UriWithParamsList);
11 | 
12 | impl ErrorInfo {
13 |     pub fn uris(&self) -> &[UriWithParams] {
14 |         self.0.uris()
15 |     }
16 | }
17 | 
18 | impl From<UriWithParamsList> for ErrorInfo {
19 |     fn from(uri_with_params_list: UriWithParamsList) -> Self {
20 |         Self(uri_with_params_list)
21 |     }
22 | }
23 | 
24 | impl<'a> TryFrom<Tokenizer<'a>> for ErrorInfo {
25 |     type Error = crate::Error;
26 | 
27 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
28 |         Ok(Self(UriWithParamsList::try_from(tokenizer)?))
29 |     }
30 | }
31 | 
32 | impl std::fmt::Display for ErrorInfo {
33 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
34 |         write!(f, "{}", self.0)
35 |     }
36 | }
37 | 


--------------------------------------------------------------------------------
/src/headers/typed/from.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::DisplayUriParamsTokenizer as Tokenizer;
 3 | 
 4 | use crate::common::uri::param::Tag;
 5 | use crate::common::{uri::Param, Uri};
 6 | use rsip_derives::{TypedHeader, UriAndParamsHelpers};
 7 | use std::convert::{TryFrom, TryInto};
 8 | 
 9 | /// The `From` header in its [typed](super) form.
10 | #[derive(TypedHeader, UriAndParamsHelpers, Eq, PartialEq, Clone, Debug)]
11 | pub struct From {
12 |     pub display_name: Option<String>,
13 |     pub uri: Uri,
14 |     pub params: Vec<Param>,
15 | }
16 | 
17 | impl<'a> TryFrom<Tokenizer<'a>> for From {
18 |     type Error = crate::Error;
19 | 
20 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
21 |         Ok(From {
22 |             display_name: tokenizer.display_name.map(Into::into),
23 |             uri: tokenizer.uri.try_into()?,
24 |             params: tokenizer
25 |                 .params
26 |                 .into_iter()
27 |                 .map(TryInto::try_into)
28 |                 .collect::<Result<Vec<_>, _>>()?,
29 |         })
30 |     }
31 | }
32 | 
33 | impl From {
34 |     pub fn tag(&self) -> Option<&Tag> {
35 |         self.params.iter().find_map(|param| match param {
36 |             Param::Tag(tag) => Some(tag),
37 |             _ => None,
38 |         })
39 |     }
40 | 
41 |     pub fn with_tag(mut self, tag: Tag) -> Self {
42 |         self.params
43 |             .retain(|param| !matches!(param, Param::Tag(Tag { .. })));
44 | 
45 |         self.params.push(Tag::new(tag).into());
46 |         self
47 |     }
48 | }
49 | 
50 | impl std::fmt::Display for From {
51 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
52 |         match &self.display_name {
53 |             Some(display_name) => write!(
54 |                 f,
55 |                 "{} <{}>{}",
56 |                 display_name,
57 |                 self.uri,
58 |                 self.params
59 |                     .iter()
60 |                     .map(|s| s.to_string())
61 |                     .collect::<Vec<_>>()
62 |                     .join("")
63 |             ),
64 |             None => write!(
65 |                 f,
66 |                 "<{}>{}",
67 |                 self.uri,
68 |                 self.params
69 |                     .iter()
70 |                     .map(|s| s.to_string())
71 |                     .collect::<Vec<_>>()
72 |                     .join("")
73 |             ),
74 |         }
75 |     }
76 | }
77 | 
78 | impl std::convert::From<crate::common::Uri> for From {
79 |     fn from(uri: crate::common::Uri) -> Self {
80 |         Self {
81 |             display_name: None,
82 |             uri,
83 |             params: Default::default(),
84 |         }
85 |     }
86 | }
87 | 


--------------------------------------------------------------------------------
/src/headers/typed/in_reply_to.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::TokenListTokenizer as Tokenizer;
 3 | 
 4 | use rsip_derives::TypedHeader;
 5 | use std::convert::TryFrom;
 6 | 
 7 | /// The `In-Reply-To` header in its [typed](super) form.
 8 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug)]
 9 | pub struct InReplyTo(pub Vec<String>);
10 | 
11 | impl<'a> TryFrom<Tokenizer<'a>> for InReplyTo {
12 |     type Error = crate::Error;
13 | 
14 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
15 |         Ok(Self(
16 |             tokenizer
17 |                 .tokens
18 |                 .iter()
19 |                 .map(|s| s.to_string())
20 |                 .collect::<Vec<String>>(),
21 |         ))
22 |     }
23 | }
24 | 
25 | impl std::fmt::Display for InReplyTo {
26 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
27 |         write!(f, "{}", self.0.join(", "))
28 |     }
29 | }
30 | 


--------------------------------------------------------------------------------
/src/headers/typed/media_type.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::NameParamsTokenizer as Tokenizer;
 3 | 
 4 | use std::convert::TryFrom;
 5 | 
 6 | #[derive(Debug, PartialEq, Eq, Clone)]
 7 | pub enum MediaType {
 8 |     Sdp(Vec<MediaTypeParam>),
 9 |     Other(String, Vec<MediaTypeParam>),
10 | }
11 | 
12 | #[derive(Debug, PartialEq, Eq, Clone)]
13 | pub struct MediaTypeParam(pub String, pub String);
14 | 
15 | impl<S, T> From<(S, T)> for MediaTypeParam
16 | where
17 |     S: std::fmt::Display,
18 |     T: std::fmt::Display,
19 | {
20 |     fn from(tuple: (S, T)) -> Self {
21 |         Self(tuple.0.to_string(), tuple.1.to_string())
22 |     }
23 | }
24 | 
25 | impl<'a> TryFrom<Tokenizer<'a>> for MediaType {
26 |     type Error = crate::Error;
27 | 
28 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
29 |         match tokenizer.name {
30 |             s if s.eq_ignore_ascii_case("application/sdp") => Ok(Self::Sdp(
31 |                 tokenizer
32 |                     .params
33 |                     .into_iter()
34 |                     .map(Into::into)
35 |                     .collect::<Vec<_>>(),
36 |             )),
37 |             _ => Ok(Self::Other(
38 |                 tokenizer.name.to_string(),
39 |                 tokenizer
40 |                     .params
41 |                     .into_iter()
42 |                     .map(Into::into)
43 |                     .collect::<Vec<_>>(),
44 |             )),
45 |         }
46 |     }
47 | }
48 | 
49 | impl std::fmt::Display for MediaType {
50 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
51 |         match self {
52 |             Self::Sdp(params) if params.is_empty() => write!(f, "application/sdp"),
53 |             Self::Sdp(params) => write!(f, "application/sdp; {}", params_to_string(params)),
54 |             Self::Other(name, params) if params.is_empty() => write!(f, "{}", name),
55 |             Self::Other(name, params) => write!(f, "{}; {}", name, params_to_string(params)),
56 |         }
57 |     }
58 | }
59 | 
60 | impl std::fmt::Display for MediaTypeParam {
61 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
62 |         write!(f, "{}={}", self.0, self.1)
63 |     }
64 | }
65 | 
66 | fn params_to_string(params: &[MediaTypeParam]) -> String {
67 |     params
68 |         .iter()
69 |         .map(|s| s.to_string())
70 |         .collect::<Vec<_>>()
71 |         .join("; ")
72 | }
73 | 


--------------------------------------------------------------------------------
/src/headers/typed/mod.rs:
--------------------------------------------------------------------------------
 1 | //! Module holding the [TypedHeader] trait and all typed headers. A typed header is basically any
 2 | //! header that holds something more complex than an opque string (like `Call-ID`) or a number
 3 | //! (like `Expires`). New typed headers will be added along the way for newer RFCs like
 4 | //! [PASSporT](https://datatracker.ietf.org/doc/html/rfc8224),
 5 | //! [SHAKEN](https://datatracker.ietf.org/doc/html/rfc8588),
 6 | //! [push notifications](https://datatracker.ietf.org/doc/html/rfc8599) etc
 7 | //!
 8 | 
 9 | //This is not a header but a common helper
10 | pub mod media_type;
11 | pub use media_type::MediaType;
12 | 
13 | pub mod accept;
14 | pub mod alert_info;
15 | pub mod allow;
16 | pub mod authentication_info;
17 | pub mod authorization;
18 | pub mod call_info;
19 | pub mod contact;
20 | pub mod content_disposition;
21 | pub mod content_type;
22 | pub mod cseq;
23 | pub mod error_info;
24 | pub mod from;
25 | pub mod in_reply_to;
26 | pub mod priority;
27 | pub mod proxy_authenticate;
28 | pub mod proxy_authorization;
29 | pub mod record_route;
30 | pub mod reply_to;
31 | pub mod route;
32 | pub mod to;
33 | pub mod tokenizers;
34 | pub mod via;
35 | pub mod warning;
36 | pub mod www_authenticate;
37 | 
38 | pub use accept::Accept;
39 | pub use alert_info::AlertInfo;
40 | pub use allow::Allow;
41 | pub use authentication_info::AuthenticationInfo;
42 | pub use authorization::Authorization;
43 | pub use call_info::CallInfo;
44 | pub use contact::Contact;
45 | pub use content_disposition::ContentDisposition;
46 | pub use content_type::ContentType;
47 | pub use cseq::CSeq;
48 | pub use error_info::ErrorInfo;
49 | pub use from::From;
50 | pub use in_reply_to::InReplyTo;
51 | pub use priority::Priority;
52 | pub use proxy_authenticate::ProxyAuthenticate;
53 | pub use proxy_authorization::ProxyAuthorization;
54 | pub use record_route::RecordRoute;
55 | pub use reply_to::ReplyTo;
56 | pub use route::Route;
57 | pub use to::To;
58 | pub use via::Via;
59 | pub use warning::Warning;
60 | pub use www_authenticate::WwwAuthenticate;
61 | 
62 | pub trait TypedHeader<'a>:
63 |     std::fmt::Debug
64 |     + std::fmt::Display
65 |     + std::cmp::PartialEq
66 |     + std::cmp::Eq
67 |     + std::clone::Clone
68 |     + std::convert::TryFrom<Self::Tokenizer, Error = crate::Error>
69 |     + Into<String>
70 |     + Into<crate::Header>
71 | {
72 |     type Tokenizer: Tokenize<'a>;
73 | }
74 | 
75 | pub trait Tokenize<'a> {
76 |     fn tokenize(part: &'a str) -> Result<Self, crate::Error>
77 |     where
78 |         Self: Sized;
79 | }
80 | 


--------------------------------------------------------------------------------
/src/headers/typed/priority.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::ValueTokenizer as Tokenizer;
 3 | 
 4 | use rsip_derives::TypedHeader;
 5 | use std::convert::TryFrom;
 6 | 
 7 | /// The `Priority` header in its [typed](super) form.
 8 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug)]
 9 | pub enum Priority {
10 |     NonUrgent,
11 |     Normal,
12 |     Urgent,
13 |     Emergency,
14 |     Other(String),
15 | }
16 | 
17 | impl<'a> TryFrom<Tokenizer<'a>> for Priority {
18 |     type Error = crate::Error;
19 | 
20 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
21 |         match tokenizer.value {
22 |             s if s.eq_ignore_ascii_case("non-urgent") => Ok(Self::NonUrgent),
23 |             s if s.eq_ignore_ascii_case("normal") => Ok(Self::Normal),
24 |             s if s.eq_ignore_ascii_case("urgent") => Ok(Self::Urgent),
25 |             s if s.eq_ignore_ascii_case("emergency") => Ok(Self::Emergency),
26 |             s => Ok(Self::Other(s.into())),
27 |         }
28 |     }
29 | }
30 | 
31 | impl std::fmt::Display for Priority {
32 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
33 |         match self {
34 |             Self::NonUrgent => write!(f, "non-urgent"),
35 |             Self::Normal => write!(f, "normal"),
36 |             Self::Urgent => write!(f, "urgent"),
37 |             Self::Emergency => write!(f, "emergency"),
38 |             Self::Other(other) => write!(f, "{}", other),
39 |         }
40 |     }
41 | }
42 | 


--------------------------------------------------------------------------------
/src/headers/typed/proxy_authenticate.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::AuthTokenizer as Tokenizer;
 3 | 
 4 | use rsip_derives::TypedHeader;
 5 | use std::convert::TryFrom;
 6 | 
 7 | /// The `Proxy-Authenticate` header in its [typed](super) form.
 8 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug, Default)]
 9 | pub struct ProxyAuthenticate(pub super::WwwAuthenticate);
10 | 
11 | impl<'a> TryFrom<Tokenizer<'a>> for ProxyAuthenticate {
12 |     type Error = crate::Error;
13 | 
14 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
15 |         Ok(ProxyAuthenticate(super::WwwAuthenticate::try_from(
16 |             tokenizer,
17 |         )?))
18 |     }
19 | }
20 | 
21 | impl std::fmt::Display for ProxyAuthenticate {
22 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
23 |         write!(f, "{}", self.0)
24 |     }
25 | }
26 | 


--------------------------------------------------------------------------------
/src/headers/typed/proxy_authorization.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::AuthTokenizer as Tokenizer;
 3 | 
 4 | use rsip_derives::TypedHeader;
 5 | use std::convert::TryFrom;
 6 | 
 7 | /// The `Proxy-Authorization` header in its [typed](super) form.
 8 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug)]
 9 | pub struct ProxyAuthorization(pub super::Authorization);
10 | 
11 | impl<'a> TryFrom<Tokenizer<'a>> for ProxyAuthorization {
12 |     type Error = crate::Error;
13 | 
14 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
15 |         Ok(ProxyAuthorization(super::Authorization::try_from(
16 |             tokenizer,
17 |         )?))
18 |     }
19 | }
20 | 
21 | impl std::fmt::Display for ProxyAuthorization {
22 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
23 |         write!(f, "{}", self.0)
24 |     }
25 | }
26 | 


--------------------------------------------------------------------------------
/src/headers/typed/record_route.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::UriWithParamsListTokenizer as Tokenizer;
 3 | 
 4 | use crate::common::uri::{UriWithParams, UriWithParamsList};
 5 | use rsip_derives::TypedHeader;
 6 | use std::convert::TryFrom;
 7 | 
 8 | /// The `Record-Route` header in its [typed](super) form.
 9 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug)]
10 | pub struct RecordRoute(pub UriWithParamsList);
11 | 
12 | impl RecordRoute {
13 |     pub fn uris(&self) -> &[UriWithParams] {
14 |         self.0.uris()
15 |     }
16 | }
17 | 
18 | impl From<UriWithParamsList> for RecordRoute {
19 |     fn from(uri_with_params_list: UriWithParamsList) -> Self {
20 |         Self(uri_with_params_list)
21 |     }
22 | }
23 | 
24 | impl<'a> TryFrom<Tokenizer<'a>> for RecordRoute {
25 |     type Error = crate::Error;
26 | 
27 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
28 |         Ok(Self(UriWithParamsList::try_from(tokenizer)?))
29 |     }
30 | }
31 | 
32 | impl std::fmt::Display for RecordRoute {
33 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
34 |         write!(f, "{}", self.0)
35 |     }
36 | }
37 | 


--------------------------------------------------------------------------------
/src/headers/typed/reply_to.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::UriWithParamsTokenizer as Tokenizer;
 3 | 
 4 | use crate::common::uri::UriWithParams;
 5 | use rsip_derives::TypedHeader;
 6 | use std::convert::TryFrom;
 7 | 
 8 | /// The `Record-Route` header in its [typed](super) form.
 9 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug)]
10 | pub struct ReplyTo(pub UriWithParams);
11 | 
12 | impl From<UriWithParams> for ReplyTo {
13 |     fn from(uri_with_params: UriWithParams) -> Self {
14 |         Self(uri_with_params)
15 |     }
16 | }
17 | 
18 | impl<'a> TryFrom<Tokenizer<'a>> for ReplyTo {
19 |     type Error = crate::Error;
20 | 
21 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
22 |         Ok(Self(UriWithParams::try_from(tokenizer)?))
23 |     }
24 | }
25 | 
26 | impl std::fmt::Display for ReplyTo {
27 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
28 |         write!(f, "{}", self.0)
29 |     }
30 | }
31 | 


--------------------------------------------------------------------------------
/src/headers/typed/route.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::UriWithParamsListTokenizer as Tokenizer;
 3 | 
 4 | use crate::common::uri::{UriWithParams, UriWithParamsList};
 5 | use rsip_derives::TypedHeader;
 6 | use std::convert::TryFrom;
 7 | 
 8 | /// The `Record-Route` header in its [typed](super) form.
 9 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug)]
10 | pub struct Route(pub UriWithParamsList);
11 | 
12 | impl Route {
13 |     pub fn uris(&self) -> &[UriWithParams] {
14 |         self.0.uris()
15 |     }
16 | }
17 | 
18 | impl From<UriWithParamsList> for Route {
19 |     fn from(uri_with_params_list: UriWithParamsList) -> Self {
20 |         Self(uri_with_params_list)
21 |     }
22 | }
23 | 
24 | impl<'a> TryFrom<Tokenizer<'a>> for Route {
25 |     type Error = crate::Error;
26 | 
27 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
28 |         Ok(Self(UriWithParamsList::try_from(tokenizer)?))
29 |     }
30 | }
31 | 
32 | impl std::fmt::Display for Route {
33 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
34 |         write!(f, "{}", self.0)
35 |     }
36 | }
37 | 


--------------------------------------------------------------------------------
/src/headers/typed/to.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::DisplayUriParamsTokenizer as Tokenizer;
 3 | 
 4 | use crate::common::uri::param::Tag;
 5 | use crate::common::{uri::Param, Uri};
 6 | use rsip_derives::{TypedHeader, UriAndParamsHelpers};
 7 | use std::convert::{TryFrom, TryInto};
 8 | 
 9 | /// The `To` header in its [typed](super) form.
10 | #[derive(TypedHeader, UriAndParamsHelpers, Eq, PartialEq, Clone, Debug)]
11 | pub struct To {
12 |     pub display_name: Option<String>,
13 |     pub uri: Uri,
14 |     pub params: Vec<Param>,
15 | }
16 | 
17 | impl<'a> TryFrom<Tokenizer<'a>> for To {
18 |     type Error = crate::Error;
19 | 
20 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
21 |         Ok(To {
22 |             display_name: tokenizer.display_name.map(Into::into),
23 |             uri: tokenizer.uri.try_into()?,
24 |             params: tokenizer
25 |                 .params
26 |                 .into_iter()
27 |                 .map(TryInto::try_into)
28 |                 .collect::<Result<Vec<_>, _>>()?,
29 |         })
30 |     }
31 | }
32 | 
33 | impl To {
34 |     pub fn tag(&self) -> Option<&Tag> {
35 |         self.params.iter().find_map(|param| match param {
36 |             Param::Tag(tag) => Some(tag),
37 |             _ => None,
38 |         })
39 |     }
40 | 
41 |     pub fn with_tag(mut self, tag: Tag) -> Self {
42 |         self.params
43 |             .retain(|param| !matches!(param, Param::Tag(Tag { .. })));
44 | 
45 |         self.params.push(Tag::new(tag).into());
46 |         self
47 |     }
48 | }
49 | 
50 | impl std::fmt::Display for To {
51 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
52 |         match &self.display_name {
53 |             Some(display_name) => write!(
54 |                 f,
55 |                 "{} <{}>{}",
56 |                 display_name,
57 |                 self.uri,
58 |                 self.params
59 |                     .iter()
60 |                     .map(|s| s.to_string())
61 |                     .collect::<Vec<_>>()
62 |                     .join("")
63 |             ),
64 |             None => write!(
65 |                 f,
66 |                 "<{}>{}",
67 |                 self.uri,
68 |                 self.params
69 |                     .iter()
70 |                     .map(|s| s.to_string())
71 |                     .collect::<Vec<_>>()
72 |                     .join("")
73 |             ),
74 |         }
75 |     }
76 | }
77 | 
78 | impl std::convert::From<crate::common::Uri> for To {
79 |     fn from(uri: crate::common::Uri) -> Self {
80 |         Self {
81 |             display_name: None,
82 |             uri,
83 |             params: Default::default(),
84 |         }
85 |     }
86 | }
87 | 


--------------------------------------------------------------------------------
/src/headers/typed/tokenizers/auth.rs:
--------------------------------------------------------------------------------
 1 | use crate::{
 2 |     headers::{auth, typed::Tokenize},
 3 |     Error,
 4 | };
 5 | 
 6 | #[derive(Eq, PartialEq, Clone, Debug)]
 7 | pub struct AuthTokenizer<'a> {
 8 |     pub scheme: auth::scheme::Tokenizer<'a, &'a str, char>,
 9 |     pub params: Vec<(&'a str, &'a str)>,
10 | }
11 | 
12 | impl<'a> Tokenize<'a> for AuthTokenizer<'a> {
13 |     fn tokenize(part: &'a str) -> Result<Self, Error> {
14 |         use crate::parser_utils::is_empty_or_fail_with;
15 |         use crate::NomStrError;
16 |         use nom::{
17 |             branch::alt,
18 |             bytes::complete::{tag, take_until},
19 |             character::complete::space0,
20 |             combinator::{map, opt, rest},
21 |             multi::many1,
22 |             sequence::{delimited, tuple},
23 |         };
24 | 
25 |         let params = map(
26 |             tuple((
27 |                 space0,
28 |                 take_until("="),
29 |                 tag("="),
30 |                 alt((
31 |                     delimited(tag("\""), take_until("\""), tag("\"")),
32 |                     take_until(","),
33 |                     take_until(" "),
34 |                     rest,
35 |                 )),
36 |                 opt(tag(",")),
37 |             )),
38 |             |tuple| (tuple.1, tuple.3),
39 |         );
40 | 
41 |         let (rem, _) =
42 |             space0(part).map_err(|_: NomStrError<'a>| Error::tokenizer(("auth header", part)))?;
43 |         let (rem, scheme) = auth::scheme::Tokenizer::tokenize(rem)
44 |             .map_err(|_| Error::tokenizer(("auth header scheme", part)))?;
45 |         let (rem, params) = many1(params)(rem)
46 |             .map_err(|_: NomStrError<'a>| Error::tokenizer(("auth header params", part)))?;
47 |         is_empty_or_fail_with(rem, ("auth header params", part))?;
48 | 
49 |         Ok(Self { scheme, params })
50 |     }
51 | }
52 | 


--------------------------------------------------------------------------------
/src/headers/typed/tokenizers/cseq.rs:
--------------------------------------------------------------------------------
 1 | use crate::{headers::typed::Tokenize, Error};
 2 | 
 3 | #[derive(Eq, PartialEq, Clone, Debug)]
 4 | pub struct CseqTokenizer<'a> {
 5 |     pub seq: &'a str,
 6 |     pub method: &'a str,
 7 | }
 8 | 
 9 | impl<'a> Tokenize<'a> for CseqTokenizer<'a> {
10 |     fn tokenize(part: &'a str) -> Result<Self, Error> {
11 |         use nom::{
12 |             bytes::complete::take_until, character::complete::space1, combinator::rest,
13 |             error::VerboseError, sequence::tuple,
14 |         };
15 | 
16 |         let (_, (seq, _, method)) =
17 |             tuple((take_until::<_, _, VerboseError<&str>>(" "), space1, rest))(part)
18 |                 .map_err(|_| Error::tokenizer(("cseq header", part)))?;
19 | 
20 |         Ok(Self { seq, method })
21 |     }
22 | }
23 | 


--------------------------------------------------------------------------------
/src/headers/typed/tokenizers/display_uri_params.rs:
--------------------------------------------------------------------------------
 1 | use crate::{common::uri, headers::typed::Tokenize, Error};
 2 | 
 3 | #[derive(Eq, PartialEq, Clone, Debug)]
 4 | pub struct DisplayUriParamsTokenizer<'a> {
 5 |     pub display_name: Option<&'a str>,
 6 |     pub uri: uri::Tokenizer<'a, &'a str, char>,
 7 |     pub params: Vec<uri::param::Tokenizer<'a, &'a str, char>>,
 8 | }
 9 | 
10 | impl<'a> Tokenize<'a> for DisplayUriParamsTokenizer<'a> {
11 |     fn tokenize(part: &'a str) -> Result<Self, Error> {
12 |         use crate::parser_utils::is_empty_or_fail_with;
13 |         use nom::{
14 |             bytes::complete::{tag, take_until},
15 |             combinator::rest,
16 |             error::VerboseError,
17 |             multi::many0,
18 |             sequence::tuple,
19 |         };
20 | 
21 |         if part.contains('<') {
22 |             let (_, (display_name, _, uri, _, params)) = tuple::<_, _, VerboseError<&str>, _>((
23 |                 take_until("<"),
24 |                 tag("<"),
25 |                 take_until(">"),
26 |                 tag(">"),
27 |                 rest,
28 |             ))(part)
29 |             .map_err(|_| Error::tokenizer(("header parts", part)))?;
30 | 
31 |             let (rem, params) = many0(uri::param::Tokenizer::tokenize)(params)
32 |                 .map_err(|_| Error::tokenizer(("params", part)))?;
33 |             is_empty_or_fail_with(rem, ("params tokenizing left trailing input", part))?;
34 | 
35 |             Ok(Self {
36 |                 display_name: crate::utils::opt_trim(display_name),
37 |                 uri: uri::Tokenizer::tokenize(uri)
38 |                     .map_err(|_| Error::tokenizer(("URI in addr-spec", part)))?
39 |                     .1,
40 |                 params,
41 |             })
42 |         } else {
43 |             let (_, (uri, params)) = tuple((
44 |                 uri::Tokenizer::tokenize_without_params,
45 |                 many0(uri::param::Tokenizer::tokenize),
46 |             ))(part)?;
47 | 
48 |             Ok(Self {
49 |                 display_name: None,
50 |                 uri,
51 |                 params,
52 |             })
53 |         }
54 |     }
55 | }
56 | 


--------------------------------------------------------------------------------
/src/headers/typed/tokenizers/mod.rs:
--------------------------------------------------------------------------------
 1 | mod auth;
 2 | mod cseq;
 3 | mod display_uri_params;
 4 | mod name_params;
 5 | mod name_params_list;
 6 | mod name_value;
 7 | mod token_list;
 8 | mod uri_with_params;
 9 | mod uri_with_params_list;
10 | mod value;
11 | mod via;
12 | mod warning;
13 | 
14 | pub use auth::AuthTokenizer;
15 | pub use cseq::CseqTokenizer;
16 | pub use display_uri_params::DisplayUriParamsTokenizer;
17 | pub use name_params::NameParamsTokenizer;
18 | pub use name_params_list::NameParamsListTokenizer;
19 | pub use name_value::NameValueTokenizer;
20 | pub use token_list::TokenListTokenizer;
21 | pub use uri_with_params::UriWithParamsTokenizer;
22 | pub use uri_with_params_list::UriWithParamsListTokenizer;
23 | pub use value::ValueTokenizer;
24 | pub use via::ViaTokenizer;
25 | pub use warning::WarningTokenizer;
26 | 


--------------------------------------------------------------------------------
/src/headers/typed/tokenizers/name_params.rs:
--------------------------------------------------------------------------------
 1 | use crate::{headers::typed::Tokenize, Error};
 2 | 
 3 | #[derive(Eq, PartialEq, Clone, Debug)]
 4 | pub struct NameParamsTokenizer<'a> {
 5 |     pub name: &'a str,
 6 |     pub params: Vec<(&'a str, &'a str)>,
 7 | }
 8 | 
 9 | #[derive(Eq, PartialEq, Clone, Debug)]
10 | pub struct NameParamsListTokenizer<'a>(pub Vec<NameParamsTokenizer<'a>>);
11 | 
12 | impl<'a> Tokenize<'a> for NameParamsTokenizer<'a> {
13 |     fn tokenize(part: &'a str) -> Result<Self, Error> {
14 |         use crate::parser_utils::is_empty_or_fail_with;
15 |         use crate::NomStrError;
16 |         use nom::{
17 |             branch::alt,
18 |             bytes::complete::{tag, take_until},
19 |             character::complete::space0,
20 |             combinator::{map, opt, rest},
21 |             multi::many0,
22 |             sequence::{delimited, tuple},
23 |         };
24 | 
25 |         let params = map(
26 |             tuple((
27 |                 space0,
28 |                 tag(";"),
29 |                 space0,
30 |                 take_until("="),
31 |                 tag("="),
32 |                 alt((
33 |                     delimited(tag("\""), take_until("\""), tag("\"")),
34 |                     take_until(";"),
35 |                     rest,
36 |                 )),
37 |                 opt(tag(",")),
38 |             )),
39 |             |tuple| (tuple.3, tuple.5),
40 |         );
41 | 
42 |         let (rem, name) = alt((take_until(";"), rest))(part)
43 |             .map_err(|_: NomStrError<'a>| Error::tokenizer(("media type", part)))?;
44 |         let (rem, params) = many0(params)(rem)
45 |             .map_err(|_: NomStrError<'a>| Error::tokenizer(("media type params", part)))?;
46 |         is_empty_or_fail_with(rem, ("media type", rem))?;
47 | 
48 |         Ok(Self { name, params })
49 |     }
50 | }
51 | 
52 | impl<'a> Tokenize<'a> for NameParamsListTokenizer<'a> {
53 |     fn tokenize(part: &'a str) -> Result<Self, Error> {
54 |         use crate::NomStrError;
55 |         use nom::{
56 |             bytes::complete::{tag, take_until},
57 |             character::complete::space0,
58 |             multi::many0,
59 |             sequence::{terminated, tuple},
60 |         };
61 | 
62 |         let stopbreak = terminated(take_until(","), tuple((tag(","), space0)));
63 | 
64 |         let (rem, media_types) = many0(stopbreak)(part)
65 |             .map_err(|_: NomStrError<'a>| Error::tokenizer(("list media type params", part)))?;
66 |         let mut media_types = media_types
67 |             .into_iter()
68 |             .map(NameParamsTokenizer::tokenize)
69 |             .collect::<Result<Vec<NameParamsTokenizer>, Error>>()?;
70 |         if !rem.is_empty() {
71 |             media_types.push(NameParamsTokenizer::tokenize(rem)?)
72 |         }
73 | 
74 |         Ok(Self(media_types))
75 |     }
76 | }
77 | 


--------------------------------------------------------------------------------
/src/headers/typed/tokenizers/name_params_list.rs:
--------------------------------------------------------------------------------
 1 | use crate::{headers::typed::Tokenize, Error};
 2 | 
 3 | #[derive(Eq, PartialEq, Clone, Debug)]
 4 | pub struct NameParamsListTokenizer<'a>(pub Vec<super::NameParamsTokenizer<'a>>);
 5 | 
 6 | impl<'a> Tokenize<'a> for NameParamsListTokenizer<'a> {
 7 |     fn tokenize(part: &'a str) -> Result<Self, Error> {
 8 |         use crate::NomStrError;
 9 |         use nom::{
10 |             bytes::complete::{tag, take_until},
11 |             character::complete::space0,
12 |             multi::many0,
13 |             sequence::{terminated, tuple},
14 |         };
15 | 
16 |         let stopbreak = terminated(take_until(","), tuple((tag(","), space0)));
17 | 
18 |         let (rem, media_types) = many0(stopbreak)(part)
19 |             .map_err(|_: NomStrError<'a>| Error::tokenizer(("list media type params", part)))?;
20 |         let mut media_types = media_types
21 |             .into_iter()
22 |             .map(super::NameParamsTokenizer::tokenize)
23 |             .collect::<Result<Vec<super::NameParamsTokenizer>, Error>>()?;
24 |         if !rem.is_empty() {
25 |             media_types.push(super::NameParamsTokenizer::tokenize(rem)?)
26 |         }
27 | 
28 |         Ok(Self(media_types))
29 |     }
30 | }
31 | 


--------------------------------------------------------------------------------
/src/headers/typed/tokenizers/name_value.rs:
--------------------------------------------------------------------------------
 1 | use crate::{headers::typed::Tokenize, Error};
 2 | 
 3 | #[derive(Eq, PartialEq, Clone, Debug)]
 4 | pub struct NameValueTokenizer<'a> {
 5 |     pub params: Vec<(&'a str, &'a str)>,
 6 | }
 7 | 
 8 | impl<'a> From<Vec<(&'a str, &'a str)>> for NameValueTokenizer<'a> {
 9 |     fn from(params: Vec<(&'a str, &'a str)>) -> Self {
10 |         Self { params }
11 |     }
12 | }
13 | 
14 | impl<'a> Tokenize<'a> for NameValueTokenizer<'a> {
15 |     fn tokenize(part: &'a str) -> Result<Self, Error> {
16 |         use crate::parser_utils::is_empty_or_fail_with;
17 |         use crate::NomStrError;
18 |         use nom::{
19 |             branch::alt,
20 |             bytes::complete::{tag, take_until},
21 |             character::complete::space0,
22 |             combinator::{map, opt, rest},
23 |             multi::many1,
24 |             sequence::{delimited, tuple},
25 |         };
26 | 
27 |         let params = map(
28 |             tuple((
29 |                 space0,
30 |                 take_until("="),
31 |                 tag("="),
32 |                 alt((
33 |                     delimited(tag("\""), take_until("\""), tag("\"")),
34 |                     take_until(","),
35 |                     take_until(" "),
36 |                     rest,
37 |                 )),
38 |                 opt(tag(",")),
39 |             )),
40 |             |tuple| (tuple.1, tuple.3),
41 |         );
42 | 
43 |         let (rem, params) = many1(params)(part)
44 |             .map_err(|_: NomStrError<'a>| Error::tokenizer(("name value params", part)))?;
45 |         is_empty_or_fail_with(rem, ("name value params", part))?;
46 | 
47 |         Ok(Self { params })
48 |     }
49 | }
50 | 


--------------------------------------------------------------------------------
/src/headers/typed/tokenizers/token_list.rs:
--------------------------------------------------------------------------------
 1 | use crate::{headers::typed::Tokenize, Error};
 2 | 
 3 | //trims spaces on each token as well
 4 | #[derive(Eq, PartialEq, Clone, Debug)]
 5 | pub struct TokenListTokenizer<'a> {
 6 |     pub tokens: Vec<&'a str>,
 7 | }
 8 | 
 9 | impl<'a> Tokenize<'a> for TokenListTokenizer<'a> {
10 |     fn tokenize(part: &'a str) -> Result<Self, Error> {
11 |         use nom::{
12 |             bytes::complete::{tag, take_until},
13 |             multi::many0,
14 |             sequence::terminated,
15 |         };
16 | 
17 |         let stopbreak = terminated(take_until(","), tag(","));
18 | 
19 |         let (last_token, mut tokens) = many0(stopbreak)(part)?;
20 | 
21 |         tokens = tokens.into_iter().map(|s| s.trim()).collect::<Vec<_>>();
22 | 
23 |         tokens.push(last_token.trim());
24 | 
25 |         Ok(Self { tokens })
26 |     }
27 | }
28 | 


--------------------------------------------------------------------------------
/src/headers/typed/tokenizers/uri_with_params.rs:
--------------------------------------------------------------------------------
 1 | use crate::{headers::typed::Tokenize, uri_with_params, Error};
 2 | 
 3 | pub type UriWithParamsTokenizer<'a> = uri_with_params::Tokenizer<'a, &'a str, char>;
 4 | 
 5 | impl<'a> Tokenize<'a> for UriWithParamsTokenizer<'a> {
 6 |     fn tokenize(part: &'a str) -> Result<Self, Error> {
 7 |         Ok(Self::tokenize(part)?.1)
 8 |     }
 9 | }
10 | 


--------------------------------------------------------------------------------
/src/headers/typed/tokenizers/uri_with_params_list.rs:
--------------------------------------------------------------------------------
 1 | use crate::{headers::typed::Tokenize, uri_with_params_list, Error};
 2 | 
 3 | pub type UriWithParamsListTokenizer<'a> = uri_with_params_list::Tokenizer<'a, &'a str, char>;
 4 | 
 5 | impl<'a> Tokenize<'a> for UriWithParamsListTokenizer<'a> {
 6 |     fn tokenize(part: &'a str) -> Result<Self, Error> {
 7 |         Ok(Self::tokenize(part)?.1)
 8 |     }
 9 | }
10 | 


--------------------------------------------------------------------------------
/src/headers/typed/tokenizers/value.rs:
--------------------------------------------------------------------------------
 1 | use crate::{headers::typed::Tokenize, Error};
 2 | 
 3 | #[derive(Eq, PartialEq, Clone, Debug)]
 4 | pub struct ValueTokenizer<'a> {
 5 |     pub value: &'a str,
 6 | }
 7 | 
 8 | impl<'a> From<&'a str> for ValueTokenizer<'a> {
 9 |     fn from(value: &'a str) -> Self {
10 |         Self { value }
11 |     }
12 | }
13 | 
14 | impl<'a> Tokenize<'a> for ValueTokenizer<'a> {
15 |     fn tokenize(value: &'a str) -> Result<Self, Error> {
16 |         Ok(Self { value })
17 |     }
18 | }
19 | 


--------------------------------------------------------------------------------
/src/headers/typed/tokenizers/via.rs:
--------------------------------------------------------------------------------
 1 | use crate::{
 2 |     common::{
 3 |         transport,
 4 |         uri::{self, param},
 5 |         version,
 6 |     },
 7 |     headers::typed::Tokenize,
 8 |     Error,
 9 | };
10 | 
11 | #[derive(Eq, PartialEq, Debug)]
12 | pub struct ViaTokenizer<'a> {
13 |     pub version: version::Tokenizer<'a, &'a str, char>,
14 |     pub transport: transport::Tokenizer<'a, &'a str, char>,
15 |     pub uri: uri::Tokenizer<'a, &'a str, char>,
16 |     pub params: Vec<uri::param::Tokenizer<'a, &'a str, char>>,
17 | }
18 | 
19 | impl<'a> Tokenize<'a> for ViaTokenizer<'a> {
20 |     fn tokenize(part: &'a str) -> Result<Self, Error> {
21 |         use nom::{
22 |             bytes::complete::tag, character::complete::space1, multi::many0, sequence::tuple,
23 |         };
24 | 
25 |         let (_, (version, _, transport, _, uri, params)) = tuple((
26 |             version::Tokenizer::tokenize,
27 |             tag("/"),
28 |             transport::Tokenizer::tokenize,
29 |             space1,
30 |             uri::Tokenizer::tokenize_without_params,
31 |             many0(param::Tokenizer::tokenize),
32 |         ))(part)
33 |         .map_err(|_| Error::tokenizer(("via (typed) header", part)))?;
34 | 
35 |         Ok(Self {
36 |             version,
37 |             transport,
38 |             uri,
39 |             params,
40 |         })
41 |     }
42 | }
43 | 


--------------------------------------------------------------------------------
/src/headers/typed/tokenizers/warning.rs:
--------------------------------------------------------------------------------
 1 | use crate::{headers::typed::Tokenize, Error};
 2 | 
 3 | //trims spaces on each token as well
 4 | #[derive(Eq, PartialEq, Clone, Debug)]
 5 | pub struct WarningTokenizer<'a> {
 6 |     pub code: &'a str,
 7 |     pub host: &'a str,
 8 |     pub text: &'a str,
 9 | }
10 | 
11 | impl<'a> From<(&'a str, &'a str, &'a str)> for WarningTokenizer<'a> {
12 |     fn from((code, host, text): (&'a str, &'a str, &'a str)) -> Self {
13 |         Self { code, host, text }
14 |     }
15 | }
16 | 
17 | impl<'a> Tokenize<'a> for WarningTokenizer<'a> {
18 |     fn tokenize(part: &'a str) -> Result<Self, Error> {
19 |         use nom::{
20 |             bytes::complete::{tag, take_until},
21 |             sequence::{terminated, tuple},
22 |         };
23 | 
24 |         let (text, (code, host)) = tuple((
25 |             terminated(take_until(" "), tag(" ")),
26 |             terminated(take_until(" "), tag(" ")),
27 |         ))(part)?;
28 | 
29 |         Ok(Self {
30 |             code,
31 |             host,
32 |             text: text.trim_start_matches('"').trim_end_matches('"'),
33 |         })
34 |     }
35 | }
36 | 


--------------------------------------------------------------------------------
/src/headers/typed/via.rs:
--------------------------------------------------------------------------------
  1 | #[doc(hidden)]
  2 | pub use super::tokenizers::ViaTokenizer as Tokenizer;
  3 | 
  4 | use crate::{
  5 |     common::{
  6 |         uri::{self, param::Branch, Param, Uri},
  7 |         Transport, Version,
  8 |     },
  9 |     Error,
 10 | };
 11 | use rsip_derives::{TypedHeader, UriAndParamsHelpers};
 12 | use std::{
 13 |     convert::{TryFrom, TryInto},
 14 |     net::IpAddr,
 15 | };
 16 | 
 17 | /// The `Via` header in its [typed](super) form.
 18 | #[derive(TypedHeader, UriAndParamsHelpers, Eq, PartialEq, Clone, Debug)]
 19 | pub struct Via {
 20 |     pub version: Version,
 21 |     pub transport: Transport,
 22 |     //TODO: rename to sent-by ?
 23 |     pub uri: Uri,
 24 |     pub params: Vec<uri::Param>,
 25 | }
 26 | 
 27 | impl Via {
 28 |     pub fn branch(&self) -> Result<&Branch, Error> {
 29 |         self.params
 30 |             .iter()
 31 |             .find_map(|param| match param {
 32 |                 Param::Branch(branch) => Some(branch),
 33 |                 _ => None,
 34 |             })
 35 |             .ok_or_else(|| Error::missing_param("branch"))
 36 |     }
 37 | 
 38 |     pub fn received(&self) -> Result<Option<IpAddr>, std::net::AddrParseError> {
 39 |         self.params
 40 |             .iter()
 41 |             .find_map(|param| match param {
 42 |                 Param::Received(received) => Some(received.parse()),
 43 |                 _ => None,
 44 |             })
 45 |             .transpose()
 46 |     }
 47 | 
 48 |     pub fn sent_by(&self) -> &Uri {
 49 |         &self.uri
 50 |     }
 51 | 
 52 |     pub fn sent_protocol(&self) -> &Transport {
 53 |         &self.transport
 54 |     }
 55 | }
 56 | 
 57 | impl<'a> TryFrom<Tokenizer<'a>> for Via {
 58 |     type Error = crate::Error;
 59 | 
 60 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
 61 |         Ok(Via {
 62 |             version: tokenizer.version.try_into()?,
 63 |             transport: tokenizer.transport.try_into()?,
 64 |             uri: tokenizer.uri.try_into()?,
 65 |             params: tokenizer
 66 |                 .params
 67 |                 .into_iter()
 68 |                 .map(TryInto::try_into)
 69 |                 .collect::<Result<Vec<_>, _>>()?,
 70 |         })
 71 |     }
 72 | }
 73 | 
 74 | impl std::fmt::Display for Via {
 75 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
 76 |         write!(
 77 |             f,
 78 |             "{}/{} {}{}",
 79 |             self.version,
 80 |             self.transport,
 81 |             self.uri,
 82 |             self.params
 83 |                 .iter()
 84 |                 .map(|s| s.to_string())
 85 |                 .collect::<Vec<_>>()
 86 |                 .join("")
 87 |         )
 88 |     }
 89 | }
 90 | 
 91 | impl std::convert::From<crate::common::Uri> for Via {
 92 |     fn from(uri: crate::common::Uri) -> Self {
 93 |         Self {
 94 |             version: Default::default(),
 95 |             transport: Default::default(),
 96 |             uri,
 97 |             params: vec![Param::Branch(Default::default())],
 98 |         }
 99 |     }
100 | }
101 | 


--------------------------------------------------------------------------------
/src/headers/typed/warning.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::WarningTokenizer as Tokenizer;
 3 | 
 4 | use crate::common::Uri;
 5 | use rsip_derives::TypedHeader;
 6 | use std::convert::{TryFrom, TryInto};
 7 | 
 8 | /// The `Record-Warning` header in its [typed](super) form.
 9 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug)]
10 | pub struct Warning {
11 |     pub code: u16,
12 |     pub uri: Uri,
13 |     pub text: String,
14 | }
15 | 
16 | impl<'a> TryFrom<Tokenizer<'a>> for Warning {
17 |     type Error = crate::Error;
18 | 
19 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
20 |         Ok(Self {
21 |             code: tokenizer.code.parse::<u16>()?,
22 |             uri: Uri {
23 |                 host_with_port: tokenizer.host.try_into()?,
24 |                 ..Default::default()
25 |             },
26 |             text: tokenizer.text.into(),
27 |         })
28 |     }
29 | }
30 | 
31 | impl std::fmt::Display for Warning {
32 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
33 |         if self.text.starts_with('"') && self.text.ends_with('"') {
34 |             write!(f, "{} {} {}", self.code, self.uri, self.text)
35 |         } else {
36 |             write!(f, "{} {} \"{}\"", self.code, self.uri, self.text)
37 |         }
38 |     }
39 | }
40 | 


--------------------------------------------------------------------------------
/src/headers/typed/www_authenticate.rs:
--------------------------------------------------------------------------------
 1 | #[doc(hidden)]
 2 | pub use super::tokenizers::AuthTokenizer as Tokenizer;
 3 | 
 4 | use crate::headers::auth::{Algorithm, Qop};
 5 | use crate::{headers::auth, Error};
 6 | use rsip_derives::TypedHeader;
 7 | use std::convert::{TryFrom, TryInto};
 8 | 
 9 | /// The `WwwAuthenticate` header in its [typed](super) form.
10 | #[derive(TypedHeader, Eq, PartialEq, Clone, Debug, Default)]
11 | pub struct WwwAuthenticate {
12 |     pub scheme: auth::Scheme,
13 |     pub realm: String,
14 |     pub domain: Option<String>,
15 |     pub nonce: String,
16 |     pub opaque: Option<String>,
17 |     pub stale: Option<String>,
18 |     pub algorithm: Option<Algorithm>,
19 |     //TODO: support multiple Qop
20 |     pub qop: Option<Qop>,
21 |     pub charset: Option<String>,
22 |     //pub userhash: Option<bool>,
23 | }
24 | 
25 | impl<'a> TryFrom<Tokenizer<'a>> for WwwAuthenticate {
26 |     type Error = crate::Error;
27 | 
28 |     fn try_from(tokenizer: Tokenizer) -> Result<Self, Self::Error> {
29 |         Ok(WwwAuthenticate {
30 |             scheme: tokenizer.scheme.try_into()?,
31 |             realm: find_param(&tokenizer.params, "realm")
32 |                 .ok_or_else(|| Error::InvalidParam("missing realm".into()))?
33 |                 .into(),
34 |             domain: find_param(&tokenizer.params, "domain").map(Into::into),
35 |             nonce: find_param(&tokenizer.params, "nonce")
36 |                 .ok_or_else(|| Error::InvalidParam("missing nonce".into()))?
37 |                 .into(),
38 |             opaque: find_param(&tokenizer.params, "opaque").map(Into::into),
39 |             stale: find_param(&tokenizer.params, "stale").map(Into::into),
40 |             algorithm: find_param(&tokenizer.params, "algorithm")
41 |                 .map(TryInto::try_into)
42 |                 .transpose()?,
43 |             qop: find_param(&tokenizer.params, "qop")
44 |                 .map(TryInto::try_into)
45 |                 .transpose()?,
46 |             charset: find_param(&tokenizer.params, "charset").map(Into::into),
47 |         })
48 |     }
49 | }
50 | 
51 | impl std::fmt::Display for WwwAuthenticate {
52 |     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
53 |         write!(f, "{} realm=\"{}\"", self.scheme, self.realm)?;
54 |         if let Some(domain) = &self.domain {
55 |             write!(f, ", domain=\"{}\"", domain)?;
56 |         }
57 | 
58 |         write!(f, ", nonce=\"{}\"", self.nonce)?;
59 | 
60 |         if let Some(opaque) = &self.opaque {
61 |             write!(f, ", opaque=\"{}\"", opaque)?;
62 |         }
63 | 
64 |         if let Some(stale) = &self.stale {
65 |             write!(f, ", stale={}", stale)?;
66 |         }
67 | 
68 |         if let Some(algorithm) = &self.algorithm {
69 |             write!(f, ", algorithm={}", algorithm)?;
70 |         }
71 | 
72 |         if let Some(qop) = &self.qop {
73 |             write!(f, ", qop=\"{}\"", qop)?;
74 |         }
75 | 
76 |         if let Some(charset) = &self.charset {
77 |             write!(f, ", charset={}", charset)?;
78 |         }
79 | 
80 |         Ok(())
81 |     }
82 | }
83 | 
84 | fn find_param<'a>(params: &[(&'a str, &'a str)], name: &str) -> Option<&'a str> {
85 |     params.iter().find_map(|(key, value)| {
86 |         if key.eq_ignore_ascii_case(name) {
87 |             Some(*value)
88 |         } else {
89 |             None
90 |         }
91 |     })
92 | }
93 | 


--------------------------------------------------------------------------------
/src/headers/untyped/accept.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
2 | 
3 | /// The `Accept` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct Accept(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/accept_encoding.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::UntypedHeader;
2 | 
3 | /// The `Accept-Encoding` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct AcceptEncoding(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/accept_language.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::UntypedHeader;
2 | 
3 | /// The `Accept-Language` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct AcceptLanguage(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/alert_info.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
2 | 
3 | /// The `Alert-Info` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct AlertInfo(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/allow.rs:
--------------------------------------------------------------------------------
 1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
 2 | 
 3 | /// The `Allow` header in its [untyped](super) form.
 4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
 5 | pub struct Allow(String);
 6 | 
 7 | impl Default for Allow {
 8 |     fn default() -> Self {
 9 |         Self(
10 |             crate::common::Method::all()
11 |                 .into_iter()
12 |                 .map(|s| s.to_string())
13 |                 .collect::<Vec<_>>()
14 |                 .join(", "),
15 |         )
16 |     }
17 | }
18 | 


--------------------------------------------------------------------------------
/src/headers/untyped/authentication_info.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
2 | 
3 | /// The `Authentication-Info` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct AuthenticationInfo(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/authorization.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
2 | 
3 | /// The `Authorization` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct Authorization(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/call_id.rs:
--------------------------------------------------------------------------------
 1 | use rsip_derives::UntypedHeader;
 2 | use uuid::Uuid;
 3 | 
 4 | /// The `Call-ID` header in its [untyped](super) form.
 5 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
 6 | #[header(display_name = "Call-ID")]
 7 | pub struct CallId(String);
 8 | 
 9 | impl Default for CallId {
10 |     fn default() -> Self {
11 |         Self(format!("{}@example.com", Uuid::new_v4()))
12 |     }
13 | }
14 | 


--------------------------------------------------------------------------------
/src/headers/untyped/call_info.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
2 | 
3 | /// The `Call-Info` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct CallInfo(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/contact.rs:
--------------------------------------------------------------------------------
 1 | use crate::{
 2 |     common::{
 3 |         uri::{param, Param},
 4 |         Uri,
 5 |     },
 6 |     headers::untyped::ToTypedHeader,
 7 |     Error,
 8 | };
 9 | use rsip_derives::{ToTypedHeader, UntypedHeader};
10 | 
11 | /// The `Contact` header in its [untyped](super) form.
12 | #[derive(ToTypedHeader, UntypedHeader, Debug, PartialEq, Eq, Clone)]
13 | pub struct Contact(String);
14 | 
15 | impl Contact {
16 |     pub fn display_name(&self) -> Result<Option<String>, Error> {
17 |         self.typed().map(|s| s.display_name)
18 |     }
19 | 
20 |     pub fn uri(&self) -> Result<Uri, Error> {
21 |         Ok(self.typed()?.uri)
22 |     }
23 | 
24 |     pub fn params(&self) -> Result<Vec<Param>, Error> {
25 |         Ok(self.typed()?.params)
26 |     }
27 | 
28 |     pub fn expires(&self) -> Result<Option<param::Expires>, Error> {
29 |         self.typed().map(|s| s.expires().cloned())
30 |     }
31 | 
32 |     pub fn with_uri(mut self, uri: Uri) -> Result<Self, Error> {
33 |         let mut typed = self.typed()?;
34 |         typed.uri = uri;
35 |         self.0 = typed.into();
36 |         Ok(self)
37 |     }
38 | 
39 |     //TODO: this should be replace_uri not mut uri
40 |     pub fn mut_uri(&mut self, uri: Uri) -> Result<&mut Self, Error> {
41 |         let mut typed = self.typed()?;
42 |         typed.uri = uri;
43 |         self.0 = typed.into();
44 |         Ok(self)
45 |     }
46 | 
47 |     pub fn with_params(mut self, params: Vec<Param>) -> Result<Self, Error> {
48 |         let mut typed = self.typed()?;
49 |         typed.params = params;
50 |         self.0 = typed.into();
51 |         Ok(self)
52 |     }
53 | 
54 |     pub fn mut_params(&mut self, params: Vec<Param>) -> Result<&mut Self, Error> {
55 |         let mut typed = self.typed()?;
56 |         typed.params = params;
57 |         self.0 = typed.into();
58 |         Ok(self)
59 |     }
60 | }
61 | 


--------------------------------------------------------------------------------
/src/headers/untyped/content_disposition.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
2 | 
3 | /// The `Content-Disposition` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct ContentDisposition(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/content_encoding.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::UntypedHeader;
2 | 
3 | /// The `Content-Encoding` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct ContentEncoding(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/content_language.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::UntypedHeader;
2 | 
3 | /// The `Content-Language` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct ContentLanguage(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/content_length.rs:
--------------------------------------------------------------------------------
 1 | use rsip_derives::UntypedHeader;
 2 | 
 3 | /// The `Content-Length` header in its [untyped](super) form.
 4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
 5 | pub struct ContentLength(String);
 6 | 
 7 | impl Default for ContentLength {
 8 |     fn default() -> Self {
 9 |         Self("0".into())
10 |     }
11 | }
12 | 
13 | impl ContentLength {
14 |     pub fn length(&self) -> Result<u32, crate::Error> {
15 |         use crate::headers::untyped::UntypedHeader;
16 | 
17 |         Ok(self.value().parse::<u32>()?)
18 |     }
19 | }
20 | 
21 | impl From<u32> for ContentLength {
22 |     fn from(from: u32) -> Self {
23 |         Self(from.to_string())
24 |     }
25 | }
26 | 


--------------------------------------------------------------------------------
/src/headers/untyped/content_type.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
2 | 
3 | /// The `Content-Type` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct ContentType(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/cseq.rs:
--------------------------------------------------------------------------------
 1 | use crate::{common::Method, headers::untyped::ToTypedHeader, Error};
 2 | use rsip_derives::{ToTypedHeader, UntypedHeader};
 3 | 
 4 | /// The `CSeq` header in its [untyped](super) form.
 5 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
 6 | #[header(display_name = "CSeq")]
 7 | pub struct CSeq(String);
 8 | 
 9 | impl CSeq {
10 |     pub fn seq(&self) -> Result<u32, Error> {
11 |         self.typed().map(|s| s.seq)
12 |     }
13 | 
14 |     pub fn mut_seq(&mut self, new_seq: u32) -> Result<&mut Self, Error> {
15 |         let mut typed = self.typed()?;
16 |         typed.seq = new_seq;
17 |         self.0 = typed.into();
18 |         Ok(self)
19 |     }
20 | 
21 |     pub fn method(&self) -> Result<Method, Error> {
22 |         self.typed().map(|s| s.method)
23 |     }
24 | 
25 |     pub fn mut_method(&mut self, new_method: Method) -> Result<&mut Self, Error> {
26 |         let mut typed = self.typed()?;
27 |         typed.method = new_method;
28 |         self.0 = typed.into();
29 |         Ok(self)
30 |     }
31 | }
32 | 


--------------------------------------------------------------------------------
/src/headers/untyped/date.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::UntypedHeader;
2 | 
3 | /// The `Date` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct Date(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/error_info.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
2 | 
3 | /// The `Error-Info` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct ErrorInfo(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/event.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::UntypedHeader;
2 | 
3 | /// The `Event` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct Event(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/expires.rs:
--------------------------------------------------------------------------------
 1 | use crate::Error;
 2 | use rsip_derives::UntypedHeader;
 3 | 
 4 | /// The `Expires` header in its [untyped](super) form.
 5 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
 6 | pub struct Expires(String);
 7 | 
 8 | impl Expires {
 9 |     pub fn seconds(&self) -> Result<u32, crate::Error> {
10 |         use crate::headers::untyped::UntypedHeader;
11 | 
12 |         Ok(self.value().parse::<u32>()?)
13 |     }
14 | }
15 | 
16 | impl From<u32> for Expires {
17 |     fn from(from: u32) -> Self {
18 |         Self(from.to_string())
19 |     }
20 | }
21 | 
22 | impl std::convert::TryFrom<Expires> for u32 {
23 |     type Error = Error;
24 | 
25 |     fn try_from(from: Expires) -> Result<Self, Self::Error> {
26 |         from.seconds()
27 |     }
28 | }
29 | 


--------------------------------------------------------------------------------
/src/headers/untyped/from.rs:
--------------------------------------------------------------------------------
 1 | use crate::{
 2 |     common::uri::{param::Tag, Param, Uri},
 3 |     headers::untyped::ToTypedHeader,
 4 |     Error,
 5 | };
 6 | use rsip_derives::{ToTypedHeader, UntypedHeader};
 7 | 
 8 | /// The `From` header in its [untyped](super) form.
 9 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
10 | pub struct From(String);
11 | 
12 | impl From {
13 |     pub fn display_name(&self) -> Result<Option<String>, Error> {
14 |         self.typed().map(|s| s.display_name)
15 |     }
16 | 
17 |     pub fn uri(&self) -> Result<Uri, Error> {
18 |         self.typed().map(|s| s.uri)
19 |     }
20 | 
21 |     pub fn params(&self) -> Result<Vec<Param>, Error> {
22 |         self.typed().map(|s| s.params)
23 |     }
24 | 
25 |     pub fn tag(&self) -> Result<Option<Tag>, Error> {
26 |         self.typed().map(|s| s.tag().cloned())
27 |     }
28 | 
29 |     pub fn with_tag(mut self, tag: Tag) -> Result<Self, Error> {
30 |         self.0 = self.typed()?.with_tag(tag).into();
31 |         Ok(self)
32 |     }
33 | 
34 |     pub fn mut_tag(&mut self, tag: Tag) -> Result<&mut Self, Error> {
35 |         self.0 = self.typed()?.with_tag(tag).into();
36 |         Ok(self)
37 |     }
38 | 
39 |     pub fn with_uri(mut self, uri: Uri) -> Result<Self, Error> {
40 |         self.0 = self.typed()?.with_uri(uri).into();
41 |         Ok(self)
42 |     }
43 | 
44 |     pub fn mut_uri(&mut self, uri: Uri) -> Result<&mut Self, Error> {
45 |         self.0 = self.typed()?.with_uri(uri).into();
46 |         Ok(self)
47 |     }
48 | }
49 | 


--------------------------------------------------------------------------------
/src/headers/untyped/in_reply_to.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
2 | 
3 | /// The `In-Reply-To` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct InReplyTo(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/max_forwards.rs:
--------------------------------------------------------------------------------
 1 | use crate::Error;
 2 | use rsip_derives::UntypedHeader;
 3 | 
 4 | /// The `Max-Forwards` header in its [untyped](super) form.
 5 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
 6 | pub struct MaxForwards(String);
 7 | 
 8 | impl Default for MaxForwards {
 9 |     fn default() -> Self {
10 |         Self("70".into())
11 |     }
12 | }
13 | 
14 | impl MaxForwards {
15 |     pub fn num(&self) -> Result<u32, crate::Error> {
16 |         use crate::headers::untyped::UntypedHeader;
17 | 
18 |         Ok(self.value().parse::<u32>()?)
19 |     }
20 | }
21 | 
22 | impl From<u32> for MaxForwards {
23 |     fn from(from: u32) -> Self {
24 |         Self(from.to_string())
25 |     }
26 | }
27 | 
28 | impl std::convert::TryFrom<MaxForwards> for u32 {
29 |     type Error = Error;
30 | 
31 |     fn try_from(from: MaxForwards) -> Result<Self, Self::Error> {
32 |         from.num()
33 |     }
34 | }
35 | 


--------------------------------------------------------------------------------
/src/headers/untyped/mime_version.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::UntypedHeader;
2 | 
3 | /// The `Mime-Version` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct MimeVersion(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/min_expires.rs:
--------------------------------------------------------------------------------
 1 | use crate::Error;
 2 | use rsip_derives::UntypedHeader;
 3 | 
 4 | /// The `Min-Expires` header in its [untyped](super) form.
 5 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
 6 | pub struct MinExpires(String);
 7 | 
 8 | impl MinExpires {
 9 |     pub fn seconds(&self) -> Result<u32, crate::Error> {
10 |         use crate::headers::untyped::UntypedHeader;
11 | 
12 |         Ok(self.value().parse::<u32>()?)
13 |     }
14 | }
15 | 
16 | impl From<u32> for MinExpires {
17 |     fn from(from: u32) -> Self {
18 |         Self(from.to_string())
19 |     }
20 | }
21 | 
22 | impl std::convert::TryFrom<MinExpires> for u32 {
23 |     type Error = Error;
24 | 
25 |     fn try_from(from: MinExpires) -> Result<Self, Self::Error> {
26 |         from.seconds()
27 |     }
28 | }
29 | 


--------------------------------------------------------------------------------
/src/headers/untyped/organization.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::UntypedHeader;
2 | 
3 | /// The `Organization` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct Organization(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/priority.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
2 | 
3 | /// The `Priority` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct Priority(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/proxy_authenticate.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
2 | 
3 | /// The `Proxy-Authentication` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct ProxyAuthenticate(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/proxy_authorization.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
2 | 
3 | /// The `Proxy-Authorization` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct ProxyAuthorization(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/proxy_require.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::UntypedHeader;
2 | 
3 | /// The `Proxy-Require` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct ProxyRequire(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/record_route.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
2 | 
3 | /// The `Record-Route` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct RecordRoute(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/reply_to.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
2 | 
3 | /// The `Reply-To` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct ReplyTo(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/require.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::UntypedHeader;
2 | 
3 | /// The `Require` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct Require(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/retry_after.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::UntypedHeader;
2 | 
3 | /// The `Retry-After` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct RetryAfter(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/route.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
2 | 
3 | /// The `Route` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct Route(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/server.rs:
--------------------------------------------------------------------------------
 1 | use rsip_derives::UntypedHeader;
 2 | 
 3 | /// The `Server` header in its [untyped](super) form.
 4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
 5 | pub struct Server(String);
 6 | 
 7 | impl Default for Server {
 8 |     fn default() -> Self {
 9 |         Self("rsip".into())
10 |     }
11 | }
12 | 


--------------------------------------------------------------------------------
/src/headers/untyped/subject.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::UntypedHeader;
2 | 
3 | /// The `Subject` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct Subject(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/subscription_state.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::UntypedHeader;
2 | 
3 | /// The `Subscription` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct SubscriptionState(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/supported.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::UntypedHeader;
2 | 
3 | /// The `Supported` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct Supported(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/timestamp.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::UntypedHeader;
2 | 
3 | /// The `Timestamp` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct Timestamp(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/to.rs:
--------------------------------------------------------------------------------
 1 | use crate::{
 2 |     common::uri::{param::Tag, Param, Uri},
 3 |     headers::untyped::ToTypedHeader,
 4 |     Error,
 5 | };
 6 | use rsip_derives::{ToTypedHeader, UntypedHeader};
 7 | 
 8 | /// The `To` header in its [untyped](super) form.
 9 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
10 | pub struct To(String);
11 | 
12 | impl To {
13 |     pub fn display_name(&self) -> Result<Option<String>, Error> {
14 |         self.typed().map(|s| s.display_name)
15 |     }
16 | 
17 |     pub fn uri(&self) -> Result<Uri, Error> {
18 |         self.typed().map(|s| s.uri)
19 |     }
20 | 
21 |     pub fn params(&self) -> Result<Vec<Param>, Error> {
22 |         self.typed().map(|s| s.params)
23 |     }
24 | 
25 |     pub fn tag(&self) -> Result<Option<Tag>, Error> {
26 |         self.typed().map(|s| s.tag().cloned())
27 |     }
28 | 
29 |     pub fn with_tag(mut self, tag: Tag) -> Result<Self, Error> {
30 |         self.0 = self.typed()?.with_tag(tag).into();
31 |         Ok(self)
32 |     }
33 | 
34 |     pub fn mut_tag(&mut self, tag: Tag) -> Result<&mut Self, Error> {
35 |         self.0 = self.typed()?.with_tag(tag).into();
36 |         Ok(self)
37 |     }
38 | 
39 |     pub fn with_uri(mut self, uri: Uri) -> Result<Self, Error> {
40 |         self.0 = self.typed()?.with_uri(uri).into();
41 |         Ok(self)
42 |     }
43 | 
44 |     pub fn mut_uri(&mut self, uri: Uri) -> Result<&mut Self, Error> {
45 |         self.0 = self.typed()?.with_uri(uri).into();
46 |         Ok(self)
47 |     }
48 | }
49 | 


--------------------------------------------------------------------------------
/src/headers/untyped/unsupported.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::UntypedHeader;
2 | 
3 | /// The `Unsupported` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct Unsupported(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/user_agent.rs:
--------------------------------------------------------------------------------
 1 | use rsip_derives::UntypedHeader;
 2 | 
 3 | /// The `User-Agent` header in its [untyped](super) form.
 4 | #[derive(UntypedHeader, Debug, PartialEq, Eq, Clone)]
 5 | pub struct UserAgent(String);
 6 | 
 7 | impl Default for UserAgent {
 8 |     fn default() -> Self {
 9 |         UserAgent("rsip".into())
10 |     }
11 | }
12 | 


--------------------------------------------------------------------------------
/src/headers/untyped/via.rs:
--------------------------------------------------------------------------------
 1 | use crate::{
 2 |     common::{
 3 |         param::{Branch, Param},
 4 |         Transport, Uri, Version,
 5 |     },
 6 |     headers::untyped::ToTypedHeader,
 7 |     Error,
 8 | };
 9 | use rsip_derives::{ToTypedHeader, UntypedHeader};
10 | 
11 | /// The `Via` header in its [untyped](super) form.
12 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
13 | pub struct Via(String);
14 | 
15 | impl Via {
16 |     pub fn version(&self) -> Result<Version, Error> {
17 |         self.typed().map(|s| s.version)
18 |     }
19 | 
20 |     pub fn trasnport(&self) -> Result<Transport, Error> {
21 |         self.typed().map(|s| s.transport)
22 |     }
23 | 
24 |     pub fn uri(&self) -> Result<Uri, Error> {
25 |         self.typed().map(|s| s.uri)
26 |     }
27 | 
28 |     pub fn branch(&self) -> Result<Branch, Error> {
29 |         Ok(self.typed()?.branch()?.clone())
30 |     }
31 | 
32 |     pub fn params(&self) -> Result<Vec<Param>, Error> {
33 |         self.typed().map(|s| s.params)
34 |     }
35 | 
36 |     pub fn with_uri(mut self, uri: Uri) -> Result<Self, Error> {
37 |         self.0 = self.typed()?.with_uri(uri).into();
38 |         Ok(self)
39 |     }
40 | 
41 |     pub fn mut_uri(&mut self, uri: Uri) -> Result<&mut Self, Error> {
42 |         self.0 = self.typed()?.with_uri(uri).into();
43 |         Ok(self)
44 |     }
45 | }
46 | 


--------------------------------------------------------------------------------
/src/headers/untyped/warning.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
2 | 
3 | /// The `Warning` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
5 | pub struct Warning(String);
6 | 


--------------------------------------------------------------------------------
/src/headers/untyped/www_authenticate.rs:
--------------------------------------------------------------------------------
1 | use rsip_derives::{ToTypedHeader, UntypedHeader};
2 | 
3 | /// The `WWW-Authenticate` header in its [untyped](super) form.
4 | #[derive(UntypedHeader, ToTypedHeader, Debug, PartialEq, Eq, Clone)]
5 | #[header(display_name = "WWW-Authenticate")]
6 | pub struct WwwAuthenticate(String);
7 | 


--------------------------------------------------------------------------------
/src/message/header_macros.rs:
--------------------------------------------------------------------------------
 1 | #[macro_export]
 2 | macro_rules! header {
 3 |     ($iter:expr, $header:path, $error:expr) => {
 4 |         $iter
 5 |             .find_map(|header| {
 6 |                 if let $header(header) = header {
 7 |                     Some(header)
 8 |                 } else {
 9 |                     None
10 |                 }
11 |             })
12 |             .ok_or($error)
13 |     };
14 | }
15 | 
16 | #[macro_export]
17 | macro_rules! all_headers {
18 |     ($iter:expr, $header:path) => {
19 |         $iter
20 |             .filter_map(|header| {
21 |                 if let $header(header) = header {
22 |                     Some(header)
23 |                 } else {
24 |                     None
25 |                 }
26 |             })
27 |             .collect()
28 |     };
29 | }
30 | 
31 | #[macro_export]
32 | macro_rules! header_opt {
33 |     ($iter:expr, $header:path) => {
34 |         $iter.find_map(|header| {
35 |             if let $header(header) = header {
36 |                 Some(header)
37 |             } else {
38 |                 None
39 |             }
40 |         })
41 |     };
42 | }
43 | 


--------------------------------------------------------------------------------
/src/message/mod.rs:
--------------------------------------------------------------------------------
 1 | #[macro_use]
 2 | pub mod header_macros;
 3 | pub mod headers_ext;
 4 | pub mod request;
 5 | pub mod response;
 6 | pub mod sip_message;
 7 | 
 8 | pub use headers_ext::HeadersExt;
 9 | pub use request::Request;
10 | pub use response::Response;
11 | pub use sip_message::SipMessage;
12 | 
13 | /// Simple trait to signify that the underlying type has headers so that the
14 | /// [HeadersExt](crate::message::HeadersExt) trait
15 | /// can automatically implement all the header methods by default.
16 | pub trait HasHeaders {
17 |     fn headers(&self) -> &crate::headers::Headers;
18 |     fn headers_mut(&mut self) -> &mut crate::headers::Headers;
19 | }
20 | 


--------------------------------------------------------------------------------
/src/services/mod.rs:
--------------------------------------------------------------------------------
1 | //! A module containing helpful services that go beyond headers and messages.
2 | //!
3 | 
4 | #[doc(hidden)]
5 | pub mod digest_generator;
6 | 
7 | pub use digest_generator::DigestGenerator;
8 | 


--------------------------------------------------------------------------------
/tests/common/method.rs:
--------------------------------------------------------------------------------
 1 | use rsip::common::method::{Method, Tokenizer};
 2 | use std::convert::TryInto;
 3 | 
 4 | mod display {
 5 |     use super::*;
 6 | 
 7 |     #[test]
 8 |     fn display1() {
 9 |         assert_eq!(Method::Register.to_string(), String::from("REGISTER"));
10 |     }
11 | }
12 | 
13 | mod parser {
14 |     use super::*;
15 | 
16 |     #[test]
17 |     fn parser1() {
18 |         assert_eq!(
19 |             Tokenizer::from("REGISTER".as_bytes()).try_into(),
20 |             Ok(Method::Register),
21 |         );
22 |     }
23 | 
24 |     #[test]
25 |     fn parser2() {
26 |         assert_eq!(
27 |             Tokenizer::from("  REGISTER  ".as_bytes()).try_into(),
28 |             Ok(Method::Register),
29 |         );
30 |     }
31 | 
32 |     #[test]
33 |     fn errors1() {
34 |         use std::convert::TryFrom;
35 | 
36 |         assert_eq!(
37 |             Method::try_from(Tokenizer::from("REGI STER".as_bytes())),
38 |             Err(rsip::Error::ParseError("invalid method: REGI STER".into())),
39 |         );
40 |     }
41 | }
42 | 
43 | mod tokenizer {
44 |     use super::*;
45 | 
46 |     #[test]
47 |     fn tokenizer1_u8() {
48 |         assert_eq!(
49 |             Tokenizer::tokenize("REGISTER something".as_bytes()),
50 |             Ok((" something".as_bytes(), "REGISTER".as_bytes().into())),
51 |         );
52 |     }
53 | 
54 |     #[test]
55 |     fn tokenizer1_str() {
56 |         assert_eq!(
57 |             Tokenizer::tokenize("REGISTER something"),
58 |             Ok((" something", "REGISTER".into())),
59 |         );
60 |     }
61 | 
62 |     #[test]
63 |     fn errors1() {
64 |         assert_eq!(
65 |             Tokenizer::tokenize("<<< something".as_bytes()),
66 |             Err(nom::Err::Error(rsip::TokenizerError::from(
67 |                 "failed to tokenize method: <<< something"
68 |             ))),
69 |         );
70 |     }
71 | }
72 | 


--------------------------------------------------------------------------------
/tests/common/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod method;
2 | pub mod status_code;
3 | pub mod transport;
4 | pub mod uri;
5 | pub mod version;
6 | 


--------------------------------------------------------------------------------
/tests/common/status_code.rs:
--------------------------------------------------------------------------------
 1 | use rsip::common::status_code::{StatusCode, Tokenizer};
 2 | use std::convert::TryInto;
 3 | 
 4 | mod display {
 5 |     use super::*;
 6 | 
 7 |     #[test]
 8 |     fn display1() {
 9 |         assert_eq!(StatusCode::OK.to_string(), String::from("200 OK"));
10 |     }
11 | 
12 |     #[test]
13 |     fn display2() {
14 |         assert_eq!(
15 |             StatusCode::Other(700, "Something".into()).to_string(),
16 |             String::from("700 Something")
17 |         );
18 |     }
19 | }
20 | 
21 | mod parser {
22 |     use super::*;
23 | 
24 |     #[test]
25 |     fn parser1() {
26 |         assert_eq!(
27 |             Tokenizer::from(("200".as_bytes(), "OK".as_bytes())).try_into(),
28 |             Ok(StatusCode::OK)
29 |         );
30 |     }
31 | 
32 |     #[test]
33 |     fn parser2() {
34 |         assert_eq!(
35 |             Tokenizer::from(("200".as_bytes(), "NOTOK".as_bytes())).try_into(),
36 |             Ok(StatusCode::OK)
37 |         );
38 |     }
39 | 
40 |     #[test]
41 |     fn parser3() {
42 |         assert_eq!(
43 |             Tokenizer::from(("700".as_bytes(), "Something".as_bytes())).try_into(),
44 |             Ok(StatusCode::Other(700, "Something".into()))
45 |         );
46 |     }
47 | }
48 | 
49 | pub mod tokenizer {
50 |     use super::*;
51 | 
52 |     #[test]
53 |     fn tokenizer1_u8() {
54 |         assert_eq!(
55 |             Tokenizer::tokenize("200 OK\r\nsomething".as_bytes()),
56 |             Ok((
57 |                 "\r\nsomething".as_bytes(),
58 |                 ("200".as_bytes(), "OK".as_bytes()).into()
59 |             )),
60 |         );
61 |     }
62 | 
63 |     #[test]
64 |     fn tokenizer1_str() {
65 |         assert_eq!(
66 |             Tokenizer::tokenize("200 OK\r\nsomething"),
67 |             Ok(("\r\nsomething", ("200", "OK").into())),
68 |         );
69 |     }
70 | 
71 |     #[test]
72 |     fn errors1() {
73 |         assert_eq!(
74 |             Tokenizer::tokenize("12 OK\r\n".as_bytes()),
75 |             Err(nom::Err::Error(rsip::TokenizerError::from(
76 |                 "failed to tokenize status: 12 OK\r\n"
77 |             ))),
78 |         );
79 |     }
80 | }
81 | 


--------------------------------------------------------------------------------
/tests/common/transport.rs:
--------------------------------------------------------------------------------
 1 | use rsip::common::transport::{Tokenizer, Transport};
 2 | use std::convert::TryInto;
 3 | 
 4 | mod display {
 5 |     use super::*;
 6 | 
 7 |     #[test]
 8 |     fn display1() {
 9 |         assert_eq!(Transport::Udp.to_string(), String::from("UDP"));
10 | 
11 |         assert_eq!(Transport::Tcp.to_string(), String::from("TCP"));
12 |     }
13 | }
14 | 
15 | mod parser {
16 |     use super::*;
17 | 
18 |     #[test]
19 |     fn parser1() {
20 |         assert_eq!(
21 |             Tokenizer::from("UDP".as_bytes()).try_into(),
22 |             Ok(Transport::Udp)
23 |         );
24 |     }
25 | 
26 |     #[test]
27 |     fn parser2() {
28 |         assert_eq!(
29 |             Tokenizer::from("TCP".as_bytes()).try_into(),
30 |             Ok(Transport::Tcp)
31 |         );
32 |     }
33 | }
34 | 
35 | mod tokenizer {
36 |     use super::*;
37 | 
38 |     #[test]
39 |     fn tokenizer1_u8() {
40 |         assert_eq!(Tokenizer::tokenize("UDP "), Ok((" ", "UDP".into())),);
41 |     }
42 | 
43 |     #[test]
44 |     fn tokenizer1_str() {
45 |         assert_eq!(
46 |             Tokenizer::tokenize("UDP ".as_bytes()),
47 |             Ok((" ".as_bytes(), "UDP".as_bytes().into())),
48 |         );
49 |     }
50 | 
51 |     #[test]
52 |     fn tokenizer2_u8() {
53 |         assert_eq!(
54 |             Tokenizer::tokenize("TCP".as_bytes()),
55 |             Ok(("".as_bytes(), "TCP".as_bytes().into())),
56 |         );
57 |     }
58 | 
59 |     #[test]
60 |     fn tokenizer2_str() {
61 |         assert_eq!(Tokenizer::tokenize("TCP"), Ok(("", "TCP".into())),);
62 |     }
63 | }
64 | 


--------------------------------------------------------------------------------
/tests/common/uri/auth.rs:
--------------------------------------------------------------------------------
 1 | use rsip::common::uri::auth::{Auth, Tokenizer};
 2 | use std::convert::TryInto;
 3 | 
 4 | mod display {
 5 |     use super::*;
 6 | 
 7 |     #[test]
 8 |     fn display1() {
 9 |         assert_eq!(
10 |             Auth {
11 |                 user: "user".into(),
12 |                 password: None
13 |             }
14 |             .to_string(),
15 |             String::from("user")
16 |         );
17 |     }
18 | 
19 |     #[test]
20 |     fn display2() {
21 |         assert_eq!(
22 |             Auth {
23 |                 user: "user".into(),
24 |                 password: Some("password".into())
25 |             }
26 |             .to_string(),
27 |             String::from("user:password")
28 |         );
29 |     }
30 | }
31 | 
32 | mod parser {
33 |     use super::*;
34 | 
35 |     #[test]
36 |     fn parser() {
37 |         assert_eq!(
38 |             Tokenizer::from(("user".as_bytes(), Some("password".as_bytes()))).try_into(),
39 |             Ok(Auth {
40 |                 user: "user".into(),
41 |                 password: Some("password".into())
42 |             }),
43 |         );
44 |     }
45 | }
46 | 
47 | mod tokenizer {
48 |     use super::*;
49 | 
50 |     #[test]
51 |     fn tokenizer1_u8() {
52 |         assert_eq!(
53 |             Tokenizer::tokenize("user:password@server2.com something".as_bytes()),
54 |             Ok((
55 |                 "server2.com something".as_bytes(),
56 |                 ("user".as_bytes(), Some("password".as_bytes())).into()
57 |             )),
58 |         );
59 |     }
60 | 
61 |     #[test]
62 |     fn tokenizer1_str() {
63 |         assert_eq!(
64 |             Tokenizer::tokenize("user:password@server2.com something"),
65 |             Ok(("server2.com something", ("user", Some("password")).into())),
66 |         );
67 |     }
68 | 
69 |     #[test]
70 |     fn errors1() {
71 |         assert_eq!(
72 |             Tokenizer::tokenize("server2.com something".as_bytes()),
73 |             Err(nom::Err::Error(rsip::TokenizerError::from(
74 |                 "failed to tokenize auth user: server2.com something"
75 |             ))),
76 |         );
77 |     }
78 | }
79 | 


--------------------------------------------------------------------------------
/tests/common/uri/host_with_port.rs:
--------------------------------------------------------------------------------
  1 | use rsip::common::uri::{host_with_port::Tokenizer, Host, HostWithPort};
  2 | use std::convert::TryInto;
  3 | 
  4 | mod display {
  5 |     use super::*;
  6 | 
  7 |     #[test]
  8 |     fn display1() {
  9 |         assert_eq!(
 10 |             HostWithPort {
 11 |                 host: Host::Domain("server2.com".into()),
 12 |                 port: None
 13 |             }
 14 |             .to_string(),
 15 |             String::from("server2.com")
 16 |         );
 17 |     }
 18 | 
 19 |     #[test]
 20 |     fn display2() {
 21 |         assert_eq!(
 22 |             HostWithPort {
 23 |                 host: Host::Domain("server2.com".into()),
 24 |                 port: Some(5060.into())
 25 |             }
 26 |             .to_string(),
 27 |             String::from("server2.com:5060")
 28 |         );
 29 |     }
 30 | }
 31 | 
 32 | mod parser {
 33 |     use super::*;
 34 | 
 35 |     #[test]
 36 |     fn parser1() {
 37 |         assert_eq!(
 38 |             Tokenizer::from(("server2.com".as_bytes(), None)).try_into(),
 39 |             Ok(HostWithPort {
 40 |                 host: Host::Domain("server2.com".into()),
 41 |                 port: None
 42 |             })
 43 |         );
 44 |     }
 45 | 
 46 |     #[test]
 47 |     fn parser2() {
 48 |         assert_eq!(
 49 |             Tokenizer::from(("server2.com".as_bytes(), Some("5060".as_bytes()))).try_into(),
 50 |             Ok(HostWithPort {
 51 |                 host: Host::Domain("server2.com".into()),
 52 |                 port: Some(5060.into())
 53 |             })
 54 |         );
 55 |     }
 56 | }
 57 | 
 58 | mod tokenizer {
 59 |     use super::*;
 60 | 
 61 |     #[test]
 62 |     fn tokenizer1_u8() {
 63 |         assert_eq!(
 64 |             Tokenizer::tokenize("server2.com something".as_bytes()),
 65 |             Ok((
 66 |                 " something".as_bytes(),
 67 |                 ("server2.com".as_bytes(), None).into()
 68 |             )),
 69 |         );
 70 |     }
 71 | 
 72 |     #[test]
 73 |     fn tokenizer1_str() {
 74 |         assert_eq!(
 75 |             Tokenizer::tokenize("server2.com something"),
 76 |             Ok((" something", ("server2.com", None).into())),
 77 |         );
 78 |     }
 79 | 
 80 |     #[test]
 81 |     fn tokenizer2_u8() {
 82 |         assert_eq!(
 83 |             Tokenizer::tokenize("server2.com:5060 something".as_bytes()),
 84 |             Ok((
 85 |                 " something".as_bytes(),
 86 |                 ("server2.com".as_bytes(), Some("5060".as_bytes())).into()
 87 |             )),
 88 |         );
 89 |     }
 90 | 
 91 |     #[test]
 92 |     fn errors1() {
 93 |         assert_eq!(
 94 |             Tokenizer::tokenize(";".as_bytes()),
 95 |             Err(nom::Err::Error(rsip::TokenizerError::from(
 96 |                 "failed to tokenize host with port: ;"
 97 |             ))),
 98 |         );
 99 |     }
100 | }
101 | 


--------------------------------------------------------------------------------
/tests/common/uri/params/mod.rs:
--------------------------------------------------------------------------------
 1 | use rsip::common::uri::param::{Maddr, Param, Tokenizer};
 2 | use std::convert::TryInto;
 3 | 
 4 | mod display {
 5 |     use super::*;
 6 | 
 7 |     #[test]
 8 |     fn display1() {
 9 |         assert_eq!(
10 |             Param::Maddr(Maddr::new("255.255.255.0")).to_string(),
11 |             String::from(";maddr=255.255.255.0")
12 |         );
13 |     }
14 | }
15 | 
16 | mod parser {
17 |     use super::*;
18 | 
19 |     #[test]
20 |     fn parser1() {
21 |         assert_eq!(
22 |             Tokenizer::from(("maddr".as_bytes(), Some("255.255.255.0".as_bytes()))).try_into(),
23 |             Ok(Param::Maddr(Maddr::new("255.255.255.0")))
24 |         );
25 |     }
26 | 
27 |     #[test]
28 |     fn parser2() {
29 |         assert_eq!(
30 |             Tokenizer::from(("maddr".as_bytes(), None,)).try_into(),
31 |             Ok(Param::Other("maddr".into(), None))
32 |         );
33 |     }
34 | }
35 | 
36 | mod tokenizer {
37 |     use super::*;
38 | 
39 |     #[test]
40 |     fn tokenizer1_u8() {
41 |         assert_eq!(
42 |             Tokenizer::tokenize(";maddr=255.255.255.255;something".as_bytes()),
43 |             Ok((
44 |                 ";something".as_bytes(),
45 |                 ("maddr".as_bytes(), Some("255.255.255.255".as_bytes())).into()
46 |             )),
47 |         );
48 |     }
49 | 
50 |     #[test]
51 |     fn tokenizer1_str() {
52 |         assert_eq!(
53 |             Tokenizer::tokenize(";maddr=255.255.255.255;something"),
54 |             Ok((";something", ("maddr", Some("255.255.255.255")).into())),
55 |         );
56 |     }
57 | 
58 |     #[test]
59 |     fn tokenizer2_u8() {
60 |         assert_eq!(
61 |             Tokenizer::tokenize(";maddr=255.255.255.255;something".as_bytes()),
62 |             Ok((
63 |                 ";something".as_bytes(),
64 |                 ("maddr".as_bytes(), Some("255.255.255.255".as_bytes())).into()
65 |             )),
66 |         );
67 |     }
68 | 
69 |     #[test]
70 |     fn errors1() {
71 |         assert_eq!(
72 |             Tokenizer::tokenize("hello".as_bytes()),
73 |             Err(nom::Err::Error(rsip::TokenizerError::from(
74 |                 "failed to tokenize uri param: hello"
75 |             ))),
76 |         );
77 |     }
78 | }
79 | 


--------------------------------------------------------------------------------
/tests/common/uri/scheme.rs:
--------------------------------------------------------------------------------
  1 | use rsip::common::uri::scheme::{Scheme, Tokenizer};
  2 | use std::convert::TryInto;
  3 | 
  4 | mod display {
  5 |     use super::*;
  6 | 
  7 |     #[test]
  8 |     fn display1() {
  9 |         assert_eq!(Scheme::Sip.to_string(), String::from("sip"));
 10 |     }
 11 | 
 12 |     #[test]
 13 |     fn display2() {
 14 |         assert_eq!(Scheme::Sips.to_string(), String::from("sips"));
 15 |     }
 16 | }
 17 | 
 18 | mod parser {
 19 |     use super::*;
 20 | 
 21 |     #[test]
 22 |     fn parser1() {
 23 |         assert_eq!(
 24 |             Tokenizer::from("sip".as_bytes()).try_into(),
 25 |             Ok(Scheme::Sip)
 26 |         );
 27 |     }
 28 | 
 29 |     #[test]
 30 |     fn parser2() {
 31 |         assert_eq!(
 32 |             Tokenizer::from("sips".as_bytes()).try_into(),
 33 |             Ok(Scheme::Sips)
 34 |         );
 35 |     }
 36 | 
 37 |     #[test]
 38 |     fn parser3() {
 39 |         assert_eq!(
 40 |             Tokenizer::from("tel".as_bytes()).try_into(),
 41 |             Ok(Scheme::Tel)
 42 |         )
 43 |     }
 44 | }
 45 | 
 46 | mod tokenizer {
 47 |     use super::*;
 48 | 
 49 |     #[test]
 50 |     fn tokenizer1_u8() {
 51 |         assert_eq!(
 52 |             Tokenizer::tokenize("sip:user2@server2.com something".as_bytes()),
 53 |             Ok((
 54 |                 "user2@server2.com something".as_bytes(),
 55 |                 "sip".as_bytes().into()
 56 |             )),
 57 |         );
 58 |     }
 59 | 
 60 |     #[test]
 61 |     fn tokenizer1_str() {
 62 |         assert_eq!(
 63 |             Tokenizer::tokenize("sip:user2@server2.com something"),
 64 |             Ok(("user2@server2.com something", "sip".into())),
 65 |         );
 66 |     }
 67 | 
 68 |     #[test]
 69 |     fn tokenizer2_u8() {
 70 |         assert_eq!(
 71 |             Tokenizer::tokenize("sips:user2@server2.com something".as_bytes()),
 72 |             Ok((
 73 |                 "user2@server2.com something".as_bytes(),
 74 |                 "sips".as_bytes().into()
 75 |             )),
 76 |         );
 77 |     }
 78 | 
 79 |     #[test]
 80 |     fn tokenizer3_str() {
 81 |         assert_eq!(
 82 |             Tokenizer::tokenize("tel:+12124567890"),
 83 |             Ok(("+12124567890", "tel".into())),
 84 |         )
 85 |     }
 86 | 
 87 |     #[test]
 88 |     fn errors1() {
 89 |         assert_eq!(
 90 |             Tokenizer::tokenize("soup:user2@server2.com something".as_bytes()),
 91 |             Err(nom::Err::Error(rsip::TokenizerError::from(
 92 |                 "failed to tokenize scheme: soup:user2@server2.com something"
 93 |             ))),
 94 |         );
 95 |     }
 96 | 
 97 |     #[test]
 98 |     fn errors2() {
 99 |         assert_eq!(
100 |             Tokenizer::tokenize("sip//:user2@server2.com something".as_bytes()),
101 |             Err(nom::Err::Error(rsip::TokenizerError::from(
102 |                 "failed to tokenize scheme: sip//:user2@server2.com something"
103 |             ))),
104 |         );
105 |     }
106 | }
107 | 


--------------------------------------------------------------------------------
/tests/common/version.rs:
--------------------------------------------------------------------------------
  1 | use rsip::common::version::{Tokenizer, Version};
  2 | use std::convert::{TryFrom, TryInto};
  3 | 
  4 | mod display {
  5 |     use super::*;
  6 | 
  7 |     #[test]
  8 |     fn display1() {
  9 |         assert_eq!(Version::V1.to_string(), String::from("SIP/1.0"));
 10 |     }
 11 | 
 12 |     #[test]
 13 |     fn display2() {
 14 |         assert_eq!(Version::V2.to_string(), String::from("SIP/2.0"));
 15 |     }
 16 | }
 17 | 
 18 | mod parser {
 19 |     use super::*;
 20 | 
 21 |     #[test]
 22 |     fn parser1() {
 23 |         assert_eq!(
 24 |             Tokenizer::from(("1".as_bytes(), "0".as_bytes())).try_into(),
 25 |             Ok(Version::V1)
 26 |         );
 27 |     }
 28 | 
 29 |     #[test]
 30 |     fn parser2() {
 31 |         assert_eq!(
 32 |             Tokenizer::from(("2".as_bytes(), "0".as_bytes())).try_into(),
 33 |             Ok(Version::V2)
 34 |         );
 35 |     }
 36 | 
 37 |     #[test]
 38 |     fn errors1() -> Result<(), rsip::Error> {
 39 |         assert_eq!(
 40 |             Version::try_from(Tokenizer::from(("a".as_bytes(), "0".as_bytes()))),
 41 |             Err(rsip::Error::ParseError("Unrecognized SIP version".into()))
 42 |         );
 43 | 
 44 |         Ok(())
 45 |     }
 46 | }
 47 | 
 48 | mod tokenizer {
 49 |     use super::*;
 50 | 
 51 |     #[test]
 52 |     fn tokenizer1_u8() {
 53 |         assert_eq!(
 54 |             Tokenizer::tokenize("SIP/1.0\r\nsomething".as_bytes()),
 55 |             Ok((
 56 |                 "\r\nsomething".as_bytes(),
 57 |                 ("1".as_bytes(), "0".as_bytes()).into()
 58 |             )),
 59 |         );
 60 |     }
 61 | 
 62 |     #[test]
 63 |     fn tokenizer1_str() {
 64 |         assert_eq!(
 65 |             Tokenizer::tokenize("SIP/1.0\r\nsomething"),
 66 |             Ok(("\r\nsomething", ("1", "0").into())),
 67 |         );
 68 |     }
 69 | 
 70 |     #[test]
 71 |     fn tokenizer2_u8() {
 72 |         assert_eq!(
 73 |             Tokenizer::tokenize("SIP/2.0 something".as_bytes()),
 74 |             Ok((
 75 |                 " something".as_bytes(),
 76 |                 ("2".as_bytes(), "0".as_bytes()).into()
 77 |             )),
 78 |         );
 79 |     }
 80 | 
 81 |     #[test]
 82 |     fn tokenizer3_u8() {
 83 |         assert_eq!(
 84 |             Tokenizer::tokenize("SIP/2.0/UDP pc33.atlanta.com".as_bytes()),
 85 |             Ok((
 86 |                 "/UDP pc33.atlanta.com".as_bytes(),
 87 |                 ("2".as_bytes(), "0".as_bytes()).into()
 88 |             )),
 89 |         );
 90 |     }
 91 | 
 92 |     #[test]
 93 |     fn errors1() {
 94 |         assert_eq!(
 95 |             Tokenizer::tokenize("SIP1.0\r\nsomething".as_bytes()),
 96 |             Err(nom::Err::Error(rsip::TokenizerError::from(
 97 |                 "failed to tokenize version: SIP1.0\r\nsomething"
 98 |             ))),
 99 |         );
100 |     }
101 | }
102 | 


--------------------------------------------------------------------------------
/tests/headers/accept/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod typed;
2 | 
3 | use rsip::headers::Accept;
4 | 
5 | validate_untyped_header_trait!(Accept);
6 | validate_to_typed_header_trait!(Accept);
7 | 


--------------------------------------------------------------------------------
/tests/headers/accept/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::headers::typed::{accept::Tokenizer, tokenizers::NameParamsTokenizer, Accept, MediaType};
 2 | use std::convert::TryInto;
 3 | 
 4 | validate_typed_header_trait!(Accept);
 5 | 
 6 | mod display {
 7 |     use super::*;
 8 | 
 9 |     #[test]
10 |     fn display1() {
11 |         assert_eq!(
12 |             Accept(vec![MediaType::Sdp(vec![])]).to_string(),
13 |             String::from(concat!("application/sdp",))
14 |         );
15 |     }
16 | 
17 |     #[test]
18 |     fn display2() {
19 |         assert_eq!(
20 |             Accept(vec![
21 |                 MediaType::Sdp(vec![
22 |                     ("charset", "ISO-8859-4").into(),
23 |                     ("foo", "bar").into()
24 |                 ]),
25 |                 MediaType::Other("application/json".into(), vec![("version", "v2").into()])
26 |             ])
27 |             .to_string(),
28 |             String::from(concat!(
29 |                 "application/sdp; charset=ISO-8859-4; foo=bar, application/json; version=v2"
30 |             ))
31 |         );
32 |     }
33 | }
34 | 
35 | mod try_from_tokenizer {
36 |     use super::*;
37 | 
38 |     #[test]
39 |     fn try_from_1() -> Result<(), rsip::Error> {
40 |         assert_eq!(
41 |             Tokenizer(vec![
42 |                 NameParamsTokenizer {
43 |                     name: "application/sdp".into(),
44 |                     params: vec![("charset", "ISO-8859-4").into(), ("foo", "bar").into()]
45 |                 },
46 |                 NameParamsTokenizer {
47 |                     name: "application/json".into(),
48 |                     params: vec![("version", "v2").into()]
49 |                 },
50 |             ])
51 |             .try_into(),
52 |             Ok(Accept(vec![
53 |                 MediaType::Sdp(vec![
54 |                     ("charset", "ISO-8859-4").into(),
55 |                     ("foo", "bar").into()
56 |                 ]),
57 |                 MediaType::Other("application/json".into(), vec![("version", "v2").into()])
58 |             ]))
59 |         );
60 | 
61 |         Ok(())
62 |     }
63 | }
64 | 


--------------------------------------------------------------------------------
/tests/headers/alert_info/mod.rs:
--------------------------------------------------------------------------------
1 | #[cfg(feature = "test-utils")]
2 | pub mod typed;
3 | 
4 | use rsip::headers::AlertInfo;
5 | 
6 | validate_untyped_header_trait!(AlertInfo);
7 | validate_to_typed_header_trait!(AlertInfo);
8 | 


--------------------------------------------------------------------------------
/tests/headers/alert_info/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::{
 2 |     common::uri::UriWithParamsList,
 3 |     headers::typed::{tokenizers::UriWithParamsListTokenizer, AlertInfo},
 4 | };
 5 | use std::convert::TryInto;
 6 | use testing_utils::Randomize;
 7 | 
 8 | validate_typed_header_trait!(AlertInfo);
 9 | 
10 | mod display {
11 |     use super::*;
12 | 
13 |     #[test]
14 |     fn display1() {
15 |         let uri_with_params_list = UriWithParamsList::random();
16 |         assert_eq!(
17 |             AlertInfo(uri_with_params_list.clone()).to_string(),
18 |             uri_with_params_list.to_string()
19 |         );
20 |     }
21 | }
22 | 
23 | mod try_from_tokenizer {
24 |     use super::*;
25 | 
26 |     #[test]
27 |     fn try_from_1() -> Result<(), rsip::Error> {
28 |         let uri_with_params_list = UriWithParamsList::random();
29 |         let uri_with_params_list_raw = uri_with_params_list.to_string();
30 |         let tokenizer = UriWithParamsListTokenizer::tokenize(&uri_with_params_list_raw)
31 |             .unwrap()
32 |             .1;
33 | 
34 |         assert_eq!(tokenizer.try_into(), Ok(AlertInfo(uri_with_params_list)));
35 | 
36 |         Ok(())
37 |     }
38 | }
39 | 


--------------------------------------------------------------------------------
/tests/headers/allow/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod typed;
2 | 
3 | use rsip::headers::Allow;
4 | 
5 | validate_untyped_header_trait!(Allow);
6 | validate_to_typed_header_trait!(Allow);
7 | 


--------------------------------------------------------------------------------
/tests/headers/allow/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::{
 2 |     common::Method,
 3 |     headers::typed::{allow::Tokenizer, Allow},
 4 | };
 5 | use std::convert::TryInto;
 6 | 
 7 | validate_typed_header_trait!(Allow);
 8 | 
 9 | mod display {
10 |     use super::*;
11 | 
12 |     #[test]
13 |     fn display1() {
14 |         assert_eq!(
15 |             Allow(vec![Method::Ack]).to_string(),
16 |             String::from(concat!("ACK",))
17 |         );
18 |     }
19 | 
20 |     #[test]
21 |     fn display2() {
22 |         assert_eq!(
23 |             Allow(vec![Method::Ack, Method::Bye]).to_string(),
24 |             String::from(concat!("ACK, BYE",))
25 |         );
26 |     }
27 | }
28 | 
29 | mod try_from_tokenizer {
30 |     use super::*;
31 | 
32 |     #[test]
33 |     fn try_from_1() -> Result<(), rsip::Error> {
34 |         assert_eq!(
35 |             Tokenizer {
36 |                 tokens: vec!["ACK"]
37 |             }
38 |             .try_into(),
39 |             Ok(Allow(vec![Method::Ack]))
40 |         );
41 | 
42 |         Ok(())
43 |     }
44 | 
45 |     #[test]
46 |     fn try_from_2() -> Result<(), rsip::Error> {
47 |         assert_eq!(
48 |             Tokenizer {
49 |                 tokens: vec!["ACK", "BYE"]
50 |             }
51 |             .try_into(),
52 |             Ok(Allow(vec![Method::Ack, Method::Bye]))
53 |         );
54 | 
55 |         Ok(())
56 |     }
57 | 
58 |     #[test]
59 |     fn try_from_3() -> Result<(), rsip::Error> {
60 |         assert_eq!(
61 |             Tokenizer {
62 |                 tokens: vec!["ACK", "BYE"]
63 |             }
64 |             .try_into(),
65 |             Ok(Allow(vec![Method::Ack, Method::Bye]))
66 |         );
67 | 
68 |         Ok(())
69 |     }
70 | }
71 | 


--------------------------------------------------------------------------------
/tests/headers/auth/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod scheme;
2 | 


--------------------------------------------------------------------------------
/tests/headers/auth/scheme.rs:
--------------------------------------------------------------------------------
 1 | pub mod tokenizer {
 2 |     use rsip::headers::auth::scheme::Tokenizer;
 3 | 
 4 |     #[test]
 5 |     fn with_str_input() -> Result<(), rsip::Error> {
 6 |         assert_eq!(Tokenizer::from("basic"), Tokenizer::tokenize("basic")?.1);
 7 |         assert_eq!(Tokenizer::from("basic"), Tokenizer::tokenize("basic  ")?.1);
 8 | 
 9 |         Ok(())
10 |     }
11 | 
12 |     #[test]
13 |     fn with_bytes_input() -> Result<(), rsip::Error> {
14 |         assert_eq!(
15 |             Tokenizer::from("basic".as_bytes()),
16 |             Tokenizer::tokenize("basic".as_bytes())?.1
17 |         );
18 |         assert_eq!(
19 |             Tokenizer::from("basic".as_bytes()),
20 |             Tokenizer::tokenize("basic  ".as_bytes())?.1
21 |         );
22 | 
23 |         Ok(())
24 |     }
25 | }
26 | 


--------------------------------------------------------------------------------
/tests/headers/authentication_info/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod typed;
2 | 
3 | use rsip::headers::AuthenticationInfo;
4 | 
5 | validate_untyped_header_trait!(AuthenticationInfo);
6 | validate_to_typed_header_trait!(AuthenticationInfo);
7 | 


--------------------------------------------------------------------------------
/tests/headers/authentication_info/typed.rs:
--------------------------------------------------------------------------------
  1 | use rsip::{
  2 |     headers::auth::AuthQop,
  3 |     headers::typed::{authentication_info::Tokenizer, AuthenticationInfo},
  4 | };
  5 | use std::convert::TryInto;
  6 | 
  7 | validate_typed_header_trait!(AuthenticationInfo);
  8 | 
  9 | mod display {
 10 |     use super::*;
 11 | 
 12 |     #[test]
 13 |     fn display1() -> Result<(), rsip::Error> {
 14 |         use rsip::headers::auth;
 15 | 
 16 |         assert_eq!(
 17 |             format!(
 18 |                 "{}",
 19 |                 AuthenticationInfo {
 20 |                     nextnonce: "7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v".into(),
 21 |                     qop: Some(auth::AuthQop::Auth {
 22 |                         cnonce: "f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ".into(),
 23 |                         nc: 1
 24 |                     }),
 25 |                     rspauth: Some("8ca523f5e9506fed4657c9700eebdbec".into()),
 26 |                 }
 27 |             ),
 28 |             String::from(concat!(
 29 |                 "nextnonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\", ",
 30 |                 "rspauth=\"8ca523f5e9506fed4657c9700eebdbec\", ",
 31 |                 "qop=\"auth\", ",
 32 |                 "nc=00000001, ",
 33 |                 "cnonce=\"f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ\""
 34 |             ))
 35 |         );
 36 | 
 37 |         Ok(())
 38 |     }
 39 | 
 40 |     #[test]
 41 |     fn display2() -> Result<(), rsip::Error> {
 42 |         assert_eq!(
 43 |             format!(
 44 |                 "{}",
 45 |                 AuthenticationInfo {
 46 |                     nextnonce: "7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v".into(),
 47 |                     qop: None,
 48 |                     rspauth: Some("8ca523f5e9506fed4657c9700eebdbec".into()),
 49 |                 }
 50 |             ),
 51 |             String::from(concat!(
 52 |                 "nextnonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\", ",
 53 |                 "rspauth=\"8ca523f5e9506fed4657c9700eebdbec\"",
 54 |             ))
 55 |         );
 56 | 
 57 |         Ok(())
 58 |     }
 59 | }
 60 | 
 61 | mod try_from_tokenizer {
 62 |     use super::*;
 63 | 
 64 |     #[test]
 65 |     fn try_from1() {
 66 |         assert_eq!(
 67 |             Tokenizer {
 68 |                 params: vec![
 69 |                     ("nextnonce", "ea9c8e88df84f1cec4341ae6cbe5a359"),
 70 |                     ("rspauth", "dfe56131d1958046689d83306477ecc"),
 71 |                 ],
 72 |             }
 73 |             .try_into(),
 74 |             Ok(AuthenticationInfo {
 75 |                 nextnonce: "ea9c8e88df84f1cec4341ae6cbe5a359".into(),
 76 |                 rspauth: Some("dfe56131d1958046689d83306477ecc".into()),
 77 |                 qop: None
 78 |             })
 79 |         );
 80 |     }
 81 | 
 82 |     #[test]
 83 |     fn try_from2() {
 84 |         assert_eq!(
 85 |             Tokenizer {
 86 |                 params: vec![
 87 |                     ("nextnonce", "ea9c8e88df84f1cec4341ae6cbe5a359"),
 88 |                     ("rspauth", "dfe56131d1958046689d83306477ecc"),
 89 |                     ("qop", "auth"),
 90 |                     ("cnonce", "0a4f113b"),
 91 |                     ("nc", "00000001")
 92 |                 ],
 93 |             }
 94 |             .try_into(),
 95 |             Ok(AuthenticationInfo {
 96 |                 nextnonce: "ea9c8e88df84f1cec4341ae6cbe5a359".into(),
 97 |                 rspauth: Some("dfe56131d1958046689d83306477ecc".into()),
 98 |                 qop: Some(AuthQop::Auth {
 99 |                     cnonce: "0a4f113b".into(),
100 |                     nc: 1
101 |                 })
102 |             })
103 |         );
104 |     }
105 | }
106 | 


--------------------------------------------------------------------------------
/tests/headers/authorization/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod typed;
2 | 
3 | use rsip::headers::Authorization;
4 | 
5 | validate_untyped_header_trait!(Authorization);
6 | validate_to_typed_header_trait!(Authorization);
7 | 


--------------------------------------------------------------------------------
/tests/headers/call_info/mod.rs:
--------------------------------------------------------------------------------
1 | #[cfg(feature = "test-utils")]
2 | pub mod typed;
3 | 
4 | use rsip::headers::CallInfo;
5 | 
6 | validate_untyped_header_trait!(CallInfo);
7 | validate_to_typed_header_trait!(CallInfo);
8 | 


--------------------------------------------------------------------------------
/tests/headers/call_info/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::{
 2 |     common::uri::UriWithParamsList,
 3 |     headers::typed::{tokenizers::UriWithParamsListTokenizer, CallInfo},
 4 | };
 5 | use std::convert::TryInto;
 6 | use testing_utils::Randomize;
 7 | 
 8 | validate_typed_header_trait!(CallInfo);
 9 | 
10 | mod display {
11 |     use super::*;
12 | 
13 |     #[test]
14 |     fn display1() {
15 |         let uri_with_params_list = UriWithParamsList::random();
16 |         assert_eq!(
17 |             CallInfo(uri_with_params_list.clone()).to_string(),
18 |             uri_with_params_list.to_string()
19 |         );
20 |     }
21 | }
22 | 
23 | mod try_from_tokenizer {
24 |     use super::*;
25 | 
26 |     #[test]
27 |     fn try_from_1() -> Result<(), rsip::Error> {
28 |         let uri_with_params_list = UriWithParamsList::random();
29 |         let uri_with_params_list_raw = uri_with_params_list.to_string();
30 |         let tokenizer = UriWithParamsListTokenizer::tokenize(&uri_with_params_list_raw)
31 |             .unwrap()
32 |             .1;
33 | 
34 |         assert_eq!(tokenizer.try_into(), Ok(CallInfo(uri_with_params_list)));
35 | 
36 |         Ok(())
37 |     }
38 | }
39 | 


--------------------------------------------------------------------------------
/tests/headers/contact/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod typed;
2 | 
3 | use rsip::headers::Contact;
4 | 
5 | validate_untyped_header_trait!(Contact);
6 | validate_to_typed_header_trait!(Contact);
7 | 


--------------------------------------------------------------------------------
/tests/headers/contact/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::{
 2 |     common::uri,
 3 |     headers::typed::{contact::Tokenizer, Contact},
 4 | };
 5 | use std::convert::{TryFrom, TryInto};
 6 | 
 7 | validate_typed_header_trait!(Contact);
 8 | 
 9 | mod display {
10 |     use super::*;
11 | 
12 |     #[test]
13 |     fn display1() -> Result<(), rsip::Error> {
14 |         assert_eq!(
15 |             format!(
16 |                 "{}",
17 |                 Contact {
18 |                     display_name: Some("Alice".into()),
19 |                     uri: uri::Uri {
20 |                         scheme: Some(uri::Scheme::Sip),
21 |                         auth: Some(uri::Auth {
22 |                             user: "alice".into(),
23 |                             password: None
24 |                         }),
25 |                         host_with_port: uri::HostWithPort::try_from("atlanta.example.com")?,
26 |                         params: vec![],
27 |                         headers: vec![].into()
28 |                     },
29 |                     params: vec![uri::Param::Tag(uri::param::Tag::new("9fxced76sl"))]
30 |                 }
31 |             ),
32 |             String::from("Alice <sip:alice@atlanta.example.com>;tag=9fxced76sl")
33 |         );
34 | 
35 |         Ok(())
36 |     }
37 | }
38 | 
39 | mod try_from_tokenizer {
40 |     use super::*;
41 | 
42 |     #[test]
43 |     fn try_from_1() -> Result<(), rsip::Error> {
44 |         assert_eq!(
45 |             Tokenizer {
46 |                 display_name: Some("Alice"),
47 |                 uri: uri::Tokenizer {
48 |                     scheme: Some("sip".into()),
49 |                     auth: Some(uri::auth::Tokenizer::from(("alice", None,))),
50 |                     host_with_port: ("atlanta.example.com", None).into(),
51 |                     params: vec![],
52 |                     headers: None,
53 |                     ..Default::default()
54 |                 },
55 |                 params: vec![("tag", Some("9fxced76sl")).into()],
56 |             }
57 |             .try_into(),
58 |             Ok(Contact {
59 |                 display_name: Some("Alice".into()),
60 |                 uri: uri::Uri {
61 |                     scheme: Some(uri::Scheme::Sip),
62 |                     auth: Some(uri::Auth {
63 |                         user: "alice".into(),
64 |                         password: None
65 |                     }),
66 |                     host_with_port: uri::HostWithPort::try_from("atlanta.example.com")?,
67 |                     params: vec![],
68 |                     headers: vec![].into()
69 |                 },
70 |                 params: vec![uri::Param::Tag(uri::param::Tag::new("9fxced76sl"))]
71 |             })
72 |         );
73 | 
74 |         Ok(())
75 |     }
76 | }
77 | 


--------------------------------------------------------------------------------
/tests/headers/content_disposition/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod typed;
2 | 
3 | use rsip::headers::ContentDisposition;
4 | 
5 | validate_untyped_header_trait!(ContentDisposition);
6 | validate_to_typed_header_trait!(ContentDisposition);
7 | 


--------------------------------------------------------------------------------
/tests/headers/content_disposition/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::headers::typed::{
 2 |     content_disposition::{DisplayType, Tokenizer},
 3 |     ContentDisposition,
 4 | };
 5 | use std::convert::TryInto;
 6 | 
 7 | validate_typed_header_trait!(ContentDisposition);
 8 | 
 9 | mod display {
10 |     use super::*;
11 | 
12 |     #[test]
13 |     fn display1() {
14 |         assert_eq!(
15 |             ContentDisposition {
16 |                 display_type: DisplayType::Session,
17 |                 display_params: vec![]
18 |             }
19 |             .to_string(),
20 |             String::from(concat!("session",))
21 |         );
22 |     }
23 | 
24 |     #[test]
25 |     fn display2() {
26 |         assert_eq!(
27 |             ContentDisposition {
28 |                 display_type: DisplayType::Other("attachment".into()),
29 |                 display_params: vec![
30 |                     ("filename", "smime.p7s").into(),
31 |                     ("handling", "required").into()
32 |                 ]
33 |             }
34 |             .to_string(),
35 |             String::from(concat!("attachment; filename=smime.p7s; handling=required"))
36 |         );
37 |     }
38 | }
39 | 
40 | mod try_from_tokenizer {
41 |     use super::*;
42 | 
43 |     #[test]
44 |     fn try_from_1() -> Result<(), rsip::Error> {
45 |         assert_eq!(
46 |             Tokenizer {
47 |                 name: "attachment",
48 |                 params: vec![("filename", "smime.p7s"), ("handling", "required")]
49 |             }
50 |             .try_into(),
51 |             Ok(ContentDisposition {
52 |                 display_type: DisplayType::Other("attachment".into()),
53 |                 display_params: vec![
54 |                     ("filename", "smime.p7s").into(),
55 |                     ("handling", "required").into()
56 |                 ]
57 |             })
58 |         );
59 | 
60 |         Ok(())
61 |     }
62 | }
63 | 


--------------------------------------------------------------------------------
/tests/headers/content_length/mod.rs:
--------------------------------------------------------------------------------
1 | use rsip::headers::*;
2 | 
3 | validate_untyped_header_trait!(ContentLength);
4 | 


--------------------------------------------------------------------------------
/tests/headers/content_type/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod typed;
2 | 
3 | use rsip::headers::ContentType;
4 | 
5 | validate_untyped_header_trait!(ContentType);
6 | validate_to_typed_header_trait!(ContentType);
7 | 


--------------------------------------------------------------------------------
/tests/headers/content_type/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::headers::typed::{tokenizers::NameParamsTokenizer, ContentType, MediaType};
 2 | use std::convert::TryInto;
 3 | 
 4 | validate_typed_header_trait!(ContentType);
 5 | 
 6 | mod display {
 7 |     use super::*;
 8 | 
 9 |     #[test]
10 |     fn display1() {
11 |         assert_eq!(
12 |             ContentType(MediaType::Sdp(vec![])).to_string(),
13 |             String::from("application/sdp")
14 |         );
15 |     }
16 | 
17 |     #[test]
18 |     fn display2() {
19 |         assert_eq!(
20 |             ContentType(MediaType::Sdp(vec![
21 |                 ("charset", "ISO-8859-4").into(),
22 |                 ("foo", "bar").into()
23 |             ]))
24 |             .to_string(),
25 |             String::from("application/sdp; charset=ISO-8859-4; foo=bar")
26 |         );
27 |     }
28 | 
29 |     #[test]
30 |     fn display3() {
31 |         assert_eq!(
32 |             ContentType(MediaType::Other("application/json".into(), vec![])).to_string(),
33 |             String::from("application/json")
34 |         );
35 |     }
36 | 
37 |     #[test]
38 |     fn display4() {
39 |         assert_eq!(
40 |             ContentType(MediaType::Other(
41 |                 "application/json".into(),
42 |                 vec![("charset", "ISO-8859-4").into(), ("foo", "bar").into()]
43 |             ))
44 |             .to_string(),
45 |             String::from("application/json; charset=ISO-8859-4; foo=bar")
46 |         );
47 |     }
48 | }
49 | 
50 | mod try_from_tokenizer {
51 |     use super::*;
52 | 
53 |     #[test]
54 |     fn try_from_1() {
55 |         assert_eq!(
56 |             NameParamsTokenizer {
57 |                 name: "application/sdp",
58 |                 params: vec![("charset", "ISO-8859-4")]
59 |             }
60 |             .try_into(),
61 |             Ok(ContentType(MediaType::Sdp(vec![
62 |                 ("charset", "ISO-8859-4").into(),
63 |             ])))
64 |         );
65 |     }
66 | }
67 | 


--------------------------------------------------------------------------------
/tests/headers/cseq/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod tokenizer;
2 | pub mod typed;
3 | 
4 | use rsip::headers::CSeq;
5 | 
6 | validate_untyped_header_trait!(CSeq);
7 | validate_to_typed_header_trait!(CSeq);
8 | 


--------------------------------------------------------------------------------
/tests/headers/cseq/tokenizer.rs:
--------------------------------------------------------------------------------
 1 | use rsip::headers::typed::{cseq::Tokenizer, Tokenize};
 2 | 
 3 | #[test]
 4 | fn tokenizer1() {
 5 |     assert_eq!(
 6 |         Tokenize::tokenize("123  INVITE"),
 7 |         Ok(Tokenizer {
 8 |             seq: "123",
 9 |             method: "INVITE"
10 |         })
11 |     );
12 | }
13 | 


--------------------------------------------------------------------------------
/tests/headers/cseq/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::{
 2 |     common::Method,
 3 |     headers::typed::{cseq::Tokenizer, CSeq},
 4 | };
 5 | use std::convert::TryInto;
 6 | 
 7 | validate_typed_header_trait!(CSeq);
 8 | 
 9 | mod try_from_tokenizer {
10 |     use super::*;
11 | 
12 |     #[test]
13 |     fn try_from1() {
14 |         assert_eq!(
15 |             Tokenizer {
16 |                 seq: "123",
17 |                 method: "INVITE"
18 |             }
19 |             .try_into(),
20 |             Ok(CSeq {
21 |                 seq: 123,
22 |                 method: Method::Invite
23 |             })
24 |         );
25 |     }
26 | }
27 | 


--------------------------------------------------------------------------------
/tests/headers/error_info/mod.rs:
--------------------------------------------------------------------------------
1 | #[cfg(feature = "test-utils")]
2 | pub mod typed;
3 | 
4 | use rsip::headers::ErrorInfo;
5 | 
6 | validate_untyped_header_trait!(ErrorInfo);
7 | validate_to_typed_header_trait!(ErrorInfo);
8 | 


--------------------------------------------------------------------------------
/tests/headers/error_info/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::{
 2 |     common::uri::UriWithParamsList,
 3 |     headers::typed::{tokenizers::UriWithParamsListTokenizer, ErrorInfo},
 4 | };
 5 | use std::convert::TryInto;
 6 | use testing_utils::Randomize;
 7 | 
 8 | validate_typed_header_trait!(ErrorInfo);
 9 | 
10 | mod display {
11 |     use super::*;
12 | 
13 |     #[test]
14 |     fn display1() {
15 |         let uri_with_params_list = UriWithParamsList::random();
16 |         assert_eq!(
17 |             ErrorInfo(uri_with_params_list.clone()).to_string(),
18 |             uri_with_params_list.to_string()
19 |         );
20 |     }
21 | }
22 | 
23 | mod try_from_tokenizer {
24 |     use super::*;
25 | 
26 |     #[test]
27 |     fn try_from_1() -> Result<(), rsip::Error> {
28 |         let uri_with_params_list = UriWithParamsList::random();
29 |         let uri_with_params_list_raw = uri_with_params_list.to_string();
30 |         let tokenizer = UriWithParamsListTokenizer::tokenize(&uri_with_params_list_raw)
31 |             .unwrap()
32 |             .1;
33 | 
34 |         assert_eq!(tokenizer.try_into(), Ok(ErrorInfo(uri_with_params_list)));
35 | 
36 |         Ok(())
37 |     }
38 | }
39 | 


--------------------------------------------------------------------------------
/tests/headers/from/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod typed;
2 | 
3 | //use rsip::headers::{typed, From, UntypedHeader, ToTypedHeader};
4 | use rsip::headers::From;
5 | 
6 | validate_untyped_header_trait!(From);
7 | validate_to_typed_header_trait!(From);
8 | 


--------------------------------------------------------------------------------
/tests/headers/from/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::{
 2 |     common::uri,
 3 |     headers::typed::{from::Tokenizer, From},
 4 | };
 5 | use std::convert::{TryFrom, TryInto};
 6 | 
 7 | validate_typed_header_trait!(From);
 8 | 
 9 | mod display {
10 |     use super::*;
11 | 
12 |     #[test]
13 |     fn display1() -> Result<(), rsip::Error> {
14 |         assert_eq!(
15 |             format!(
16 |                 "{}",
17 |                 From {
18 |                     display_name: Some("Alice".into()),
19 |                     uri: uri::Uri {
20 |                         scheme: Some(uri::Scheme::Sip),
21 |                         auth: Some(uri::Auth {
22 |                             user: "alice".into(),
23 |                             password: None
24 |                         }),
25 |                         host_with_port: uri::HostWithPort::try_from("atlanta.example.com")?,
26 |                         params: vec![],
27 |                         headers: vec![].into()
28 |                     },
29 |                     params: vec![uri::Param::Tag(uri::param::Tag::new("9fxced76sl"))]
30 |                 }
31 |             ),
32 |             String::from("Alice <sip:alice@atlanta.example.com>;tag=9fxced76sl")
33 |         );
34 | 
35 |         Ok(())
36 |     }
37 | }
38 | 
39 | mod try_from_tokenizer {
40 |     use super::*;
41 | 
42 |     #[test]
43 |     fn try_from1() -> Result<(), rsip::Error> {
44 |         assert_eq!(
45 |             Tokenizer {
46 |                 display_name: Some("Alice"),
47 |                 uri: uri::Tokenizer {
48 |                     scheme: Some("sip".into()),
49 |                     auth: Some(uri::auth::Tokenizer::from(("alice", None,))),
50 |                     host_with_port: ("atlanta.example.com", None).into(),
51 |                     params: vec![],
52 |                     headers: None,
53 |                     ..Default::default()
54 |                 },
55 |                 params: vec![("tag", Some("9fxced76sl")).into()],
56 |             }
57 |             .try_into(),
58 |             Ok(From {
59 |                 display_name: Some("Alice".into()),
60 |                 uri: uri::Uri {
61 |                     scheme: Some(uri::Scheme::Sip),
62 |                     auth: Some(uri::Auth {
63 |                         user: "alice".into(),
64 |                         password: None
65 |                     }),
66 |                     host_with_port: uri::HostWithPort::try_from("atlanta.example.com")?,
67 |                     params: vec![],
68 |                     headers: vec![].into()
69 |                 },
70 |                 params: vec![uri::Param::Tag(uri::param::Tag::new("9fxced76sl"))]
71 |             })
72 |         );
73 | 
74 |         Ok(())
75 |     }
76 | }
77 | 


--------------------------------------------------------------------------------
/tests/headers/in_reply_to/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod typed;
2 | 
3 | use rsip::headers::InReplyTo;
4 | 
5 | validate_untyped_header_trait!(InReplyTo);
6 | validate_to_typed_header_trait!(InReplyTo);
7 | 


--------------------------------------------------------------------------------
/tests/headers/in_reply_to/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::headers::typed::{tokenizers::TokenListTokenizer, InReplyTo, Tokenize};
 2 | use std::convert::TryInto;
 3 | //use testing_utils::Randomize;
 4 | 
 5 | validate_typed_header_trait!(InReplyTo);
 6 | 
 7 | mod display {
 8 |     use super::*;
 9 | 
10 |     #[test]
11 |     fn display1() {
12 |         assert_eq!(
13 |             InReplyTo(vec![
14 |                 "70710@saturn.bell-tel.com".into(),
15 |                 "17320@saturn.bell-tel.com".into()
16 |             ])
17 |             .to_string(),
18 |             "70710@saturn.bell-tel.com, 17320@saturn.bell-tel.com".to_string()
19 |         );
20 |     }
21 | }
22 | 
23 | mod try_from_tokenizer {
24 |     use super::*;
25 | 
26 |     #[test]
27 |     fn try_from_1() -> Result<(), rsip::Error> {
28 |         let tokenizer =
29 |             TokenListTokenizer::tokenize(&"70710@saturn.bell-tel.com, 17320@saturn.bell-tel.com")
30 |                 .unwrap();
31 | 
32 |         assert_eq!(
33 |             tokenizer.try_into(),
34 |             Ok(InReplyTo(vec![
35 |                 "70710@saturn.bell-tel.com".into(),
36 |                 "17320@saturn.bell-tel.com".into()
37 |             ]))
38 |         );
39 | 
40 |         Ok(())
41 |     }
42 | }
43 | 


--------------------------------------------------------------------------------
/tests/headers/max_forwards/mod.rs:
--------------------------------------------------------------------------------
1 | use rsip::headers::*;
2 | 
3 | validate_untyped_header_trait!(MaxForwards);
4 | 


--------------------------------------------------------------------------------
/tests/headers/media_type.rs:
--------------------------------------------------------------------------------
 1 | use rsip::headers::typed::{media_type::Tokenizer, MediaType};
 2 | use std::convert::TryInto;
 3 | 
 4 | mod display {
 5 |     use super::*;
 6 | 
 7 |     #[test]
 8 |     fn display1() {
 9 |         assert_eq!(
10 |             MediaType::Sdp(vec![]).to_string(),
11 |             String::from("application/sdp")
12 |         );
13 |     }
14 | 
15 |     #[test]
16 |     fn display2() {
17 |         assert_eq!(
18 |             MediaType::Sdp(vec![
19 |                 ("charset", "ISO-8859-4").into(),
20 |                 ("foo", "bar").into()
21 |             ])
22 |             .to_string(),
23 |             String::from("application/sdp; charset=ISO-8859-4; foo=bar")
24 |         );
25 |     }
26 | 
27 |     #[test]
28 |     fn display3() {
29 |         assert_eq!(
30 |             MediaType::Other("application/json".into(), vec![]).to_string(),
31 |             String::from("application/json")
32 |         );
33 |     }
34 | 
35 |     #[test]
36 |     fn display4() {
37 |         assert_eq!(
38 |             MediaType::Other(
39 |                 "application/json".into(),
40 |                 vec![("charset", "ISO-8859-4").into(), ("foo", "bar").into()]
41 |             )
42 |             .to_string(),
43 |             String::from("application/json; charset=ISO-8859-4; foo=bar")
44 |         );
45 |     }
46 | }
47 | 
48 | mod try_from_tokenizer {
49 |     use super::*;
50 | 
51 |     #[test]
52 |     fn try_from_1() {
53 |         assert_eq!(
54 |             Tokenizer {
55 |                 name: "application/sdp",
56 |                 params: vec![("charset", "ISO-8859-4")]
57 |             }
58 |             .try_into(),
59 |             Ok(MediaType::Sdp(vec![("charset", "ISO-8859-4").into(),]))
60 |         );
61 |     }
62 | }
63 | 


--------------------------------------------------------------------------------
/tests/headers/mod.rs:
--------------------------------------------------------------------------------
 1 | use rsip::headers::UntypedHeader;
 2 | 
 3 | pub mod accept;
 4 | pub mod alert_info;
 5 | pub mod allow;
 6 | pub mod auth;
 7 | pub mod authentication_info;
 8 | pub mod authorization;
 9 | pub mod call_info;
10 | pub mod contact;
11 | pub mod content_disposition;
12 | pub mod content_length;
13 | pub mod content_type;
14 | pub mod cseq;
15 | pub mod error_info;
16 | pub mod from;
17 | pub mod in_reply_to;
18 | pub mod max_forwards;
19 | pub mod media_type;
20 | pub mod priority;
21 | pub mod proxy_authenticate;
22 | pub mod record_route;
23 | pub mod reply_to;
24 | pub mod to;
25 | pub mod tokenizers;
26 | pub mod via;
27 | pub mod warning;
28 | pub mod www_authenticate;
29 | 
30 | use rsip::headers::{header::Tokenizer, Accept, Header};
31 | 
32 | mod display {
33 |     use super::*;
34 | 
35 |     #[test]
36 |     fn display1() {
37 |         assert_eq!(
38 |             Header::Accept(Accept::new("REGISTER, INVITE")).to_string(),
39 |             String::from("Accept: REGISTER, INVITE")
40 |         );
41 |     }
42 | 
43 |     #[test]
44 |     fn display2() {
45 |         assert_eq!(
46 |             Header::Other("X-Forward".into(), "202.45.213.14".into()).to_string(),
47 |             String::from("X-Forward: 202.45.213.14")
48 |         );
49 |     }
50 | }
51 | 
52 | mod tokenizer {
53 |     use super::*;
54 | 
55 |     #[test]
56 |     fn tokenizer1() {
57 |         assert_eq!(
58 |             Tokenizer::tokenize(b"Accept: REGISTER, INVITE\r\n something"),
59 |             Ok((
60 |                 " something".as_bytes(),
61 |                 Tokenizer {
62 |                     name: "Accept".as_bytes(),
63 |                     value: "REGISTER, INVITE".as_bytes()
64 |                 }
65 |             )),
66 |         );
67 |     }
68 | }
69 | 


--------------------------------------------------------------------------------
/tests/headers/priority/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod typed;
2 | 
3 | use rsip::headers::Priority;
4 | 
5 | validate_untyped_header_trait!(Priority);
6 | validate_to_typed_header_trait!(Priority);
7 | 


--------------------------------------------------------------------------------
/tests/headers/priority/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::headers::typed::{tokenizers::ValueTokenizer, Priority, Tokenize};
 2 | use std::convert::TryInto;
 3 | //use testing_utils::Randomize;
 4 | 
 5 | validate_typed_header_trait!(Priority);
 6 | 
 7 | mod display {
 8 |     use super::*;
 9 | 
10 |     #[test]
11 |     fn display1() {
12 |         assert_eq!(Priority::NonUrgent.to_string(), "non-urgent");
13 |     }
14 | 
15 |     #[test]
16 |     fn display2() {
17 |         assert_eq!(Priority::Other("FooBar".into()).to_string(), "FooBar");
18 |     }
19 | }
20 | 
21 | mod try_from_tokenizer {
22 |     use super::*;
23 | 
24 |     #[test]
25 |     fn try_from_1() -> Result<(), rsip::Error> {
26 |         let tokenizer = ValueTokenizer::tokenize("emergency").unwrap();
27 | 
28 |         assert_eq!(tokenizer.try_into(), Ok(Priority::Emergency));
29 | 
30 |         Ok(())
31 |     }
32 | 
33 |     #[test]
34 |     fn try_from_2() -> Result<(), rsip::Error> {
35 |         let tokenizer = ValueTokenizer::tokenize("FooBar").unwrap();
36 | 
37 |         assert_eq!(tokenizer.try_into(), Ok(Priority::Other("FooBar".into())));
38 | 
39 |         Ok(())
40 |     }
41 | }
42 | 


--------------------------------------------------------------------------------
/tests/headers/proxy_authenticate/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod typed;
2 | 
3 | use rsip::headers::ProxyAuthenticate;
4 | 
5 | validate_untyped_header_trait!(ProxyAuthenticate);
6 | validate_to_typed_header_trait!(ProxyAuthenticate);
7 | 


--------------------------------------------------------------------------------
/tests/headers/proxy_authenticate/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::headers::{
 2 |     auth,
 3 |     typed::{proxy_authenticate::Tokenizer, ProxyAuthenticate, WwwAuthenticate},
 4 | };
 5 | use std::convert::TryInto;
 6 | 
 7 | validate_typed_header_trait!(ProxyAuthenticate);
 8 | 
 9 | #[test]
10 | fn display() -> Result<(), rsip::Error> {
11 |     use rsip::headers::auth;
12 | 
13 |     assert_eq!(
14 |         format!(
15 |             "{}",
16 |             ProxyAuthenticate(WwwAuthenticate {
17 |                 scheme: auth::Scheme::Digest,
18 |                 realm: "http-auth@example.org".into(),
19 |                 nonce: "7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v".into(),
20 |                 algorithm: Some(auth::Algorithm::Sha256),
21 |                 qop: Some(auth::Qop::Auth),
22 |                 opaque: Some("FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS".into()),
23 |                 domain: None,
24 |                 stale: None,
25 |                 charset: None
26 |             })
27 |         ),
28 |         String::from(concat!(
29 |             "Digest ",
30 |             "realm=\"http-auth@example.org\", ",
31 |             "nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\", ",
32 |             "opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\", ",
33 |             "algorithm=SHA256, ",
34 |             "qop=\"auth\"",
35 |         ))
36 |     );
37 | 
38 |     Ok(())
39 | }
40 | 
41 | #[test]
42 | fn from_tokenizer() {
43 |     assert_eq!(
44 |         Tokenizer {
45 |             scheme: "Digest".into(),
46 |             params: vec![
47 |                 ("realm", "testrealm@host.com"),
48 |                 ("qop", "auth"),
49 |                 ("nonce", "dcd98b7102dd2f0e8b11d0f600bfb0c093"),
50 |                 ("opaque", "5ccc069c403ebaf9f0171e9517f40e41"),
51 |             ],
52 |         }
53 |         .try_into(),
54 |         Ok(ProxyAuthenticate(WwwAuthenticate {
55 |             scheme: auth::Scheme::Digest,
56 |             realm: "testrealm@host.com".into(),
57 |             domain: None,
58 |             nonce: "dcd98b7102dd2f0e8b11d0f600bfb0c093".into(),
59 |             opaque: Some("5ccc069c403ebaf9f0171e9517f40e41".into()),
60 |             stale: None,
61 |             algorithm: None,
62 |             qop: Some("auth".try_into().expect("auth qop")),
63 |             charset: None
64 |         }))
65 |     );
66 | }
67 | 


--------------------------------------------------------------------------------
/tests/headers/proxy_authorization/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod typed;
2 | 
3 | use rsip::headers::ProxyAuthorization;
4 | 
5 | validate_untyped_header_trait!(ProxyAuthorization);
6 | validate_to_typed_header_trait!(ProxyAuthorization);
7 | 


--------------------------------------------------------------------------------
/tests/headers/record_route/mod.rs:
--------------------------------------------------------------------------------
1 | #[cfg(feature = "test-utils")]
2 | pub mod typed;
3 | 
4 | use rsip::headers::RecordRoute;
5 | 
6 | validate_untyped_header_trait!(RecordRoute);
7 | validate_to_typed_header_trait!(RecordRoute);
8 | 


--------------------------------------------------------------------------------
/tests/headers/record_route/typed.rs:
--------------------------------------------------------------------------------
  1 | use rsip::{
  2 |     common::uri::{Param, Scheme, Uri, UriWithParams, UriWithParamsList},
  3 |     headers::typed::{tokenizers::UriWithParamsListTokenizer, RecordRoute},
  4 | };
  5 | use std::convert::TryInto;
  6 | use testing_utils::Randomize;
  7 | 
  8 | validate_typed_header_trait!(RecordRoute);
  9 | 
 10 | mod display {
 11 |     use super::*;
 12 | 
 13 |     #[test]
 14 |     fn display1() {
 15 |         let uri_with_params_list = UriWithParamsList::random();
 16 |         assert_eq!(
 17 |             RecordRoute(uri_with_params_list.clone()).to_string(),
 18 |             uri_with_params_list.to_string()
 19 |         );
 20 |     }
 21 | 
 22 |     #[test]
 23 |     fn display2() {
 24 |         let uri_with_params_list = vec![
 25 |             UriWithParams {
 26 |                 uri: Uri {
 27 |                     scheme: Some(Scheme::Sip),
 28 |                     host_with_port: "server10.biloxi.com".try_into().unwrap(),
 29 |                     params: vec![Param::Lr],
 30 |                     ..Default::default()
 31 |                 },
 32 |                 ..Default::default()
 33 |             },
 34 |             UriWithParams {
 35 |                 uri: Uri {
 36 |                     scheme: Some(Scheme::Sip),
 37 |                     host_with_port: "bigbox3.site3.atlanta.com".try_into().unwrap(),
 38 |                     params: vec![Param::Lr],
 39 |                     ..Default::default()
 40 |                 },
 41 |                 ..Default::default()
 42 |             },
 43 |         ]
 44 |         .into();
 45 | 
 46 |         assert_eq!(
 47 |             RecordRoute(uri_with_params_list).to_string(),
 48 |             "<sip:server10.biloxi.com;lr>,<sip:bigbox3.site3.atlanta.com;lr>"
 49 |         );
 50 |     }
 51 | }
 52 | 
 53 | mod try_from_tokenizer {
 54 |     use super::*;
 55 | 
 56 |     #[test]
 57 |     fn try_from_1() -> Result<(), rsip::Error> {
 58 |         let uri_with_params_list = UriWithParamsList::random();
 59 |         let uri_with_params_list_raw = uri_with_params_list.to_string();
 60 |         let tokenizer = UriWithParamsListTokenizer::tokenize(&uri_with_params_list_raw)
 61 |             .unwrap()
 62 |             .1;
 63 | 
 64 |         assert_eq!(tokenizer.try_into(), Ok(RecordRoute(uri_with_params_list)));
 65 | 
 66 |         Ok(())
 67 |     }
 68 | 
 69 |     #[test]
 70 |     fn try_from_2() -> Result<(), rsip::Error> {
 71 |         let uris = "<sip:server10.biloxi.com;lr>,<sip:bigbox3.site3.atlanta.com;lr>";
 72 |         let uri_with_params_list = vec![
 73 |             UriWithParams {
 74 |                 uri: Uri {
 75 |                     scheme: Some(Scheme::Sip),
 76 |                     host_with_port: "server10.biloxi.com".try_into().unwrap(),
 77 |                     params: vec![Param::Lr],
 78 |                     ..Default::default()
 79 |                 },
 80 |                 ..Default::default()
 81 |             },
 82 |             UriWithParams {
 83 |                 uri: Uri {
 84 |                     scheme: Some(Scheme::Sip),
 85 |                     host_with_port: "bigbox3.site3.atlanta.com".try_into().unwrap(),
 86 |                     params: vec![Param::Lr],
 87 |                     ..Default::default()
 88 |                 },
 89 |                 ..Default::default()
 90 |             },
 91 |         ]
 92 |         .into();
 93 | 
 94 |         let tokenizer = UriWithParamsListTokenizer::tokenize(&uris).unwrap().1;
 95 | 
 96 |         assert_eq!(tokenizer.try_into(), Ok(RecordRoute(uri_with_params_list)));
 97 | 
 98 |         Ok(())
 99 |     }
100 | }
101 | 


--------------------------------------------------------------------------------
/tests/headers/reply_to/mod.rs:
--------------------------------------------------------------------------------
1 | #[cfg(feature = "test-utils")]
2 | pub mod typed;
3 | 
4 | use rsip::headers::ReplyTo;
5 | 
6 | validate_untyped_header_trait!(ReplyTo);
7 | validate_to_typed_header_trait!(ReplyTo);
8 | 


--------------------------------------------------------------------------------
/tests/headers/reply_to/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::{
 2 |     common::uri::UriWithParams,
 3 |     headers::typed::{tokenizers::UriWithParamsTokenizer, ReplyTo},
 4 | };
 5 | use std::convert::TryInto;
 6 | use testing_utils::Randomize;
 7 | 
 8 | validate_typed_header_trait!(ReplyTo);
 9 | 
10 | mod display {
11 |     use super::*;
12 | 
13 |     #[test]
14 |     fn display1() {
15 |         let uri_with_params = UriWithParams::random();
16 |         assert_eq!(
17 |             ReplyTo(uri_with_params.clone()).to_string(),
18 |             uri_with_params.to_string()
19 |         );
20 |     }
21 | }
22 | 
23 | mod try_from_tokenizer {
24 |     use super::*;
25 | 
26 |     #[test]
27 |     fn try_from_1() -> Result<(), rsip::Error> {
28 |         let uri_with_params = UriWithParams::random();
29 |         let uri_with_params_raw = uri_with_params.to_string();
30 |         let tokenizer = UriWithParamsTokenizer::tokenize(&uri_with_params_raw)
31 |             .unwrap()
32 |             .1;
33 | 
34 |         assert_eq!(tokenizer.try_into(), Ok(ReplyTo(uri_with_params)));
35 | 
36 |         Ok(())
37 |     }
38 | }
39 | 


--------------------------------------------------------------------------------
/tests/headers/route/mod.rs:
--------------------------------------------------------------------------------
1 | #[cfg(feature = "test-utils")]
2 | pub mod typed;
3 | 
4 | use rsip::headers::RecordRoute;
5 | 
6 | validate_untyped_header_trait!(RecordRoute);
7 | validate_to_typed_header_trait!(RecordRoute);
8 | 


--------------------------------------------------------------------------------
/tests/headers/route/typed.rs:
--------------------------------------------------------------------------------
  1 | use rsip::{
  2 |     common::uri::{Param, Scheme, Uri, UriWithParams, UriWithParamsList},
  3 |     headers::typed::{tokenizers::UriWithParamsListTokenizer, Route},
  4 | };
  5 | use std::convert::TryInto;
  6 | use testing_utils::Randomize;
  7 | 
  8 | validate_typed_header_trait!(Route);
  9 | 
 10 | mod display {
 11 |     use super::*;
 12 | 
 13 |     #[test]
 14 |     fn display1() {
 15 |         let uri_with_params_list = UriWithParamsList::random();
 16 |         assert_eq!(
 17 |             Route(uri_with_params_list.clone()).to_string(),
 18 |             uri_with_params_list.to_string()
 19 |         );
 20 |     }
 21 | 
 22 |     #[test]
 23 |     fn display2() {
 24 |         let uri_with_params_list = vec![
 25 |             UriWithParams {
 26 |                 uri: Uri {
 27 |                     scheme: Some(Scheme::Sip),
 28 |                     host_with_port: "server10.biloxi.com".try_into().unwrap(),
 29 |                     params: vec![Param::Lr],
 30 |                     ..Default::default()
 31 |                 },
 32 |                 ..Default::default()
 33 |             },
 34 |             UriWithParams {
 35 |                 uri: Uri {
 36 |                     scheme: Some(Scheme::Sip),
 37 |                     host_with_port: "bigbox3.site3.atlanta.com".try_into().unwrap(),
 38 |                     params: vec![Param::Lr],
 39 |                     ..Default::default()
 40 |                 },
 41 |                 ..Default::default()
 42 |             },
 43 |         ]
 44 |         .into();
 45 | 
 46 |         assert_eq!(
 47 |             Route(uri_with_params_list).to_string(),
 48 |             "<sip:server10.biloxi.com;lr>,<sip:bigbox3.site3.atlanta.com;lr>"
 49 |         );
 50 |     }
 51 | }
 52 | 
 53 | mod try_from_tokenizer {
 54 |     use super::*;
 55 | 
 56 |     #[test]
 57 |     fn try_from_1() -> Result<(), rsip::Error> {
 58 |         let uri_with_params_list = UriWithParamsList::random();
 59 |         let uri_with_params_list_raw = uri_with_params_list.to_string();
 60 |         let tokenizer = UriWithParamsListTokenizer::tokenize(&uri_with_params_list_raw)
 61 |             .unwrap()
 62 |             .1;
 63 | 
 64 |         assert_eq!(tokenizer.try_into(), Ok(Route(uri_with_params_list)));
 65 | 
 66 |         Ok(())
 67 |     }
 68 | 
 69 |     #[test]
 70 |     fn try_from_2() -> Result<(), rsip::Error> {
 71 |         let uris = "<sip:server10.biloxi.com;lr>,<sip:bigbox3.site3.atlanta.com;lr>";
 72 |         let uri_with_params_list = vec![
 73 |             UriWithParams {
 74 |                 uri: Uri {
 75 |                     scheme: Some(Scheme::Sip),
 76 |                     host_with_port: "server10.biloxi.com".try_into().unwrap(),
 77 |                     params: vec![Param::Lr],
 78 |                     ..Default::default()
 79 |                 },
 80 |                 ..Default::default()
 81 |             },
 82 |             UriWithParams {
 83 |                 uri: Uri {
 84 |                     scheme: Some(Scheme::Sip),
 85 |                     host_with_port: "bigbox3.site3.atlanta.com".try_into().unwrap(),
 86 |                     params: vec![Param::Lr],
 87 |                     ..Default::default()
 88 |                 },
 89 |                 ..Default::default()
 90 |             },
 91 |         ]
 92 |         .into();
 93 | 
 94 |         let tokenizer = UriWithParamsListTokenizer::tokenize(&uris).unwrap().1;
 95 | 
 96 |         assert_eq!(tokenizer.try_into(), Ok(Route(uri_with_params_list)));
 97 | 
 98 |         Ok(())
 99 |     }
100 | }
101 | 
102 | 


--------------------------------------------------------------------------------
/tests/headers/to/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod typed;
2 | 
3 | use rsip::headers::To;
4 | 
5 | validate_untyped_header_trait!(To);
6 | validate_to_typed_header_trait!(To);
7 | 


--------------------------------------------------------------------------------
/tests/headers/to/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::{
 2 |     common::uri,
 3 |     headers::typed::{to::Tokenizer, To},
 4 | };
 5 | use std::convert::{TryFrom, TryInto};
 6 | 
 7 | validate_typed_header_trait!(To);
 8 | 
 9 | mod display {
10 |     use super::*;
11 | 
12 |     #[test]
13 |     fn display1() -> Result<(), rsip::Error> {
14 |         assert_eq!(
15 |             format!(
16 |                 "{}",
17 |                 To {
18 |                     display_name: Some("Alice".into()),
19 |                     uri: uri::Uri {
20 |                         scheme: Some(uri::Scheme::Sip),
21 |                         auth: Some(uri::Auth {
22 |                             user: "alice".into(),
23 |                             password: None
24 |                         }),
25 |                         host_with_port: uri::HostWithPort::try_from("atlanta.example.com")?,
26 |                         params: vec![],
27 |                         headers: vec![].into()
28 |                     },
29 |                     params: vec![uri::Param::Tag(uri::param::Tag::new("9fxced76sl"))]
30 |                 }
31 |             ),
32 |             String::from("Alice <sip:alice@atlanta.example.com>;tag=9fxced76sl")
33 |         );
34 | 
35 |         Ok(())
36 |     }
37 | }
38 | 
39 | mod try_from_tokenizer {
40 |     use super::*;
41 | 
42 |     #[test]
43 |     fn try_from_1() -> Result<(), rsip::Error> {
44 |         assert_eq!(
45 |             Tokenizer {
46 |                 display_name: Some("Alice"),
47 |                 uri: uri::Tokenizer {
48 |                     scheme: Some("sip".into()),
49 |                     auth: Some(uri::auth::Tokenizer::from(("alice", None,))),
50 |                     host_with_port: ("atlanta.example.com", None).into(),
51 |                     params: vec![],
52 |                     headers: None,
53 |                     ..Default::default()
54 |                 },
55 |                 params: vec![("tag", Some("9fxced76sl")).into()],
56 |             }
57 |             .try_into(),
58 |             Ok(To {
59 |                 display_name: Some("Alice".into()),
60 |                 uri: uri::Uri {
61 |                     scheme: Some(uri::Scheme::Sip),
62 |                     auth: Some(uri::Auth {
63 |                         user: "alice".into(),
64 |                         password: None
65 |                     }),
66 |                     host_with_port: uri::HostWithPort::try_from("atlanta.example.com")?,
67 |                     params: vec![],
68 |                     headers: vec![].into()
69 |                 },
70 |                 params: vec![uri::Param::Tag(uri::param::Tag::new("9fxced76sl"))]
71 |             })
72 |         );
73 | 
74 |         Ok(())
75 |     }
76 | }
77 | 


--------------------------------------------------------------------------------
/tests/headers/tokenizers/auth.rs:
--------------------------------------------------------------------------------
 1 | use rsip::headers::typed::{tokenizers::AuthTokenizer, Tokenize};
 2 | 
 3 | #[test]
 4 | fn tokenizer1() {
 5 |     assert_eq!(
 6 |         AuthTokenizer::tokenize(concat!(
 7 |             "Digest ",
 8 |             "realm=\"testrealm@host.com\", ",
 9 |             "qop=\"auth,auth-int\", ",
10 |             "nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", ",
11 |             "opaque=\"5ccc069c403ebaf9f0171e9517f40e41\""
12 |         )),
13 |         Ok(AuthTokenizer {
14 |             scheme: "Digest".into(),
15 |             params: vec![
16 |                 ("realm", "testrealm@host.com"),
17 |                 ("qop", "auth,auth-int"),
18 |                 ("nonce", "dcd98b7102dd2f0e8b11d0f600bfb0c093"),
19 |                 ("opaque", "5ccc069c403ebaf9f0171e9517f40e41"),
20 |             ],
21 |         })
22 |     );
23 | }
24 | 
25 | #[test]
26 | fn tokenizer2() {
27 |     //with space in-between in qop values
28 |     assert_eq!(
29 |         AuthTokenizer::tokenize(concat!(
30 |             "Digest ",
31 |             "realm=\"testrealm@host.com\", ",
32 |             "qop=\"auth, auth-int\", ",
33 |             "nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", ",
34 |             "opaque=\"5ccc069c403ebaf9f0171e9517f40e41\""
35 |         )),
36 |         Ok(AuthTokenizer {
37 |             scheme: "Digest".into(),
38 |             params: vec![
39 |                 ("realm", "testrealm@host.com"),
40 |                 ("qop", "auth, auth-int"),
41 |                 ("nonce", "dcd98b7102dd2f0e8b11d0f600bfb0c093"),
42 |                 ("opaque", "5ccc069c403ebaf9f0171e9517f40e41"),
43 |             ],
44 |         })
45 |     );
46 | }
47 | 
48 | #[test]
49 | fn tokenizer3() {
50 |     assert_eq!(
51 |         AuthTokenizer::tokenize(concat!(
52 |             "Digest ",
53 |             "username=\"bob\", ",
54 |             "realm=\"atlanta.example.com\", ",
55 |             "nonce=\"ea9c8e88df84f1cec4341ae6cbe5a359\", ",
56 |             "opaque=\"\", ",
57 |             "uri=\"sips:ss2.biloxi.example.com\", ",
58 |             "response=\"dfe56131d1958046689d83306477ecc\""
59 |         )),
60 |         Ok(AuthTokenizer {
61 |             scheme: "Digest".into(),
62 |             params: vec![
63 |                 ("username", "bob"),
64 |                 ("realm", "atlanta.example.com"),
65 |                 ("nonce", "ea9c8e88df84f1cec4341ae6cbe5a359"),
66 |                 ("opaque", ""),
67 |                 ("uri", "sips:ss2.biloxi.example.com"),
68 |                 ("response", "dfe56131d1958046689d83306477ecc")
69 |             ],
70 |         })
71 |     );
72 | }
73 | 
74 | #[test]
75 | fn tokenizer4() {
76 |     assert_eq!(
77 |         AuthTokenizer::tokenize(concat!(
78 |             "Digest ",
79 |             "username=\"bob\", ",
80 |             "realm=\"atlanta.example.com\", ",
81 |             "nonce=\"ea9c8e88df84f1cec4341ae6cbe5a359\", ",
82 |             "opaque=\"\", ",
83 |             "uri=\"sips:ss2.biloxi.example.com\", ",
84 |             "response=dfe56131d1958046689d83306477ecc"
85 |         )),
86 |         Ok(AuthTokenizer {
87 |             scheme: "Digest".into(),
88 |             params: vec![
89 |                 ("username", "bob"),
90 |                 ("realm", "atlanta.example.com"),
91 |                 ("nonce", "ea9c8e88df84f1cec4341ae6cbe5a359"),
92 |                 ("opaque", ""),
93 |                 ("uri", "sips:ss2.biloxi.example.com"),
94 |                 ("response", "dfe56131d1958046689d83306477ecc")
95 |             ],
96 |         })
97 |     );
98 | }
99 | 


--------------------------------------------------------------------------------
/tests/headers/tokenizers/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod auth;
2 | pub mod display_uri_params;
3 | pub mod name_params;
4 | pub mod name_params_list;
5 | pub mod name_value;
6 | pub mod token_list;
7 | pub mod value;
8 | pub mod warning;
9 | 


--------------------------------------------------------------------------------
/tests/headers/tokenizers/name_params.rs:
--------------------------------------------------------------------------------
 1 | use rsip::headers::typed::{tokenizers::NameParamsTokenizer, Tokenize};
 2 | /*
 3 |  * TODO: fix me, this is green!
 4 | #[test]
 5 | fn tokenizer0() {
 6 |     assert_eq!(
 7 |         NameParamsTokenizer::tokenize(""),
 8 |         Ok(NameParamsTokenizer {
 9 |             name: "",
10 |             params: vec![]
11 |         })
12 |     );
13 | }
14 | */
15 | 
16 | #[test]
17 | fn tokenizer1() {
18 |     assert_eq!(
19 |         NameParamsTokenizer::tokenize("application/sdp"),
20 |         Ok(NameParamsTokenizer {
21 |             name: "application/sdp",
22 |             params: vec![]
23 |         })
24 |     );
25 | }
26 | 
27 | #[test]
28 | fn tokenizer2() {
29 |     assert_eq!(
30 |         NameParamsTokenizer::tokenize("application/sdp; charset=ISO-8859-4"),
31 |         Ok(NameParamsTokenizer {
32 |             name: "application/sdp",
33 |             params: vec![("charset", "ISO-8859-4")]
34 |         })
35 |     );
36 | }
37 | 
38 | #[test]
39 | fn tokenizer3() {
40 |     assert_eq!(
41 |         NameParamsTokenizer::tokenize(
42 |             "application/vnd.api+json; pagination=simple-spec; querying=graphql"
43 |         ),
44 |         Ok(NameParamsTokenizer {
45 |             name: "application/vnd.api+json",
46 |             params: vec![("pagination", "simple-spec"), ("querying", "graphql")]
47 |         })
48 |     );
49 | }
50 | 
51 | #[test]
52 | fn tokenizer4() {
53 |     assert_eq!(
54 |         NameParamsTokenizer::tokenize("attachment; filename=smime.p7s; handling=required"),
55 |         Ok(NameParamsTokenizer {
56 |             name: "attachment",
57 |             params: vec![("filename", "smime.p7s"), ("handling", "required")]
58 |         })
59 |     );
60 | }
61 | 


--------------------------------------------------------------------------------
/tests/headers/tokenizers/name_params_list.rs:
--------------------------------------------------------------------------------
 1 | use rsip::headers::typed::{
 2 |     tokenizers::{NameParamsListTokenizer, NameParamsTokenizer},
 3 |     Tokenize,
 4 | };
 5 | 
 6 | #[test]
 7 | fn tokenizer1() {
 8 |     assert_eq!(
 9 |         NameParamsListTokenizer::tokenize(
10 |             "application/vnd.api+json; pagination=simple-spec; querying=graphql"
11 |         ),
12 |         Ok(NameParamsListTokenizer(vec![NameParamsTokenizer {
13 |             name: "application/vnd.api+json",
14 |             params: vec![("pagination", "simple-spec"), ("querying", "graphql")]
15 |         }]))
16 |     );
17 | }
18 | 
19 | #[test]
20 | fn tokenizer2() {
21 |     assert_eq!(
22 |         NameParamsListTokenizer::tokenize(concat!(
23 |             "application/vnd.api+json; pagination=simple-spec; querying=graphql, ",
24 |             "application/sdp; charset=ISO-8859-4"
25 |         )),
26 |         Ok(NameParamsListTokenizer(vec![
27 |             NameParamsTokenizer {
28 |                 name: "application/vnd.api+json",
29 |                 params: vec![("pagination", "simple-spec"), ("querying", "graphql")]
30 |             },
31 |             NameParamsTokenizer {
32 |                 name: "application/sdp",
33 |                 params: vec![("charset", "ISO-8859-4")]
34 |             }
35 |         ]))
36 |     );
37 | }
38 | 
39 | #[test]
40 | fn tokenizer3() {
41 |     assert_eq!(
42 |         NameParamsListTokenizer::tokenize(concat!(
43 |             "application/vnd.api+json; pagination=simple-spec; querying=graphql,", //without space
44 |             "application/sdp; charset=ISO-8859-4"
45 |         )),
46 |         Ok(NameParamsListTokenizer(vec![
47 |             NameParamsTokenizer {
48 |                 name: "application/vnd.api+json",
49 |                 params: vec![("pagination", "simple-spec"), ("querying", "graphql")]
50 |             },
51 |             NameParamsTokenizer {
52 |                 name: "application/sdp",
53 |                 params: vec![("charset", "ISO-8859-4")]
54 |             }
55 |         ]))
56 |     );
57 | }
58 | 
59 | //taken from RFC3261
60 | #[test]
61 | fn tokenizer4() {
62 |     assert_eq!(
63 |         NameParamsListTokenizer::tokenize(concat!(
64 |             "application/sdp;level=1, ",
65 |             "application/x-private, ",
66 |             "text/html"
67 |         )),
68 |         Ok(NameParamsListTokenizer(vec![
69 |             NameParamsTokenizer {
70 |                 name: "application/sdp",
71 |                 params: vec![("level", "1")]
72 |             },
73 |             NameParamsTokenizer {
74 |                 name: "application/x-private",
75 |                 params: vec![]
76 |             },
77 |             NameParamsTokenizer {
78 |                 name: "text/html",
79 |                 params: vec![]
80 |             }
81 |         ]))
82 |     );
83 | }
84 | 


--------------------------------------------------------------------------------
/tests/headers/tokenizers/name_value.rs:
--------------------------------------------------------------------------------
 1 | use rsip::headers::typed::{tokenizers::NameValueTokenizer, Tokenize};
 2 | 
 3 | #[test]
 4 | fn tokenizer1() {
 5 |     assert_eq!(
 6 |         NameValueTokenizer::tokenize(concat!(
 7 |             "realm=\"testrealm@host.com\", ",
 8 |             "qop=\"auth,auth-int\", ",
 9 |             "nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", ",
10 |             "opaque=\"5ccc069c403ebaf9f0171e9517f40e41\""
11 |         )),
12 |         Ok(NameValueTokenizer {
13 |             params: vec![
14 |                 ("realm", "testrealm@host.com"),
15 |                 ("qop", "auth,auth-int"),
16 |                 ("nonce", "dcd98b7102dd2f0e8b11d0f600bfb0c093"),
17 |                 ("opaque", "5ccc069c403ebaf9f0171e9517f40e41"),
18 |             ]
19 |         })
20 |     );
21 | }
22 | 
23 | #[test]
24 | fn tokenizer2() {
25 |     assert_eq!(
26 |         NameValueTokenizer::tokenize(concat!(
27 |             "foo=1, ",
28 |             "with_quotes=\"1\", ",
29 |             "without_space=\"1\",",
30 |             "bar=foobar, ",
31 |             "response=dfe56131d1958046689d83306477ecc"
32 |         )),
33 |         Ok(NameValueTokenizer {
34 |             params: vec![
35 |                 ("foo", "1"),
36 |                 ("with_quotes", "1"),
37 |                 ("without_space", "1"),
38 |                 ("bar", "foobar"),
39 |                 ("response", "dfe56131d1958046689d83306477ecc"),
40 |             ]
41 |         })
42 |     );
43 | }
44 | 


--------------------------------------------------------------------------------
/tests/headers/tokenizers/token_list.rs:
--------------------------------------------------------------------------------
 1 | use rsip::headers::typed::{tokenizers::TokenListTokenizer, Tokenize};
 2 | 
 3 | #[test]
 4 | fn tokenizer1() {
 5 |     assert_eq!(
 6 |         TokenListTokenizer::tokenize("ACK"),
 7 |         Ok(TokenListTokenizer {
 8 |             tokens: vec!["ACK"],
 9 |         })
10 |     );
11 | }
12 | 
13 | #[test]
14 | fn tokenizer2() {
15 |     assert_eq!(
16 |         TokenListTokenizer::tokenize(" ACK "),
17 |         Ok(TokenListTokenizer {
18 |             tokens: vec!["ACK"],
19 |         })
20 |     );
21 | }
22 | 
23 | #[test]
24 | fn tokenizer3() {
25 |     assert_eq!(
26 |         TokenListTokenizer::tokenize("foo, ACK "),
27 |         Ok(TokenListTokenizer {
28 |             tokens: vec!["foo", "ACK"],
29 |         })
30 |     );
31 | }
32 | 
33 | #[test]
34 | fn tokenizer4() {
35 |     assert_eq!(
36 |         TokenListTokenizer::tokenize(" foo , ACK "),
37 |         Ok(TokenListTokenizer {
38 |             tokens: vec!["foo", "ACK"],
39 |         })
40 |     );
41 | }
42 | 


--------------------------------------------------------------------------------
/tests/headers/tokenizers/value.rs:
--------------------------------------------------------------------------------
 1 | use rsip::headers::typed::{tokenizers::ValueTokenizer, Tokenize};
 2 | 
 3 | #[test]
 4 | fn tokenizer1() {
 5 |     assert_eq!(
 6 |         ValueTokenizer::tokenize("testrealm@host.com"),
 7 |         Ok(ValueTokenizer {
 8 |             value: "testrealm@host.com"
 9 |         })
10 |     );
11 | }
12 | 


--------------------------------------------------------------------------------
/tests/headers/tokenizers/warning.rs:
--------------------------------------------------------------------------------
 1 | use rsip::headers::typed::{tokenizers::WarningTokenizer, Tokenize};
 2 | 
 3 | #[test]
 4 | fn tokenizer1() {
 5 |     assert_eq!(
 6 |         WarningTokenizer::tokenize("301 isi.edu \"Incompatible network address type 'E.164'\""),
 7 |         Ok(WarningTokenizer {
 8 |             code: "301",
 9 |             host: "isi.edu",
10 |             text: "Incompatible network address type 'E.164'",
11 |         })
12 |     );
13 | }
14 | 
15 | #[test]
16 | fn tokenizer2() {
17 |     assert_eq!(
18 |         WarningTokenizer::tokenize("307 isi.edu Session parameter 'foo' not understood"),
19 |         Ok(WarningTokenizer {
20 |             code: "307",
21 |             host: "isi.edu",
22 |             text: "Session parameter 'foo' not understood",
23 |         })
24 |     );
25 | }
26 | 


--------------------------------------------------------------------------------
/tests/headers/via/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod tokenizer;
2 | pub mod typed;
3 | 
4 | use rsip::headers::Via;
5 | 
6 | validate_untyped_header_trait!(Via);
7 | validate_to_typed_header_trait!(Via);
8 | 


--------------------------------------------------------------------------------
/tests/headers/via/tokenizer.rs:
--------------------------------------------------------------------------------
 1 | use rsip::{
 2 |     common::uri,
 3 |     headers::typed::{via::Tokenizer, Tokenize},
 4 | };
 5 | 
 6 | #[test]
 7 | fn tokenizer1() {
 8 |     assert_eq!(
 9 |         Tokenizer::tokenize("SIP/2.0/TLS client.biloxi.example.com:5061;branch=z9hG4bKnashds7"),
10 |         Ok(Tokenizer {
11 |             version: ("2", "0").into(),
12 |             transport: "TLS".into(),
13 |             uri: uri::Tokenizer {
14 |                 scheme: None,
15 |                 auth: None,
16 |                 host_with_port: ("client.biloxi.example.com", Some("5061")).into(),
17 |                 params: vec![],
18 |                 headers: None,
19 |                 ..Default::default()
20 |             },
21 |             params: vec![("branch", Some("z9hG4bKnashds7")).into()],
22 |         })
23 |     );
24 | }
25 | 


--------------------------------------------------------------------------------
/tests/headers/via/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::{
 2 |     common::{
 3 |         uri::{self, param::Branch, HostWithPort, Param},
 4 |         Transport, Version,
 5 |     },
 6 |     headers::typed::{via::Tokenizer, Via},
 7 | };
 8 | use std::convert::TryInto;
 9 | 
10 | validate_typed_header_trait!(Via);
11 | 
12 | mod display {
13 |     use super::*;
14 | 
15 |     #[test]
16 |     fn display1() {
17 |         assert_eq!(
18 |             format!(
19 |                 "{}",
20 |                 Via {
21 |                     version: Version::V2,
22 |                     transport: Transport::Tls,
23 |                     uri: HostWithPort::from(("client.biloxi.example.com", Some(5061))).into(),
24 |                     params: vec![Param::Branch(Branch::new("z9hG4bKnashds7"))]
25 |                 }
26 |             ),
27 |             String::from("SIP/2.0/TLS client.biloxi.example.com:5061;branch=z9hG4bKnashds7")
28 |         )
29 |     }
30 | }
31 | 
32 | mod try_from_tokenizer {
33 |     use super::*;
34 | 
35 |     #[test]
36 |     fn try_from_1() {
37 |         assert_eq!(
38 |             Tokenizer {
39 |                 version: ("2", "0").into(),
40 |                 transport: "TLS".into(),
41 |                 uri: uri::Tokenizer {
42 |                     scheme: None,
43 |                     auth: None,
44 |                     host_with_port: ("client.biloxi.example.com", Some("5061")).into(),
45 |                     params: vec![],
46 |                     headers: None,
47 |                     ..Default::default()
48 |                 },
49 |                 params: vec![("branch", Some("z9hG4bKnashds7")).into()],
50 |             }
51 |             .try_into(),
52 |             Ok(Via {
53 |                 version: Version::V2,
54 |                 transport: Transport::Tls,
55 |                 uri: HostWithPort::from(("client.biloxi.example.com", Some(5061))).into(),
56 |                 params: vec![Param::Branch(Branch::new("z9hG4bKnashds7"))]
57 |             })
58 |         );
59 |     }
60 | }
61 | 


--------------------------------------------------------------------------------
/tests/headers/warning/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod typed;
2 | 
3 | use rsip::headers::Warning;
4 | 
5 | validate_untyped_header_trait!(Warning);
6 | validate_to_typed_header_trait!(Warning);
7 | 


--------------------------------------------------------------------------------
/tests/headers/warning/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::common::Uri;
 2 | use rsip::headers::typed::{tokenizers::WarningTokenizer, Tokenize, Warning};
 3 | use std::convert::{TryFrom, TryInto};
 4 | 
 5 | validate_typed_header_trait!(Warning);
 6 | 
 7 | mod display {
 8 |     use super::*;
 9 | 
10 |     #[test]
11 |     fn display1() {
12 |         assert_eq!(
13 |             Warning {
14 |                 code: 307,
15 |                 uri: Uri::try_from("isi.edu").unwrap(),
16 |                 text: "Session parameter 'foo' not understood".into()
17 |             }
18 |             .to_string(),
19 |             String::from("307 isi.edu \"Session parameter 'foo' not understood\"")
20 |         );
21 |     }
22 | 
23 |     #[test]
24 |     fn display2() {
25 |         assert_eq!(
26 |             Warning {
27 |                 code: 301,
28 |                 uri: Uri::try_from("isi.edu").unwrap(),
29 |                 text: "\"Incompatible network address type 'E.164'\"".into()
30 |             }
31 |             .to_string(),
32 |             String::from("301 isi.edu \"Incompatible network address type 'E.164'\"")
33 |         );
34 |     }
35 | }
36 | 
37 | mod try_from_tokenizer {
38 |     use super::*;
39 | 
40 |     #[test]
41 |     fn try_from_1() -> Result<(), rsip::Error> {
42 |         let tokenizer =
43 |             WarningTokenizer::tokenize("307 isi.edu \"Session parameter 'foo' not understood\"")?;
44 | 
45 |         assert_eq!(
46 |             tokenizer.try_into(),
47 |             Ok(Warning {
48 |                 code: 307,
49 |                 uri: Uri::try_from("isi.edu").unwrap(),
50 |                 text: "Session parameter 'foo' not understood".into()
51 |             })
52 |         );
53 | 
54 |         Ok(())
55 |     }
56 | 
57 |     #[test]
58 |     fn try_from_2() -> Result<(), rsip::Error> {
59 |         let tokenizer =
60 |             WarningTokenizer::tokenize("301 isi.edu Incompatible network address type 'E.164'")?;
61 | 
62 |         assert_eq!(
63 |             tokenizer.try_into(),
64 |             Ok(Warning {
65 |                 code: 301,
66 |                 uri: Uri::try_from("isi.edu").unwrap(),
67 |                 text: "Incompatible network address type 'E.164'".into()
68 |             })
69 |         );
70 | 
71 |         Ok(())
72 |     }
73 | }
74 | 


--------------------------------------------------------------------------------
/tests/headers/www_authenticate/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod typed;
2 | 
3 | use rsip::headers::WwwAuthenticate;
4 | 
5 | validate_untyped_header_trait!(WwwAuthenticate);
6 | validate_to_typed_header_trait!(WwwAuthenticate);
7 | 


--------------------------------------------------------------------------------
/tests/headers/www_authenticate/typed.rs:
--------------------------------------------------------------------------------
 1 | use rsip::headers::{
 2 |     auth,
 3 |     typed::{www_authenticate::Tokenizer, WwwAuthenticate},
 4 | };
 5 | use std::convert::TryInto;
 6 | 
 7 | validate_typed_header_trait!(WwwAuthenticate);
 8 | 
 9 | #[test]
10 | fn display() -> Result<(), rsip::Error> {
11 |     use rsip::headers::auth;
12 | 
13 |     assert_eq!(
14 |         format!(
15 |             "{}",
16 |             WwwAuthenticate {
17 |                 scheme: auth::Scheme::Digest,
18 |                 realm: "http-auth@example.org".into(),
19 |                 nonce: "7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v".into(),
20 |                 algorithm: Some(auth::Algorithm::Sha256),
21 |                 qop: Some(auth::Qop::Auth),
22 |                 opaque: Some("FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS".into()),
23 |                 domain: None,
24 |                 stale: None,
25 |                 charset: None
26 |             }
27 |         ),
28 |         String::from(concat!(
29 |             "Digest ",
30 |             "realm=\"http-auth@example.org\", ",
31 |             "nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\", ",
32 |             "opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\", ",
33 |             "algorithm=SHA256, ",
34 |             "qop=\"auth\"",
35 |         ))
36 |     );
37 | 
38 |     Ok(())
39 | }
40 | 
41 | #[test]
42 | fn from_tokenizer() {
43 |     assert_eq!(
44 |         Tokenizer {
45 |             scheme: "Digest".into(),
46 |             params: vec![
47 |                 ("realm", "testrealm@host.com"),
48 |                 ("qop", "auth"),
49 |                 ("nonce", "dcd98b7102dd2f0e8b11d0f600bfb0c093"),
50 |                 ("opaque", "5ccc069c403ebaf9f0171e9517f40e41"),
51 |             ],
52 |         }
53 |         .try_into(),
54 |         Ok(WwwAuthenticate {
55 |             scheme: auth::Scheme::Digest,
56 |             realm: "testrealm@host.com".into(),
57 |             domain: None,
58 |             nonce: "dcd98b7102dd2f0e8b11d0f600bfb0c093".into(),
59 |             opaque: Some("5ccc069c403ebaf9f0171e9517f40e41".into()),
60 |             stale: None,
61 |             algorithm: None,
62 |             qop: Some("auth".try_into().expect("auth qop")),
63 |             charset: None
64 |         })
65 |     );
66 | }
67 | 


--------------------------------------------------------------------------------
/tests/lib.rs:
--------------------------------------------------------------------------------
 1 | fn untyped_traits_check<'a, T: rsip::headers::untyped::UntypedHeader<'a>>() {}
 2 | fn to_typed_traits_check<'a, T: rsip::headers::untyped::ToTypedHeader<'a>>() {}
 3 | fn typed_traits_check<'a, T: rsip::headers::typed::TypedHeader<'a>>() {}
 4 | 
 5 | macro_rules! validate_untyped_header_trait {
 6 |     ($name:ident) => {
 7 |         #[test]
 8 |         fn validate_untyped_header_trait() {
 9 |             crate::untyped_traits_check::<$name>();
10 |         }
11 |     };
12 | }
13 | 
14 | macro_rules! validate_to_typed_header_trait {
15 |     ($name:ident) => {
16 |         #[test]
17 |         fn validate_to_typed_header_trait() {
18 |             crate::to_typed_traits_check::<$name>();
19 |         }
20 |     };
21 | }
22 | 
23 | macro_rules! validate_typed_header_trait {
24 |     ($name:ident) => {
25 |         #[test]
26 |         fn validate_typed_header_trait() {
27 |             crate::typed_traits_check::<$name>();
28 |         }
29 |     };
30 | }
31 | 
32 | pub mod common;
33 | pub mod headers;
34 | pub mod message;
35 | pub mod services;
36 | pub mod support;
37 | 


--------------------------------------------------------------------------------
/tests/message/has_headers.rs:
--------------------------------------------------------------------------------
 1 | use rsip::{headers::*, message::HeadersExt};
 2 | 
 3 | #[test]
 4 | fn headers() {
 5 |     //TODO: start using randomized stuff/traits
 6 |     let via = Via::new("SIP/2.0/TLS client.biloxi.example.com:5061;branch=z9hG4bKnashd92");
 7 |     let max_forwards = MaxForwards::new("70");
 8 |     let to = To::new("Bob <sips:bob@biloxi.example.com>");
 9 |     let from = From::new("Bob <sips:bob@biloxi.example.com>;tag=ja743ks76zlflH");
10 |     let call_id = CallId::new("1j9FpLxk3uxtm8tn@biloxi.example.com");
11 |     let cseq = CSeq::new("2 REGISTER");
12 |     let contact = Contact::new("<sips:bob@client.biloxi.example.com>");
13 |     let authorization = Authorization::new("Digest username=\"bob\", realm=\"atlanta.example.com\" nonce=\"ea9c8e88df84f1cec4341ae6cbe5a359\", opaque=\"\" uri=\"sips:ss2.biloxi.example.com\", response=\"dfe56131d1958046689d83306477ecc\"");
14 |     let content_length = ContentLength::new("0");
15 | 
16 |     let headers: rsip::headers::Headers = vec![
17 |         via.clone().into(),
18 |         max_forwards.clone().into(),
19 |         from.clone().into(),
20 |         to.clone().into(),
21 |         call_id.clone().into(),
22 |         cseq.clone().into(),
23 |         contact.clone().into(),
24 |         authorization.clone().into(),
25 |         content_length.clone().into(),
26 |     ]
27 |     .into();
28 | 
29 |     let implementer = crate::support::HasHeadersImpl(headers);
30 | 
31 |     assert_eq!(implementer.via_header(), Ok(&via));
32 |     assert_eq!(implementer.max_forwards_header(), Ok(&max_forwards));
33 |     assert_eq!(implementer.to_header(), Ok(&to));
34 |     assert_eq!(implementer.from_header(), Ok(&from));
35 |     assert_eq!(implementer.call_id_header(), Ok(&call_id));
36 |     assert_eq!(implementer.cseq_header(), Ok(&cseq));
37 |     assert_eq!(implementer.contact_header(), Ok(&contact));
38 |     assert_eq!(implementer.authorization_header(), Some(&authorization));
39 | }
40 | 


--------------------------------------------------------------------------------
/tests/message/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod has_headers;
2 | pub mod message;
3 | pub mod request;
4 | pub mod response;
5 | 


--------------------------------------------------------------------------------
/tests/services/auth.rs:
--------------------------------------------------------------------------------
 1 | use rsip::{
 2 |     common::{
 3 |         uri::{Host, HostWithPort},
 4 |         Method,
 5 |     },
 6 |     headers::auth::{Algorithm, AuthQop},
 7 |     services::DigestGenerator,
 8 | };
 9 | 
10 | #[test]
11 | fn digest() {
12 |     let uri: HostWithPort = Host::from("/dir/index.html").into();
13 | 
14 |     let auth_qop = AuthQop::Auth {
15 |         cnonce: "0a4f113b".into(),
16 |         nc: 1,
17 |     };
18 | 
19 |     let generator = DigestGenerator {
20 |         username: "Mufasa",
21 |         password: "Circle Of Life",
22 |         algorithm: Algorithm::Md5,
23 |         nonce: "dcd98b7102dd2f0e8b11d0f600bfb0c093",
24 |         method: &Method::Register,
25 |         qop: Some(&auth_qop),
26 |         uri: &uri.into(),
27 |         realm: "testrealm@host.com",
28 |     };
29 | 
30 |     assert_eq!("59d17b90f0e821045ecceb843e5b38c4", generator.compute());
31 |     assert_eq!(generator.verify("59d17b90f0e821045ecceb843e5b38c4"), true);
32 | }
33 | 


--------------------------------------------------------------------------------
/tests/services/mod.rs:
--------------------------------------------------------------------------------
1 | pub mod auth;
2 | 


--------------------------------------------------------------------------------
/tests/support/has_headers_impl.rs:
--------------------------------------------------------------------------------
 1 | pub struct HasHeadersImpl(pub rsip::headers::Headers);
 2 | 
 3 | impl rsip::message::HasHeaders for HasHeadersImpl {
 4 |     fn headers(&self) -> &rsip::headers::Headers {
 5 |         &self.0
 6 |     }
 7 | 
 8 |     fn headers_mut(&mut self) -> &mut rsip::headers::Headers {
 9 |         &mut self.0
10 |     }
11 | }
12 | 
13 | impl rsip::message::HeadersExt for HasHeadersImpl {}
14 | 


--------------------------------------------------------------------------------
/tests/support/mod.rs:
--------------------------------------------------------------------------------
1 | mod has_headers_impl;
2 | 
3 | pub use has_headers_impl::HasHeadersImpl;
4 | 


--------------------------------------------------------------------------------